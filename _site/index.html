<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>柯小小西</title>
    <meta name="description" content="">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_8v3czwksspqlg14i.css">
    <link rel="stylesheet" href="/css/main.css ">
    <link rel="canonical" href="http://localhost:4000/">
    <link rel="alternate" type="application/rss+xml" title="柯小小西" href="http://localhost:4000/feed.xml ">


    <script>
    // 百度统计代码
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?a9b0f47a0e50b02dafb8a7088436a9bc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>




</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">柯小小西</a>
        <small>留着一点点技术积蓄</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                    <a class="active" href="/">
                        
                        <i class="fa fa-home"></i>Home
                    </a>
                </li>

                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>Archives
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>Categories
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/tag/">
                        
                            <i class="fa fa-tags"></i>Tags
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/about/">
                        
                            <i class="fa fa-heart"></i>About
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" index>
    <div class="left">
        <h1>Welcome to 柯小小西's Blog!</h1>
        <small>留着一点点技术积蓄</small>
        <hr>
        <ul>
            
              <li>
                <h2>
                  <a class="post-link" href="/2017/03/29/java-server-in-action/">深入浅出Java服务端原理之基础篇</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2017-03-29
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#java" title="Category: java" rel="category">java</a>&nbsp;
    
        <a href="/category/#socket" title="Category: socket" rel="category">socket</a>&nbsp;
    
        <a href="/category/#thrift" title="Category: thrift" rel="category">thrift</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <blockquote>
  <p>上篇文章介绍了<a href="http://ketao1989.github.io/2016/12/10/rpc-theory-in-action/">深入浅出RPC一些原理知识</a>，这里将继续深入讲讲关于RPC网络服务技术。本文的目标，是让对Java网络服务端开发感兴趣的新人，可以一步步深入了解一个高性能服务所需要的相关知识体系。</p>

  <p>当然，高性能高并发的服务端开发，涉及的知识点和手段众多，比如linux网络和内核参数调优等。本文只关注代码开发层级的介绍和深入。</p>
</blockquote>

<h2 id="前言">前言</h2>

<p>本文中，所谓 <code class="highlighter-rouge">服务端</code>指的是，基于client/server服务组件中的server端。在网络世界里，基本上任何一个用户交互都涉及客户端和服务器端网络通信；尤其是，当存在对服务端大量请求时，如果让服务器持续对外服务过程中，抗住更多的并发请求，是一个互联网开发同学十分关心和必备的技能。</p>

<p>本文中，首先会基于Java网络API开发一个<code class="highlighter-rouge">HelloWorld</code>版本的server端版本。<br />
接下来，会不断的在前一个server版本上进行优化和升级，使得其可以响应更多的网络连接请求。 <br />
在此期间，会引入一些概念，比如IO同步异步、阻塞非阻塞。<br />
最后，我们要站在巨人的肩膀上，基于Netty来开发一个生产级别的server端应用。</p>

<!-- more -->

<h2 id="网络协议介绍">网络协议介绍</h2>

<blockquote>
  <p>服务器开发，是基于网络协议基础上的，虽然Java 网络API已经封装了协议细节，但是在分析程序运行中出现的一些网络问题，优化服务通信性能时，还是很有用的。</p>

  <p>这里主要介绍传输层的两大协议：TCP和UDP协议。（深入的介绍，请参考 《TCP/IP 详解 卷1：协议》这本经典书籍。）一般应用定制所谓自定义的网络协议，基本上都是基于传输层来实现的。</p>
</blockquote>

<h3 id="tcp-协议">TCP 协议</h3>

<blockquote>
  <p>传输层主要有两大协议：面向连接的TCP (Transmission Control Protocol)协议和面向无连接的UDP (User Datagram Protocol)协议。相对于UDP协议，TCP为了保证连接的可靠性，其协议实现细节是相当复杂的。</p>
</blockquote>

<h4 id="三次握手四次握手">三次握手/四次握手</h4>

<p>既然TCP是面向连接的协议，那就存在如何建立连接以及如何断开连接的问题。</p>

<blockquote>
  <p>在介绍TCP连接协议前，需要特别指出：TCP所谓的处在连接状态<code class="highlighter-rouge">ESTABLISHED</code>，只是说明在通信双方建立的<code class="highlighter-rouge">连接状态表</code>中，当前的TCP链路是连接的。而且，通信双方的状态表，并不保证是一致的。
所以，在使用TCP协议的业务里，都需要有一个定时器来发送一个特殊的段给对等方检测当前链路是否依然处于连接状态，也就是<code class="highlighter-rouge">存活检测</code>。在后面的介绍中，还会有应用级别的<code class="highlighter-rouge">存活检测</code>。</p>
</blockquote>

<p>首先，在所有的介绍TCP协议的文章里都会有的握手图（来自网络，参考文献1）：</p>

<p><img src="/images/2017/tcp_open_close.jpeg" alt="Alt text" /></p>

<p>所谓三次握手，就是在通信双方建立TCP连接的时候，需要双方共发送3个数据包来确认双方为通信都准备OK。</p>

<ol>
  <li>第一次握手。客户端client首先初始化一个SYN序列号x，一般第一次客户端和服务端握手时，SYN初始化为0，随后每次都会加上传输数据的字节作为对端新的SYN序列号。Client将产生的SYN序列化发送给Server，并将自己的状态置为<code class="highlighter-rouge">SYN_SENT</code>。</li>
  <li>第二次握手。服务端Server接收到Client发送过来的连接请求包，由于在建立TCP连接的请求包中并没有有效数据(设置FIN和SYN这种标志位的包，是不计算有效数据的)，所以Server发送的握手包中，SYN序列号为0（Server对这次建立连接也是第一次），以及ACK确认号1=0+1。此外，服务器Server将自己的状态设置为<code class="highlighter-rouge">SYN_RCVD</code>。</li>
  <li>第三次握手。客户端Client接收到Server发送回来的确认包，根据服务端ACK号和SYN号，发送自己的最后一个连接数据包，其中和第二次握手相似，SYN序列号为1，ACK为1=0+1。并将自己的连接状态设置为<code class="highlighter-rouge">ESTABLISHED</code>。</li>
</ol>

<p>在TCP通信过程中，ACK数据，是根据对方SYN序列号，再加上本次数据包有效数据大小来计算的，而下次对端发送SYN序列号的值就是其收到的ACK值。SYN 和 ACK的逻辑，保证了TCP重传机制。</p>

<blockquote>
  <p>在了解TCP建立连接进行的三次握手过程之后，肯定会有疑问，为什么是3次，而不是2次或者4次呢？</p>

  <p>3次考虑，是在满足日常应用场景中，所需要的最少次数。1次肯定不行，如果是2次呢？假设 C 向 S 发送连接请求，当时这个请求没有到达 S 。然后 C 重新发送一个连接请求，S接收到并且发送响应包，然后连接建立。正常数据交换完了之后，关闭连接。但是，这个时候，第一次的连接请求发送了过来，S 建立连接，一直处于等待数据交互中。 
 或者，C 向 S 发送连接请求， 然后 S 会发送一个响应包，可能 C 可能没有收到这个响应包。这个时候，S 可能以为 C 收到了ACK包，然后S给C发送数据分组包，但是 C 一直在等待 S 的ACK应答分组包，并把 S 的数据分组报丢弃。
 其实，2次握手，最重要的是，在双方都以为建立连接的情况下，可能存在无法对S的序列号达成一致。但是，3次握手，就可以确认好 C 和 S 的初始序列号一致。</p>

  <p>以上可以阅读参考文献2。</p>
</blockquote>

<p>所谓的四次握手（也有叫做四次挥手的），就是处在连接状态的通信双方，正常断开连接所需要进行的四次数据包交互流程。由于TCP是全双工，因此通信双方都需要进行关闭，所以会进行4次握手。</p>
<ol>
  <li>第一次握手。客户端将发送FIN包给服务端，关闭连接。FIN包中，FIN序列号和ACK值与前面数据组交互一样。此时，客户端处于<code class="highlighter-rouge">FIN_WAIT_1</code>状态。</li>
  <li>第二次握手。服务端收到客户端的FIN包之后，只会发回一个ACK包，表示收到关闭连接请求。此时，服务端处于<code class="highlighter-rouge">CLOSE_WAIT</code>状态</li>
  <li>第三次握手。作为全双工链路，服务端也需要发送FIN包来关闭自己这方的连接链路。由于ACK已经发送，所以这一次只需要发送FIN序列号。此时，服务端处于<code class="highlighter-rouge">LAST_ACK</code>状态。</li>
  <li>第四次握手。客户端现在收到了服务端发送的FIN包，客户端发送ACK表示自己收到了服务端的关闭请求。此时，客户端处于<code class="highlighter-rouge">TIME_WAIT</code>状态；而服务端收到客户端ACK包之后，则设置自己状态为<code class="highlighter-rouge">CLOSED</code>。客户端的<code class="highlighter-rouge">TIME_WAIT</code>状态会停留两倍的MSL时长。</li>
</ol>

<blockquote>
  <p>MSL指的是报文段的最大生存时间，如果报文段在网络通信中存活时间超过MSL时间，还没有被接收，那么会被丢弃。关于<code class="highlighter-rouge">TIME_WAIT</code>深入学习可以参考文献3</p>
</blockquote>

<h4 id="tcp-重传机制">TCP 重传机制</h4>

<blockquote>
  <p>TCP重传机制，是TCP协议保证数据可靠性的一个重要的机制。在网络环境不好的情况下，重传机制可以对上层应用层，屏蔽掉因为各种网络问题导致超时数据丢失而进行重试的策略细节。但是，正式由于屏蔽，导致很多时间排查问题时会忽略掉这点。</p>

  <p>此外，其实在很多系统设计过程中，重传重试相关的需求还是蛮多的。学习TCP重传机制，可以给我们在设计实现自己的应用系统时提供一些借鉴。</p>
</blockquote>

<p>TCP重传机制，需要确认什么时候需要重传，以及重传哪些数据包。</p>

<p>TCP需要重传，肯定是在数据包丢失之后才需要重传，将发送端认为服务端未收到的报文重新发送给接收端。但是，在不可靠的网络环境下，你根本就无法确认数据包是否丢失，通过TCP ACK机制只能确保哪些数据报文被通信对方收到，但是由于接收报文是乱序的，所以当前未收到的报文可能在未来某个时候被ACK回来，也可能就真的被丢失了。</p>

<p>因此，TCP在发送报文之后，会开启一个定时器，然后如果在计算的超时时间内未收到ACK，则重传。所以，TCP重传机制，有的时候也被称为 TCP超时重传机制。</p>

<p>超时重传机制，包含两个重要的时间参数。</p>
<ul>
  <li>往返时间RTT。其是发送端发送TCP包开始计算，到接收到该包ACK数据结束，这期间所消耗的时间。</li>
  <li>超时重传时间RTO。其是，发送端发送TCP包之后，确认包丢失，然后决定重新发送该包的时间。</li>
</ul>

<p>显然，我们需要的是RTO时间，根据这个时间我们来确认是否应该超时重传了。但是RTO是动态计算出来的，也就是我们需要根据当前网络状况的不同，计算出RTO时间。因此，就说到了RTT，异常的超时时间，根据正常包往返时间来动态计算，是比较合理的。RTO初始的计算方式，就是取若干次RTT的平均时间，最小200ms，后面随着重传次数的变化，RTO也会调整。</p>

<blockquote>
  <p>因此，整个流程是这样子的：发送端发送TCP报文，并且启动该报文对应的重传计时器，如果收到了ACK报文，则结束计时器，并且获得最新一次的RTT，计算RTO；如果没有收到ACK报文，并且这时间已经超过当前RTO设置，则重传报文，并且RTO时间倍增。如果，倍增之后，ACK报文还未收到，则继续倍增，直到收到或者到达设置的最大RTO超时时间。</p>

  <p>在LINUX中，重传此时一般为15次。</p>
</blockquote>

<p>此外，还有一种也会触发报文重传。比如，发送端先后发送了A：<code class="highlighter-rouge">seq=100,size=100</code>；B：<code class="highlighter-rouge">seq=200,size=200</code>；C：<code class="highlighter-rouge">seq=400,size=150</code> 三个报文，然后接收方，返回了A’：<code class="highlighter-rouge">ack=200</code>；B’=<code class="highlighter-rouge">ack=200</code>；C’=<code class="highlighter-rouge">ack=200</code>。那么这个时候，就不会等待RTO超时了，而是发送端会认为接收端明显没有收到seq=200的报文，立刻触发<code class="highlighter-rouge">快速重传机制</code>，发送丢失的数据报文。</p>

<h4 id="tcp-滑动窗口">TCP 滑动窗口</h4>

<blockquote>
  <p>除了重传机制，TCP另一大亮点，就是滑动窗口。其滑动窗口可以很好的保护系统可靠性，避免大流量数据导致大量传输失败，限制传输速度以及网络带宽和服务器资源的有效利用。在实际应用系统设计中，也可以充分借鉴参考。</p>
</blockquote>

<p>TCP 使用接收方接收窗口来控制通信的数据流速率，从而达到拥塞控制，避免通信过程中不必要的丢包处理。</p>

<p>首先来看下TCP报文头结构：</p>

<p><img src="/images/2017/tcp_header.gif" alt="Alt text" /></p>

<p>如上图所示，在20字节长的报文头里面，有16bit是接收方用来告诉客户端其可接收数据的大小，发送方根据这个数据，来控制发送给接收方的数据长度。</p>

<p>看一个简单的例子了解下：</p>

<p><img src="/images/2017/tcp_window.png" alt="Alt text" /></p>

<p>首先，在和接收端最后一次通信的时候，发送端从TCP报头中获取了剩余窗口为500，表示发送端可以发送500字节的数据给接收方；
然后，发送端发送400字节数据，其中seq=1到seq=200之间的数据已经ACK确认，seq=201到seq=400发送出去但是还未被确认。于是，可发送滑动窗口头部从<code class="highlighter-rouge">1--&gt;201</code>，尾部从<code class="highlighter-rouge">500--&gt;700</code>，如上图(b)；
接着发送端收到了接收端seq=201到seq=400的ACK报文，这个时候，滑动窗口继续向后滑动。</p>

<blockquote>
  <p>需要指出一种特殊的情形，就是当发送端发送数据过快，接收端还未来得及处理时，就会出现接收端返回报头中窗口为0的情形，这就是<code class="highlighter-rouge">Zero Window</code>。显然，这种情况，发送端会停止发送数据，知道窗口不为0。然后就有了<code class="highlighter-rouge">ZWP</code>技术，当自己的大小不为0，接收端ACK他的窗口大小给发送端 。</p>
</blockquote>

<p>但是，基于滑动窗口会出现一个问题，就是当接收端处理速度比较慢，可能每次就只能处理很小字节的报文，然后告诉发送端，其剩余窗口为很小的数字。但是，一个TCP+IP头是40个字节，显然，如果窗口不为0就发送报文给接收端，是不可取的。</p>

<p>那如何避免在窗口很小的时候，频繁发送小传输报文给接收端呢？在TCP中，称为Silly Window Syndrome(糊涂窗口综合症)。解决方案可以是在特定时刻接收端ACK窗口为0或者发送端累计一部分报文之后在发送给接收端。</p>

<p>一般，我们在发送端控制比较方便。因此，就出现了<code class="highlighter-rouge">Nagle算法</code>。首先引入MSS概念：</p>
<ul>
  <li>MSS：Maximum Segment Size，也就是最大分段大小。为了达到最佳的传输效能，TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往用MTU（最大数据包大小，以太网的MTU为1500）代替（需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes），所以一般MSS值1460。</li>
</ul>

<p>Nagle 算法的规则：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> [1]如果包长度达到 MSS ，则允许发送；
 [2]如果该包含有 FIN ，则允许发送；
 [3]设置了 TCP_NODELAY 选项，则允许发送；
 [4]设置 TCP_CORK 选项时，若所有发出去的小数据包（包长度小于 MSS ）均被确认，则允许发送；
 [5]上述条件都未满足，但发生了超时（一般为 200ms ），则立即发送。
</code></pre></div></div>
<blockquote>
  <p>从上面的规则可以看到，我们再开发应用层代码的时候，如果应用场景需要实时发送各种小报文数据，则需要将Socket的TCP_NODELAY设置为true，否则可能会由于报文太小，而导致数据一直未发送出去。</p>
</blockquote>

<p>滑动窗口目前看来，控制发送端发送速率来保护接收端系统是足够了的；但是，滑动窗口，还需要满足解决网络拥塞控制，因此需要更进一步。</p>

<p>上文介绍过TCP通过采样了RTT时间然后计算出RTO，作为重传超时时间。但是，如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，显然，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，最后，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。</p>

<p>因此，就出现TCP Reno算法，包含4个部分：</p>
<ol>
  <li>慢热启动算法 – Slow Start。就是在发送端刚刚接入网络的时候，不会立刻将发送报文量提升到很大的值，而是慢慢试探网络，以每个RTT<code class="highlighter-rouge">X2</code>的指数来提速，或者当收到一个ACK则<code class="highlighter-rouge">+1</code>提速。在Linux 3.0 中，初始的发送大小为10个MSS。</li>
  <li>拥塞避免算法 – Congestion Avoidance。当指数增长到最大阈值ssthresh=65535，则会对发送速率进行调整ssthresh为当前速率/2。然后回到慢启动过程。此外，很可能在这个时候会出现RTO超时情况，然后进入快速重传。</li>
  <li>快速重传 - Fast Retransimit。调整ssthresh为当前速率/2，并且当前速率也调整为当前速率/2。然后进入拥塞避免阶段。</li>
  <li>快速恢复算法 – Fast Recovery。</li>
</ol>

<p>基于以上的算法来调整发送端发送报文的速率，可以很好感知网络当前的负载情况，将网络延时导致重传超时作为一个影响因子，来控制网络拥塞。</p>

<blockquote>
  <p>其实，在使用很多工具的时候，都会明显感觉到<code class="highlighter-rouge">Reno</code>算法的存在。比如在下载文件的时候，下载速度都是逐步增加到一定速率。
 关于TCP具体拥塞算法，可以参加文献4</p>
</blockquote>

<h4 id="tcp-存活检测">TCP 存活检测</h4>

<blockquote>
  <p>上面讲的东西，都比较理论，应用开发中相对用的比较少。这里，介绍一个在开发应用层网络程序时，需要考虑的知识点。</p>
</blockquote>

<p>在前文中说过，TCP由于其内部只是维护了本身的状态表，并不能实时通知当前网络断开的消息。之所以，TCP不去提供这个实时通知网络变化的原因，有2个：</p>
<ol>
  <li>这样会消耗掉大量的网络带宽，试想若存在着大量的不成熟的网络应用程序，网络带宽一定会消耗殆尽；</li>
  <li>在TCP设计之初，美国国防部设计TCP就是为了让在网络中断的情况下仍然通过其它途径维持通信的能力。
不过，在Linux中，提供了<code class="highlighter-rouge">KEEP_ALIVE</code>机制去检测TCP的存活状态。</li>
</ol>

<p>这种KEEP_ALIVE机制下，TCP会在连接空闲一定时间间隔（一般时间为 7200 s，失败后重试 10 次，每次超时时间 75 s。）后发送一个特殊的段给通信对方，若对方系统依然运行，对应端口对外接收数据，则会响应并发送一个ACK消息。</p>

<p>KEEP_ALIVE 可以很好的检测连接是否存活。但是在实际应用中，其存在两个问题：</p>
<ol>
  <li>TCP默认的间隔时间有点过长，在我们日常环境中，使用这种默认时间来检测连接是否存活，是不行的。</li>
  <li>TCP KEEP_ALIVE方式的存活检测，只是针对连接，而不是针对通信双方应用系统的。也就是，即使检测的连接是活跃的，但是可能对应的系统已经100%CPU，无法接收真实的应用处理了。</li>
</ol>

<p>因此，一般的应用服务器实现中，都是使用自己的心跳机制来保证应用的存活。</p>

<blockquote>
  <p>应用心跳存活机制，是由应用定时周期发送心跳包给对方，这里就涉及到频率的问题了。如果时间设置的太长，则起不到实时感知网络是否端口。如果时间太短，则会导致数据量过大，增加网络和接收方负担。
此外，在移动智能设备占主导地位的今天，移动网络的不稳定，流量和电量的消耗，都要求心跳频率不能太频繁。</p>

  <p>因此，在APP端，一般如果应用正在前台使用，则心跳会相对频繁，比如30s一次，如果app被推到后台时，则心跳间隔时间可以调整大点，比如10分钟一次。</p>
</blockquote>

<h3 id="udp-协议">UDP 协议</h3>

<p>相对于TCP协议，UDP协议非常简单。UDP是面向无连接的，不需要在传送数据之前通过握手协议来建立连接；UDP是不可靠的协议，其不保证数据最后被交付到目的主机，因此也就没有ACK报文来告知发送端发送的数据是否成功。</p>

<p>此外，UDP如名字那样，面向报文的，也就是UDP包不会进行拆分或合并，没有TCP的拥塞控制和重传机制。重要的一点是，UDP报文头只占用8个字节，而TCP需要占用20个字节。</p>

<blockquote>
  <p>在TCP中，我们谈到，说TCP的连接其实只是在其双方内存表里面有个一对一连接状态的维护，并不是真的建立了一条链路。而，UDP无连接的，也只是说在UDP中不存在一个一对一连接链路状态的维护，UDP可以通过socket给多个UDP端发送数据，也可以接受多个UDP端发送过来的数据，如果UDP客户端和服务端都只接收和发送该一个socket的数据，那么可以说，其实“虚连接”的。</p>

  <p>不过需要注意的是，在TCP中，基于这个连接上有一堆的机制和算法来保证连接可靠性，这个是UDP没有的。所以TCP和UDP最大的不同，是一个是可靠的协议，一个是非可靠的。</p>
</blockquote>

<p>UDP的不可靠，使得其适应一些特殊的应用场景。</p>
<ol>
  <li>实时要求高的场景。比如视频通信。在视频直播过程中，用户是可以接受一些帧的数据包的丢失，相对而言，其无法接受一些过时的数据重放，因此业务基于UDP协议进行一些额外补充，满足一些实时性要求高的业务。</li>
  <li>在很早以前，由于国内的网络不是很好，导致TCP协议并不能很好的发挥其稳定性的特性，并且UDP无连接以及报头小等特性，使得服务器可以支持更高的用户量。具体可以参考文献5。</li>
</ol>

<blockquote>
  <p>虽然，QQ使用的是UDP通信，TCP一个链路维护其他信息；但是对于现如今，这种设计模式并不一定性价比最高。所以，微信的通信，就是基于TCP来完成的，而不是UDP协议。</p>
</blockquote>

<h2 id="java-server入门">Java Server入门</h2>

<blockquote>
  <p>基于Java JDK提供的网络API开发简单的服务器是很便捷的，其封装的API接口对于开发者而已，非常易用。</p>
</blockquote>

<h3 id="echo-服务端">ECHO 服务端</h3>

<p>和其他很多文章介绍网络编程一样，这里我们也首先实现一个echo服务器示例。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startServer</span><span class="o">(</span><span class="kt">int</span> <span class="n">port</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">//创建serverSocket来监听port</span>
            <span class="n">ServerSocket</span> <span class="n">serverSocket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ServerSocket</span><span class="o">(</span><span class="n">port</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>

                <span class="c1">// 建立一个socket连接</span>
                <span class="n">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="n">serverSocket</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"new connect......"</span><span class="o">);</span>

                <span class="k">try</span> <span class="o">(</span><span class="n">InputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span> <span class="n">OutputStream</span> <span class="n">os</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">())</span> <span class="o">{</span>

                    <span class="c1">// 连接成功，返回连接成功消息给客户端</span>
                    <span class="n">os</span><span class="o">.</span><span class="na">write</span><span class="o">((</span><span class="s">"SERVER CONN OK!"</span> <span class="o">+</span> <span class="k">new</span> <span class="n">Date</span><span class="o">().</span><span class="na">toString</span><span class="o">()</span> <span class="o">+</span> <span class="s">"\n\r"</span><span class="o">).</span><span class="na">getBytes</span><span class="o">(</span><span class="n">Charset</span><span class="o">.</span><span class="na">defaultCharset</span><span class="o">()));</span>
                    <span class="n">os</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>

                    <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">16</span><span class="o">];</span>
                    <span class="kt">int</span> <span class="n">len</span><span class="o">;</span>

                    <span class="k">while</span> <span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">is</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">data</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>

                        <span class="c1">// 读取数据，将数据打印出来</span>
                        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">,</span> <span class="n">Charset</span><span class="o">.</span><span class="na">defaultCharset</span><span class="o">()));</span>
                        <span class="c1">// echo反馈给客户端</span>
                        <span class="n">os</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
                        <span class="n">os</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>
<blockquote>
  <p>代码展示的是一个单线程同步阻塞方式处理网络Socket IO操作的echo服务器版本，所以当客户端连接上服务器之后，其他客户端是不能同时操作网络IO的。</p>

  <p>此外，需要特别说明在 <code class="highlighter-rouge">public ServerSocket(int port, int backlog) throws IOException</code>方法中的backlog，在测试的时候，可以更清楚知道该参数含义：网络连接的等待队列的最大长度。</p>
</blockquote>

<p>我们使用 Telnet模拟客户端进行测试，结果如下图所示：</p>

<p><img src="/images/2017/socket_backlog.png" alt="Alt text" /></p>

<blockquote>
  <p>在代码中，我们将backlog设为1，所以，如上图，当我们1个网络IO操作处理中，1个处在网络连接等待队列中，最后1个网络连接请求由于等待队列已满，从而<code class="highlighter-rouge">创建网络连接操作超时</code>而导致最终失败，所以会出现<code class="highlighter-rouge">Operation timed out</code>。</p>
</blockquote>

<p>因此，我们看出来了这个版本的显著的缺点，就是无法同时处理多个网络请求。</p>

<h3 id="多线程版本-echo服务端">多线程版本 ECHO服务端</h3>

<p>显然，服务器只能同时处理单个客户端网络请求，肯定是不行的。从代码上分析，程序阻塞的地方，是服务器从socket流中获取数据，然后处理数据返回数据等同步阻塞的IO操作。由于是单线程来处理这些IO操作，所以线程阻塞，就会导致其他网络请求无法响应处理，因此，显然的，就会才有多线程来避免这个问题。</p>

<blockquote>
  <p>在实现多线程处理请求的时候，一般才有线程池来完成；并且，线程池的大小还需要进行一个限制，避免请求量过大，导致机器资源耗尽不可用。</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadPoolServer</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ExecutorService</span> <span class="n">EXECUTOR_SERVICE</span> <span class="o">=</span> <span class="n">createDefaultExecutorService</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ThreadPoolServer</span> <span class="n">server</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThreadPoolServer</span><span class="o">();</span>
        <span class="n">server</span><span class="o">.</span><span class="na">startServer</span><span class="o">(</span><span class="mi">8080</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startServer</span><span class="o">(</span><span class="kt">int</span> <span class="n">port</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">ServerSocket</span> <span class="n">serverSocket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ServerSocket</span><span class="o">(</span><span class="n">port</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span>

            <span class="c1">// 设置超时无限大，保证在accept不阻塞</span>
            <span class="n">serverSocket</span><span class="o">.</span><span class="na">setSoTimeout</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

            <span class="k">for</span> <span class="o">(;</span> <span class="o">;</span> <span class="o">)</span> <span class="o">{</span>
                <span class="n">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="n">serverSocket</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
               <span class="c1">// 读超时设置无限大，保证不会断开client</span>
                <span class="n">socket</span><span class="o">.</span><span class="na">setSoTimeout</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">EXECUTOR_SERVICE</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="n">ProcessorRunnable</span><span class="o">(</span><span class="n">socket</span><span class="o">));</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">socket</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="n">ExecutorService</span> <span class="nf">createDefaultExecutorService</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">SynchronousQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span> <span class="n">executorQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SynchronousQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;();</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">8</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">60</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span> <span class="n">executorQueue</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProcessorRunnable</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>

        <span class="kd">private</span> <span class="n">Socket</span> <span class="n">socket</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">ProcessorRunnable</span><span class="o">(</span><span class="n">Socket</span> <span class="n">socket</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">(</span><span class="n">InputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span> <span class="n">OutputStream</span> <span class="n">os</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">())</span> <span class="o">{</span>
                <span class="c1">// 同上文代码示例</span>
                <span class="n">processData</span><span class="o">(</span><span class="n">is</span><span class="o">,</span><span class="n">os</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="c1">// 处理完成最后，如果socket是打开的，需要进行关闭</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">socket</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">socket</span><span class="o">.</span><span class="na">isConnected</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">socket</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}}}</span>
</code></pre></div></div>

<blockquote>
  <p>上面示例除了增加多线程支持多客户端同时访问外，实现的时候，对一些实现进行了优化和完善。比如线程池，socket资源关闭，超时设置等。</p>
</blockquote>

<h4 id="设置-so_timeout参数">设置 SO_TIMEOUT参数</h4>

<p><strong>SO_TIMEOUT</strong>是设置socket超时时间的。在server的代码中，ServerSocket.setSoTimeout(int) 和Socket.setSoTimeout(int)是不一样的。在ServerSocket中超时时间指的是accept新连接的超时时间，当服务器等待指定时间还未有新的连接请求过来，则会抛出SocketTimeout异常，并且停止接收新的socket连接请求，但是现有的socket连接读写操作服务器还会继续处理。如下所示：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="o">.</span><span class="na">net</span><span class="o">.</span><span class="na">SocketTimeoutException</span><span class="o">:</span> <span class="n">Accept</span> <span class="n">timed</span> <span class="n">out</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">net</span><span class="o">.</span><span class="na">PlainSocketImpl</span><span class="o">.</span><span class="na">socketAccept</span><span class="o">(</span><span class="n">Native</span> <span class="n">Method</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">net</span><span class="o">.</span><span class="na">AbstractPlainSocketImpl</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">AbstractPlainSocketImpl</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">409</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">net</span><span class="o">.</span><span class="na">ServerSocket</span><span class="o">.</span><span class="na">implAccept</span><span class="o">(</span><span class="n">ServerSocket</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">545</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">net</span><span class="o">.</span><span class="na">ServerSocket</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">ServerSocket</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">513</span><span class="o">)</span>
</code></pre></div></div>
<p>与之不同，Socket的超时时间则是读read超时，当和服务器建立连接的客户端在超时时间内未写入新的数据到服务端，则服务器会抛出SocketTimeout异常，同时断开连接，客户端会出现<code class="highlighter-rouge">Connection closed by foreign host</code>类似的错误信息。抛出异常堆栈信息，如下所示：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="o">.</span><span class="na">net</span><span class="o">.</span><span class="na">SocketTimeoutException</span><span class="o">:</span> <span class="n">Read</span> <span class="n">timed</span> <span class="n">out</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">net</span><span class="o">.</span><span class="na">SocketInputStream</span><span class="o">.</span><span class="na">socketRead0</span><span class="o">(</span><span class="n">Native</span> <span class="n">Method</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">net</span><span class="o">.</span><span class="na">SocketInputStream</span><span class="o">.</span><span class="na">socketRead</span><span class="o">(</span><span class="n">SocketInputStream</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">116</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">net</span><span class="o">.</span><span class="na">SocketInputStream</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">SocketInputStream</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">171</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">net</span><span class="o">.</span><span class="na">SocketInputStream</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">SocketInputStream</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">141</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">net</span><span class="o">.</span><span class="na">SocketInputStream</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">SocketInputStream</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">127</span><span class="o">)</span>
</code></pre></div></div>

<blockquote>
  <p>在很多时候，我们都会给服务器的socket读设置一个超时时间，来避免由于客户端bug而导致一直占用服务器socket连接资源不释放问题，比如我们使用ssh客户端登录线上机器的时候，时间长了就会被断开连接。那如果客户端真的是期望和服务器一直保持连接该怎么办？定时发送心跳来维持连接，所以，我们一般通过修改ssh配置文件定时发送心跳包来保证不被服务器断开连接。</p>
</blockquote>

<h4 id="executor使用说明">Executor使用说明</h4>

<p>在服务器开发使用多线程模型的时候，服务器在收到客户端请求后，建立好socket连接，然后从线程池中获取一个线程来操作网络流IO。但是，在正常环境下，肯定不能无限的创建线程来支持客户端的请求，这个时候，就需要设置一个最大的线程数来保护服务器。</p>

<p>此外，当客户端请求处理逻辑发现线程池的初始线程数的线程都被消耗完，则依照线程池逻辑会临时放到Queue中等待线程释放，或者队列满进而在最大线程数之内创建新的线程来支持客户端请求处理。因此，就可能会有IO操作一直等待处理而不反馈给客户端（这种case对于需要及时响应的客户端请求，是很不推荐的，所以在HSF，thrift这些RPC框架中，都采用SynchronousQueue来避免这个问题）。</p>

<p><strong>SynchronousQueue</strong>是一个阻塞队列，但是这个队列比较特殊，其每一次插入操作都必须等待另外一个线程去获取移除操作，才能结束阻塞返回。SynchronousQueue内部使用<code class="highlighter-rouge">TransferQueue</code>/<code class="highlighter-rouge">TransferStack</code>来实现，内部逻辑比较复杂，感兴趣的可以去看JDK源码。</p>

<blockquote>
  <p>SynchronousQueue 其内部只会有一个元素（姑且这么认为，实际上其是不存储元素的）。当队列为空的时候，生产者将队列head指向新创建的node节点，在node上面waiter属性则设置为该生成者占用的线程，并且node的数据类型为DATA，阻塞线程等待消费；然后，需要消费数据的线程检查到head不为null，并且node类型为DATA，则消费该node，并且unpark掉处于阻塞的生成者线程。
当SynchronousQueue的head为null时，消费者需要获取node进行消费，则创建一个node节点，设置waiter为消费者线程，类型为REQUEST，将head指向node节点；然后生产者有生产数据的需求时，则unpark掉处于阻塞的消费者线程。</p>
</blockquote>

<h2 id="参考文献">参考文献</h2>

<ol>
  <li>TCP 的那些事儿(<a href="http://coolshell.cn/articles/11564.html">http://coolshell.cn/articles/11564.html</a>)</li>
  <li>TCP 为什么是三次握手，为什么不是两次或四次？(<a href="https://www.zhihu.com/question/24853633">https://www.zhihu.com/question/24853633</a>)</li>
  <li>再叙TIME_WAIT(<a href="https://huoding.com/2013/12/31/316">https://huoding.com/2013/12/31/316</a>)</li>
  <li>从TCP三次握手说起–浅析TCP协议中的疑难杂症(<a href="http://wetest.qq.com/lab/view/81.html">http://wetest.qq.com/lab/view/81.html</a>)</li>
  <li>QQ 为什么以 UDP 协议为主，以 TCP 协议为辅？ (<a href="https://www.zhihu.com/question/20292749">https://www.zhihu.com/question/20292749</a>)</li>
  <li>微信对网络影响的技术试验及分析(<a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=195&amp;ctid=10">http://www.52im.net/forum.php?mod=viewthread&amp;tid=195&amp;ctid=10</a>)</li>
  <li>thrift server整理后的项目源码(<a href="https://github.com/ketao1989/JavaThrift">https://github.com/ketao1989/JavaThrift</a>)</li>
  <li>关于Java网络API中设置Socket连接超时分析 (<a href="http://cuisuqiang.iteye.com/blog/1725348">http://cuisuqiang.iteye.com/blog/1725348</a>)</li>
  <li>Java 半关闭导致Connect reset异常分析(<a href="http://xiaoz5919.iteye.com/blog/1685138">http://xiaoz5919.iteye.com/blog/1685138</a>)</li>
</ol>


                </div>
                <div class="read-all">
                    <a  href="/2017/03/29/java-server-in-action/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2016/12/10/rpc-theory-in-action/">深入浅出RPC原理</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2016-12-10
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#rpc" title="Category: rpc" rel="category">rpc</a>&nbsp;
    
        <a href="/category/#dubbo" title="Category: dubbo" rel="category">dubbo</a>&nbsp;
    
        <a href="/category/#thrift" title="Category: thrift" rel="category">thrift</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <blockquote>
  <p>远程过程调用(Remote Procedure Call，简称RPC)，在微服务大行其道的今天，得到了广泛的应用。因此，在分布式系统服务群中开发应用，了解RPC一些原理和实现架构，还是很有必要的。本文，将从大的框架层面来聊聊RPC原理和实现。</p>
</blockquote>

<h2 id="前言">前言</h2>

<p>远程过程调用RPC，就是客户端基于某种传输协议通过网络向服务提供端请求服务处理，然后获取返回数据(对于ONE WAY模式则不返还响应结果)；而这种调用对于客户端而言，和调用本地服务一样方便，开发人员不需要了解具体底层网络传输协议。简单讲，就是本地调用的逻辑处理的过程放在的远程的机器上，而不是本地服务代理来处理。</p>

<p>目前，Java界的RPC中间件百家争鸣，国内开源的就有阿里的Dubbo(当当二次开发的DubboX)，新浪Motan；国外跨语言的有Facebook的Thrift， Google的gRpc等。</p>

<!-- more -->

<h2 id="lpc--ipc">LPC &amp; IPC</h2>

<p>既然存在RPC这种远程过程调用，必然会有与之对应的本地过程调用了。本地过程调用在不同的操作系统中，叫法不同，使用方式也不太一样。在Windows编程中，称为LPC；在linux编程中，更习惯称之为IPC，即进程间通信。</p>

<p>但是，不管如何，其本质上就是本地机器上的不同进程之间通信协作的调用方式。</p>

<p>服务端开发，一般我们基于Linux，所以这里简单介绍下Linux环境下 IPC实现方式：</p>

<ul>
  <li>管道</li>
  <li>共享内存</li>
  <li>信号量</li>
  <li>Socket套接字</li>
</ul>

<p>除此之外，还有消息队列和信号两种实现进程间通信的方式。</p>

<p>信号很容易理解，比如我们在控制台输入的<code class="highlighter-rouge">CTRL + C</code>来向执行的进程发送kill信号来结束该进程。对于信号，一般我们再终端交互窗口中使用比较多，在服务端开发中很少涉及。</p>

<p>Linux提供的消息队列和各种分布式MQ不同，它是在内核中使用链表结构来保持消息的队列，然后其他进程从内核的消息队列中获取消息。目前，Linux官方不太推荐使用，将渐渐被淘汰。</p>

<h3 id="管道">管道</h3>

<p>管道命令，在我们的<code class="highlighter-rouge">linux shell</code>中经常使用，一般，我们使用<code class="highlighter-rouge">|</code>操作符来保证两个命令之间的数据通信。比如，使用命令：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ps <span class="nt">-ef</span> | <span class="nb">grep </span>java | xargs <span class="nb">echo</span>
</code></pre></div></div>
<p>管道命令，其实内部实现就是使用的linux管道接口，每个命令其实是一个进程，各个进程的标准输出STDOUT，作为下一个进程的标准输入STDIN。</p>

<p>Linux管道包含：匿名管道和命名管道。</p>
<ul>
  <li>匿名管道：只能父子进程间通信。使用pipe()方法来创建：
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cp">#include &lt;unistd.h&gt;
</span>    <span class="kt">int</span> <span class="n">pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">filedis</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</code></pre></div>    </div>
    <blockquote>
      <p>参数filedis返回两个文件描述符：filedes[0]为读而打开，filedes[1]为写而打开。filedes[1]的输出是filedes[0]的输入</p>
    </blockquote>
  </li>
  <li>命名管道：可以在单台机器内的任何一组进程间进行通信。一般我们使用mkfifo()来创建命名管道：
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cp">#include &lt;sys/types.h&gt;
</span>    <span class="cp">#include &lt;sys/stat.h&gt;
</span>    <span class="kt">int</span> <span class="n">mkfifo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">pathname</span><span class="p">,</span><span class="n">mode_t</span> <span class="n">mode</span><span class="p">)</span>
</code></pre></div>    </div>
    <blockquote>
      <p>成功返回0，失败返回-1。成功返回之后，pathname其实就可以看着一个管道文件操作(当然并没有真实文件在磁盘存在)，对于文件操作的方法例如open,read,write都适用于fifo命名通道。</p>
    </blockquote>
  </li>
</ul>

<h3 id="信号量semaphore">信号量Semaphore</h3>

<p>Linux中的信号量和Java中的信号量一样，其主要用处是同步协作。</p>

<p>信号量其实就是一个比较特殊的变量，然后对它的操作都是原子进行的，并且一般只提供两种方法：P和V操作(在java中为wait()和notify())。</p>

<ul>
  <li>P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行；</li>
  <li>V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1。</li>
</ul>

<p>linux对外提供的API接口方法如下所示:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">struct</span> <span class="n">sem</span> <span class="p">{</span>
      <span class="kt">short</span> <span class="n">sempid</span><span class="p">;</span><span class="cm">/* pid of last operaton */</span>
      <span class="n">ushort</span> <span class="n">semval</span><span class="p">;</span><span class="cm">/* current value */</span>
      <span class="n">ushort</span> <span class="n">semncnt</span><span class="p">;</span><span class="cm">/* num procs awaiting increase in semval */</span>
      <span class="n">ushort</span> <span class="n">semzcnt</span><span class="p">;</span><span class="cm">/* num procs awaiting semval = 0 */</span>
    <span class="p">}</span>

<span class="err">　　</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">sys</span><span class="o">/</span><span class="n">types</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="err">　　</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">sys</span><span class="o">/</span><span class="n">ipc</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="err">　　</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">sys</span><span class="o">/</span><span class="n">sem</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
    <span class="c1">//首先获取一个信号量,只有该方法可以才能直接使用key，其他方法必须先semget然后才能使用信号量</span>
<span class="err">　　</span> <span class="kt">int</span> <span class="n">semget</span><span class="p">(</span><span class="n">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nsems</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
    <span class="c1">//对信号量进行操作，直接控制信号量信息，比如删除信号量</span>
    <span class="kt">int</span> <span class="n">semctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">union</span> <span class="n">semun</span> <span class="n">arg</span><span class="p">);</span>
    <span class="c1">//改变信号量的值，P,V操作都是通过该方法</span>
    <span class="kt">int</span> <span class="n">semop</span><span class="p">(</span><span class="kt">int</span> <span class="n">sem_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span><span class="n">sem_opa</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num_sem_ops</span><span class="p">);</span>

</code></pre></div></div>
<p>信号量的主要作用就是同步，所以我们一般是使用共享内存方式完成进程间通信，而在此过程中通过信号量来完成多进程间的同步协调机制。</p>

<h3 id="共享内存">共享内存</h3>

<p>由于同一台机器的硬件设备一般对于同一个系统来说，都是共享的。所以使用内存来完成进程间通信开发的思路，必然是很容易想到的，但是未必容易做到。</p>

<p>众所周知，进程和线程最大的区别就是一些资源是否隔离。也就是说，不同的进程，其内存资源使用是隔离独立的，每个进程有自己的一套内存地址映射逻辑，也即是系统是无法直接从不同进程的相同虚拟内存地址找到共同的物理内存地址的，这样，就无法像线程一样，简单把数据对象设置为<code class="highlighter-rouge">static</code>然后线程间就可以共享获取了。</p>

<p>因此，Linux对外提供了共享内存的方法来完成进程间通信。</p>

<p>共享内存是最有效的进程间通信方式。其对外提供的API如下所示：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="cp">#include &lt;sys/types.h&gt;
</span><span class="err">　</span>   <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">sys</span><span class="o">/</span><span class="n">ipc</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="err">　　</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">sys</span><span class="o">/</span><span class="n">shm</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>

    <span class="c1">//创建共享内存空间，大小为size</span>
    <span class="kt">int</span> <span class="n">shmget</span><span class="p">(</span><span class="n">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shmflg</span><span class="p">);</span>
    <span class="c1">//所有需要使用共享内存通信的进程，映射到自身的内存地址空间中</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">shmat</span><span class="p">(</span><span class="kt">int</span> <span class="n">shmid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
    <span class="c1">//从当前进程地址空间中分离该共享内存</span>
    <span class="kt">int</span> <span class="n">shmdt</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">shmaddr</span><span class="p">);</span>
    <span class="c1">//控制共享内存的，比如删除该共享内存空间等</span>
    <span class="kt">int</span> <span class="n">shmctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">shm_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">command</span><span class="p">,</span> <span class="k">struct</span> <span class="n">shmid_ds</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

</code></pre></div></div>
<blockquote>
  <p>从上面的方法可以很显然的看出，进程间的内存地址空间是独立隔离的(内核地址空间由于虚拟地址和物理地址是一致的，所以在进程间这块地址空间也是一致的，不过我们操作的都是用户空间的内存，所以不考虑这块)。当我们想要共享操作，必须要把物理内存分别绑定到对应进程的地址空间，才能共享操作。</p>

  <p>使用的时候，很简单。<code class="highlighter-rouge">shmat</code>方法返回一个<code class="highlighter-rouge">void *</code>就可以强转某个指定的struct，然后直接操作该对象结构体即可。由于共享，所以需要考虑多线程同步安全问题。</p>
</blockquote>

<h3 id="socket套接字">Socket套接字</h3>

<p>从上面的几个API方法可以看到都是利用单机同用一套资源，然后各自进程的资源之间通过内核方式或者内存方式协作完成单机多进程间通信。</p>

<p>此外，还有一种方式来完成进程间通信，就是套接字socket。Socket一般情况下是用在不同的两台机器的不同进程之间通信的，当Socket创建时的类型为 <code class="highlighter-rouge">AF_LOCAL或AF_UNIX</code>时，则是本地进程通信了(当然你也可以直接使用网络套接字，如果你觉得走下网络更酷，或者以后便于服务分离)。</p>

<p>关于Socket的API介绍，这里就省略了。服务端/客户端模式的介绍和示例相对很常见，也很容易开发和理解。</p>

<p>从使用网络套接字Socket来实现进程间通信这个角度来说，其和RPC并没有什么不同了，所以有些文献分类时，说广义来讲RPC也应该包括LPC(IPC),因为从大的来讲，单机进程通信其实算是远程过程调用的一种特殊简化的方式而已。</p>

<p>当然，本文还是觉得还是区别开比较通用，也便于理解。</p>

<blockquote>
  <p>如在Socket介绍的那样，本地过程调用很多情况下都是依赖操作系统对外提供的API来协调操作某个共享资源来完成进程间的数据交换。</p>

  <p>如果不依赖单机共享资源，就只有Socket接口。因此，如果要扩展到分布式环境下的进程间通信，那就只能使用网络套接字来完成。</p>

</blockquote>

<p>说完单机的服务调用，在互联网时代，自然要讲web服务(Web Service)了。</p>

<h2 id="web-service技术">Web Service技术</h2>

<blockquote>
  <p><code class="highlighter-rouge">Web Service</code>一般有两种定义：</p>
  <ol>
    <li>特指 W3C组织制定的<code class="highlighter-rouge">web service</code>规范技术。其包括SOAP(一个基于XML的可扩展消息信封格式，需同时绑定一个网络传输协议。这个协议通常是HTTP或HTTPS，但也可能是SMTP或XMPP)、WSDL(一个XML格式文档，用以描述服务端口访问方式和使用协议的细节。通常用来辅助生成服务器和客户端代码及配置信息)和UDDI(一个用来发布和搜索WEB服务的协议，应用程序可借由此协议在设计或运行时找到目标WEB服务)。从上面三个定义就可以看出，这种规范技术是一个重量级的协议。</li>
    <li>泛指网络系统对外提供web服务所使用的技术。这里，我们主要是基于该定义来理解。</li>
  </ol>
</blockquote>

<p>一般而言，技术体系，必然是服务于架构体系的。不同的架构，所约定的技术结构设计还是有些区别的。</p>

<p>因此，要了解web服务技术，必然要先了解其服务于哪个架构体系；也就是说，先去了解技术产生的架构背景。</p>

<h3 id="soa--微服务">SOA &amp; 微服务</h3>

<p>在分布式网络服务架构体系中，最火的莫过于 SOA(面向服务架构，Service-Oriented Architecture)和微服务。</p>

<p>嗯，一般将服务化架构，必然会扯到<code class="highlighter-rouge">全家桶</code>设计升级的故事。</p>

<p>简化版是这样子的：</p>

<ul>
  <li>
    <p>在很久很久以前，网络应用也是单机部署的，所有的业务代码全部都在一个大项目内，然后更改一个逻辑就需要重启部署应用，停止对外服务。</p>
  </li>
  <li>
    <p>然后，这样子肯定不行的，就有了多机部署，通过Nginx或者其他代理/均衡软件来分发请求到相同服务的不同机器上，当其中一台机器停机部署时，请求全部打到其他机器上去。但是这个时候，所有机器上的代码还是一套。</p>
  </li>
  <li>
    <p>后来，机器不断升级，但是业务不断变多，项目代码越来越大，更改一个地方编译打包部署时间非常长，于是，我们就把一些独立隔离开的业务代码分成多个项目。但是，实现业务逻辑的时候，必然有一些功能和数据是多个业务都会用到的，简单以前的代码copy过来，数据就直接操作数据库。但是，当有个公用的功能需要更改时，就发现所有相关业务都需要更改，并且数据库上的操作，还会带来其他同步兼容等等问题。</p>
  </li>
  <li>
    <p>于是，就出现了SOA，也就是基于服务的架构设计理念。SOA的设计理念，就是把所有的服务都对外以HTTP或者其他协议方式对外暴露，绝对<code class="highlighter-rouge">不允许</code>相同的服务在不同的业务系统独立一套，然后共用底层数据库。服务化的设计系统，所有拆分的业务，彼此之间都通过暴露的服务接口通信，操作对方的数据。这样，各个业务系统之间开始独立自主的向着美好的方向发展了。</p>
  </li>
  <li>
    <p>再后来，单个业务发展的越来越好，提供的功能也越来越多，这样一个业务系统的代码也变得很大了，开发人员也越来越多。于是乎，单个业务系统内部就存在问题了，当然，我们也可以拆分成不同的业务系统来开发发展。但是，单个业务系统，很多的公用逻辑都是一些业务细节，并不好独立成业务系统；此外，单个业务系统开发人员都很容易交流，因此，对于内部业务系统的架构设计，就出现了<code class="highlighter-rouge">微服务Micro-Service</code>了。我们把单个业务系统中一些功能细节的结构封装成服务，大的对外业务系统，组装各个微服务的接口数据，然后提供SOA服务。</p>
  </li>
</ul>

<p>因此，SOA其实和微服务，从我的视角来看，其实就是 业务外部和内部服务的不同架构设计而已，其技术框架很大程度上都可以通用。其区别如下图：</p>

<p><img src="/images/2016/12/soa_ms.jpg" alt="SOA和微服务" /></p>

<p>从上面发展历程可以看到，SOA一般使用SOAP或者REST方式来提供服务，这样外部业务系统可以使用通用网络协议来处理请求和响应，而微服务，还可以有一些私有的协议方式来提供服务，例如基于自定义协议的RPC框架。RPC使得调用服务简单，但是需要一些其他耗时间的交流协调工作，这适合微服务的场景，但是不一定适合SOA场景了。</p>

<h3 id="web服务技术结构">web服务技术结构</h3>

<p>先给出一个web服务的技术体系结构图：</p>

<p><img src="/images/2016/12/web_service.png" alt="web服务技术体系" /></p>

<p><code class="highlighter-rouge">web service</code>被W3C设立规范之初，SOAP方案就被提出来。但是，随着服务化技术和架构的发展，SOAP多少有点过于复杂，因此就出现了简化版的REST方案。此后，由于分布式服务应用越来越大，对性能和易用性上面要求越来越大，因此就出现了RPC框架(很多时候，RPC并不被当做一种web service方案。在绝大部分博客中，介绍web service 只会讨论 SOAP和REST，主要是其基本上都是基于SOA来介绍服务方案)。</p>

<h4 id="soap">SOAP</h4>

<p>SOAP，全称为 Simple Object Access Protocol，也就是 简单对象访问协议。跟着<code class="highlighter-rouge">web service</code>一起出来的，说明历史悠久，不过感觉现在也慢慢要淘汰了。</p>

<p>SOAP，是基于XML数据格式来交换数据的；其内部定义了一套复杂完善的XML标签，标签中包含了调用的远程过程、参数、返回值和出错信息等等，通信双方根据这套标签来解析数据或者请求服务。与SOAP相关的配套协议是WSDL (Web Service Description Language)，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，类似我们现在聊服务治理中的服务发现功能。</p>

<p>因此，SOAP服务整体流程是：首先，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。</p>

<h4 id="rest">REST</h4>

<p>REST，全称 REpresentational State Transfort，也就是 表示性状态转移。由于SOAP方案过于庞大复杂，在很多简单的web服务应用场景中，轻量级的REST就出现替代SOAP方案了。</p>

<p>和SOAP相比，REST只是对URI做了一些规范，数据才有JSON格式，底层传输使用HTTP/HTTPS来通信，因此，所有web服务器都可以快速支持该方案；开发人员也可以快速学习和使用。</p>

<h4 id="soap--rest">SOAP &amp; REST</h4>

<p>从命名来看，SOAP是一种协议，而REST只是一种方案。协议的设计很多时候，从上而下一整套都是新的，需要设计开发专门的工具支持；而方案相对就是基于目前以后的工具来做一些设计和约束，这就是为什么REST快速替换了SOAP的地位。</p>

<p>REST特点：</p>
<ul>
  <li>由于数据返回格式是自定义的，绝大部分使用JSON，这种数据结构节省带宽，并且前端JavaScript能天生支持。</li>
  <li>无状态，基于HTTP协议，所以只能适应无状态场景。</li>
</ul>

<p>SOAP特点：</p>
<ul>
  <li>协议有安全性的一些规范。</li>
  <li>基于xml的标签约束，而且也不要去底层是HTTP传输，所以支持有状态的场景。</li>
</ul>

<h3 id="rpc家族">RPC家族</h3>

<p>RPC家族中，RMI是Java制定的远程通信协议。而后，基本上RPC框架都或多或少有RMI的影子(当然，其实主要是RPC本身的实现方式就是这样子了-_-)。RMI既然是Java的标准RPC组件，那必然其他编程语言就无法使用了；因此，Thrift这种基于IDL来跨语言的RPC组件就出现了。Thrift的使用者，只需要按照Thrift官方规定的方式来写API结构，然后生成对应语言的API接口，继而就可以跨语言完成远程过程调用了。但是，作为服务化的组件，如果没有服务治理来完成大规模应用集群中服务调用管理工作，则运维工作则是非常繁重的，因此类似dubbo这种包含服务治理的RPC组件出现了。</p>

<p>下面，就来介绍RPC组件。</p>

<h2 id="rpc介绍">RPC介绍</h2>

<blockquote>
  <p>RMI作为Java自带的官方RPC组件，单独介绍；然后我们来看看通用RPC实现结构。</p>
</blockquote>

<h3 id="rmi介绍">RMI介绍</h3>

<p>RMI，全称是Remote Method Invocation，也就是远程方法调用。在JDK 1.2的时候，引入到Java体系的。当应用比较小，性能要求不高的情况下，使用RMI还是挺方便快捷的。</p>

<p>下面先看看RMI的调用流程。</p>

<p><img src="/images/2016/12/rmi.png" alt="RMI服务调用流程" /></p>

<p>其中，有些概念需要说明：</p>
<blockquote>
  <p>stub(桩)：stub实际上就是远程过程在客户端上面的一个代理proxy。当我们的客户端代码调用API接口提供的方法的时候，RMI生成的stub代码块会将请求数据序列化，交给远程服务端处理，然后将结果反序列化之后返回给客户端的代码。这些处理过程，对于客户端来说，基本是透明无感知的。</p>

  <p>remote：这层就是底层网络处理了，RMI对用户来说，屏蔽了这层细节。stub通过remote来和远程服务端进行通信。</p>

  <p>skeleton(骨架)：和stub相似，skeleton则是服务端生成的一个代理proxy。当客户端通过stub发送请求到服务端，则交给skeleton来处理，其会根据指定的服务方法来反序列化请求，然后调用具体方法执行，最后将结果返回给客户端。</p>

  <p>registry(服务发现)：rmi服务，在服务端实现之后需要注册到rmi server上，然后客户端从指定的rmi地址上lookup服务，调用该服务对应的方法即可完成远程方法调用。registry是个很重要的功能，当服务端开发完服务之后，要对外暴露，如果没有服务注册，则客户端是无从调用的，即使服务端的服务就在那里。</p>
</blockquote>

<p>下面给出一个简单的Java示例来show code下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 接口必须继承RMI的Remote
 */</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">RmiService</span> <span class="kd">extends</span> <span class="n">Remote</span> <span class="o">{</span>

    <span class="cm">/**
     * 必须有RemoteException，才是RMI方法
     */</span>
    <span class="n">String</span> <span class="nf">hello</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">RemoteException</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**
 * UnicastRemoteObject会生成一个代理proxy
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RmiServiceImpl</span> <span class="kd">extends</span> <span class="n">UnicastRemoteObject</span> <span class="kd">implements</span> <span class="n">RmiService</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">RmiServiceImpl</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">RemoteException</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">hello</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">RemoteException</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Hello "</span> <span class="o">+</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * 服务端server启动
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RmiServer</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">RmiService</span> <span class="n">service</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RmiServiceImpl</span><span class="o">();</span>
            <span class="c1">//在本地创建和暴露一个注册服务实例，端口为9999</span>
            <span class="n">LocateRegistry</span><span class="o">.</span><span class="na">createRegistry</span><span class="o">(</span><span class="mi">9999</span><span class="o">);</span>
            <span class="c1">//注册service服务到上面创建的注册实例上</span>
            <span class="n">Naming</span><span class="o">.</span><span class="na">rebind</span><span class="o">(</span><span class="s">"rmi://127.0.0.1:9999/service1"</span><span class="o">,</span><span class="n">service</span><span class="o">);</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"------------server start-----------------"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="cm">/**
 * 客户端调用rmi服务
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RmiClient</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 根据注册的服务地址来查找服务，然后就可以调用API对应的方法了</span>
            <span class="n">RmiService</span> <span class="n">service</span> <span class="o">=</span> <span class="o">(</span><span class="n">RmiService</span><span class="o">)</span><span class="n">Naming</span><span class="o">.</span><span class="na">lookup</span><span class="o">(</span><span class="s">"rmi://localhost:9999/service1"</span><span class="o">);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">service</span><span class="o">.</span><span class="na">hello</span><span class="o">(</span><span class="s">"RMI"</span><span class="o">));</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>
<blockquote>
  <p>上面一些核心的代码已经在注释中给了说明。</p>
</blockquote>

<h3 id="通用rpc架构">通用RPC架构</h3>

<p>一般，远程过程调用RPC就是本地动态代理隐藏通信细节，通过组件序列化请求，走网络到服务端，执行真正的服务代码，然后将结果返回给客户端，反序列化数据给调用方法的过程。</p>

<p>RPC具体调用流程如下所示：
<img src="/images/2016/12/rpc.png" alt="RPC调用流程" /></p>

<p>通用的RPC组件一般包括以下一些模块：</p>

<blockquote>
  <ol>
    <li>
      <p>serviceClient：这个模块主要是封装服务端对外提供的API，让客户端像使用本地API接口一样调用远程服务。一般，我们使用动态代理机制，当客户端调用api的方法时，serviceClient会走代理逻辑，去远程服务器请求真正的执行方法，然后将响应结果作为本地的api方法执行结果返回给客户端应用。类似RMI的stub模块。</p>
    </li>
    <li>
      <p>processor：在服务端存在很多方法，当客户端请求过来，服务端需要定位到具体对象的具体方法，然后执行该方法，这个功能就由processor模块来完成。一般这个操作需要使用反射机制来获取用来执行真实处理逻辑的方法，当然，有的RPC直接在server初始化的时候，将一定规则写进Map映射中，这样直接获取对象即可。类似RMI的skeleton模块。</p>
    </li>
    <li>
      <p>protocol：协议层，这是每个RPC组件的核心技术所在。一般，协议层包括编码/解码，或者说序列化和反序列化工作；当然，有的时候编解码不仅仅是对象序列化的工作，还有一些通信相关的字节流的额外解析部分。序列化工具有：hessian，protobuf，avro,thrift，json系，xml系等等。在RMI中这块是直接使用JDK自身的序列化组件。</p>
    </li>
    <li>
      <p>transport：传输层，主要是服务端和客户端网络通信相关的功能。这里和下面的IO层区分开，主要是因为传输层处理server/client的网络通信交互，而不涉及具体底层处理连接请求和响应相关的逻辑。</p>
    </li>
    <li>
      <p>I/O：这个模块主要是为了提高性能可能采用不同的IO模型和线程模型，当然，一般我们可能和上面的transport层联系的比较紧密，统一称为remote模块。</p>
    </li>
  </ol>
</blockquote>

<p>此外，还有业务代码自己去实现的client和server层。client当需要远程调用服务时，会首先初始化一个API接口代理对象，然后调用某个代理方法。server在对外暴露服务时，需要首先实现对应API接口内部的方法，当请求过来时，通过反射找到对应的实例对象，执行对应的业务代码。</p>

<h3 id="简单rpc组件实现">简单RPC组件实现</h3>

<p>介绍完RPC相关结构和概念之后，给一个简单的RPC组件示例来对各个模块进行code级别的说明。</p>

<blockquote>
  <p>以下代码仅仅是了解RPC各个模块功能的示例，对性能和异常等情况未考虑全面，生产环境不适用。</p>
</blockquote>

<h4 id="protocol模块代码">protocol模块代码</h4>

<blockquote>
  <p>协议层主要包括编解码和序列化部分。编解码就是我们对传输通信的远程调用请求接口和方法参数等数据按照我们规定的格式进行组装编码，然后在接收的一方负责把数据解码成原始的对象，然后找到需要执行的接口和方法。序列化/反序列化，则是将数据对象，按照一定的映射关系转换成字节流，供网络传输，接收的一方首先将流映射为对象数据。</p>

  <p>有的时候，序列化/反序列化组件会包含编解码部分。此外，编解码和序列化工作先后关系也不一定。一般高性能RPC，序列化工具十分强大和通用，所以编解码部分会放在序列化之后，主要是解码的时候，可以不完成反序列化就对流进行一些处理工作，比如映射、分发等。</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/**
 * 很明显，这里使用JSON来序列化和反序列化RPC调用传递的数据
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceProtocol</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ServiceProtocol</span> <span class="n">protocol</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ServiceProtocol</span><span class="o">();</span>

    <span class="cm">/**
     * 将对象序列化为字符串字节
     */</span>
    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encode</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">JsonUtils</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="n">o</span><span class="o">).</span><span class="na">getBytes</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 反序列化成字符串
     */</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">decode</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">clazz</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">JsonUtils</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">data</span><span class="o">),</span> <span class="n">clazz</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 编解码模型
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ProtocolModel</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="n">String</span> <span class="n">clazz</span><span class="o">;</span>
        <span class="kd">private</span> <span class="n">String</span> <span class="n">method</span><span class="o">;</span>
        <span class="kd">private</span> <span class="n">String</span><span class="o">[]</span> <span class="n">argTypes</span><span class="o">;</span>
        <span class="kd">private</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">;</span>

        <span class="c1">// setter getter方法省略</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>
<p>示例中的代码使用JSON来序列化/反序列化工作。由于JSON序列化组件比较弱，所以这边需要将执行调用方法相关的请求数据进行编码成<code class="highlighter-rouge">ProtocolModel</code>对象。</p>

<h4 id="remote模块代码">remote模块代码</h4>

<blockquote>
  <p>remote模块是提供服务端和客户端通信的功能。因此，在服务端需要起一个端口来监听外部的请求，在客户端则负责发送请求，接收响应数据。</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 客户端通信组件，客户端和外部服务端数据交互时使用
 */</span>
 <span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClientRemoter</span> <span class="o">{</span>

     <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ClientRemoter</span> <span class="n">client</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClientRemoter</span><span class="o">();</span>

     <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getDataRemote</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">requestData</span><span class="o">)</span> <span class="o">{</span>

         <span class="k">try</span> <span class="o">(</span><span class="n">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Socket</span><span class="o">())</span> <span class="o">{</span>
             <span class="n">socket</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="k">new</span> <span class="n">InetSocketAddress</span><span class="o">(</span><span class="s">"127.0.0.1"</span><span class="o">,</span> <span class="mi">9999</span><span class="o">));</span>
             <span class="n">socket</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">().</span><span class="na">write</span><span class="o">(</span><span class="n">requestData</span><span class="o">);</span>
             <span class="n">socket</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">().</span><span class="na">flush</span><span class="o">();</span>

             <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">10240</span><span class="o">];</span>
             <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">().</span><span class="na">read</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>

             <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
         <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
             <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
             <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
         <span class="o">}</span>
     <span class="o">}</span>
 <span class="o">}</span>


<span class="cm">/**
 * 服务端起一个端口监听服务，绑定到相关processor处理器上。
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServerRemoter</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span>
        <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">availableProcessors</span><span class="o">());</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startServer</span><span class="o">(</span><span class="kt">int</span> <span class="n">port</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

        <span class="kd">final</span> <span class="n">ServerSocket</span> <span class="n">server</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ServerSocket</span><span class="o">();</span>
        <span class="n">server</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="k">new</span> <span class="n">InetSocketAddress</span><span class="o">(</span><span class="n">port</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"-----------start server----------------"</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="kd">final</span> <span class="n">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
                <span class="n">executor</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="n">MyRunnable</span><span class="o">(</span><span class="n">socket</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">server</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>

        <span class="kd">private</span> <span class="n">Socket</span> <span class="n">socket</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">MyRunnable</span><span class="o">(</span><span class="n">Socket</span> <span class="n">socket</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>

            <span class="k">try</span> <span class="o">(</span><span class="n">InputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span> <span class="n">OutputStream</span> <span class="n">os</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">())</span> <span class="o">{</span>

                <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">10240</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">is</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>

                <span class="n">ServiceProtocol</span><span class="o">.</span><span class="na">ProtocolModel</span> <span class="n">model</span> <span class="o">=</span> <span class="n">ServiceProtocol</span><span class="o">.</span><span class="na">protocol</span>
                    <span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">),</span> <span class="n">ServiceProtocol</span><span class="o">.</span><span class="na">ProtocolModel</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
                <span class="n">Object</span> <span class="n">object</span> <span class="o">=</span> <span class="n">ServiceProcessor</span><span class="o">.</span><span class="na">processor</span><span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="n">model</span><span class="o">);</span>
                <span class="n">os</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">ServiceProtocol</span><span class="o">.</span><span class="na">protocol</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="n">object</span><span class="o">));</span>
                <span class="n">os</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="c1">// close socket...</span>
           <span class="o">}</span>        <span class="o">}</span>    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <p>简单处理，直接让网络一次获取所有的数据，假设一次请求和响应的数据大小小于10K。</p>

  <p>在server端的remote中，启动服务之前是需要绑定对外提供的服务的，也就是服务server启动，其内部需要指定序列化、服务处理器等逻辑。</p>
</blockquote>

<p>通用RPC的通信层，是非常复杂的，其需要考虑各种网络环境导致的数据半包，分包和粘包情况，需要考虑高性能NIO组件，多线程处理超时，连接复用等等。</p>

<h4 id="processor模块代码">processor模块代码</h4>

<blockquote>
  <p>服务端接口方法定位处理器。作为一个组件，显然不应该在业务代码中嵌入一些非业务逻辑。processor会根据序列化完了之后的请求数据来定位具体的处理逻辑，然后调用对应的业务代码来处理获取返回结果。</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceProcessor</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ServiceProcessor</span> <span class="n">processor</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ServiceProcessor</span><span class="o">();</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ConcurrentMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">PROCESSOR_INSTANCE_MAP</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;();</span>


    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">publish</span><span class="o">(</span><span class="n">Class</span> <span class="n">clazz</span><span class="o">,</span> <span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">PROCESSOR_INSTANCE_MAP</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">clazz</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">obj</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">process</span><span class="o">(</span><span class="n">ServiceProtocol</span><span class="o">.</span><span class="na">ProtocolModel</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">model</span><span class="o">.</span><span class="na">getClazz</span><span class="o">());</span>

            <span class="n">Class</span><span class="o">[]</span> <span class="n">types</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Class</span><span class="o">[</span><span class="n">model</span><span class="o">.</span><span class="na">getArgTypes</span><span class="o">().</span><span class="na">length</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">types</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">types</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">model</span><span class="o">.</span><span class="na">getArgTypes</span><span class="o">()[</span><span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span>

            <span class="n">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="n">model</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(),</span> <span class="n">types</span><span class="o">);</span>

            <span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">PROCESSOR_INSTANCE_MAP</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">model</span><span class="o">.</span><span class="na">getClazz</span><span class="o">());</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span> <span class="n">model</span><span class="o">.</span><span class="na">getArgs</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>
<blockquote>
  <p>PROCESSOR_INSTANCE_MAP publish这个逻辑，在Spring环境中，一般通过xml配置自动注入进来，然后从context中获取对应的实例。但是，不管怎样，底层其实都是一个map来维护映射关系。</p>
</blockquote>

<p>如上文介绍的那样，经过解码获取到的调用对象，然后通过java反射机制，执行指定的方法获取结果。</p>

<h4 id="serviceclient模块代码">serviceClient模块代码</h4>

<blockquote>
  <p>其实，这块叫做serviceProxyClient比较直接点。</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceProxyClient</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">getInstance</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">clazz</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">T</span><span class="o">)</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">clazz</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Class</span><span class="o">[]</span> <span class="o">{</span><span class="n">clazz</span><span class="o">},</span> <span class="k">new</span> <span class="n">ServiceProxy</span><span class="o">(</span><span class="n">clazz</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ServiceProxy</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>

        <span class="kd">private</span> <span class="n">Class</span> <span class="n">clazz</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">ServiceProxy</span><span class="o">(</span><span class="n">Class</span> <span class="n">clazz</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">clazz</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>

            <span class="n">ServiceProtocol</span><span class="o">.</span><span class="na">ProtocolModel</span> <span class="n">model</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ServiceProtocol</span><span class="o">.</span><span class="na">ProtocolModel</span><span class="o">();</span>
            <span class="n">model</span><span class="o">.</span><span class="na">setClazz</span><span class="o">(</span><span class="n">clazz</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
            <span class="n">model</span><span class="o">.</span><span class="na">setMethod</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
            <span class="n">model</span><span class="o">.</span><span class="na">setArgs</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>

            <span class="n">String</span><span class="o">[]</span> <span class="n">argType</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">method</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">().</span><span class="na">length</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argType</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">argType</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">()[</span><span class="n">i</span><span class="o">].</span><span class="na">getName</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">model</span><span class="o">.</span><span class="na">setArgTypes</span><span class="o">(</span><span class="n">argType</span><span class="o">);</span>

            <span class="kt">byte</span><span class="o">[]</span> <span class="n">req</span> <span class="o">=</span> <span class="n">ServiceProtocol</span><span class="o">.</span><span class="na">protocol</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="n">model</span><span class="o">);</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">rsp</span> <span class="o">=</span> <span class="n">ClientRemoter</span><span class="o">.</span><span class="na">client</span><span class="o">.</span><span class="na">getDataRemote</span><span class="o">(</span><span class="n">req</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">ServiceProtocol</span><span class="o">.</span><span class="na">protocol</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">rsp</span><span class="o">,</span> <span class="n">method</span><span class="o">.</span><span class="na">getReturnType</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p><code class="highlighter-rouge">ProxyClient</code>就是对客户端调用API时透明化底层序列化和网络操作相关细节。所以，在proxyClient内部，我们可以看到它封装代理了这块调用逻辑，业务代码直接使用<code class="highlighter-rouge">getInstance</code>方法就可以获取对象实例，然后按照正常使用api方法来执行调用逻辑，获取结果。</p>

<blockquote>
  <p>如果使用spring框架的话，可以进一步封装成一个bean，然后客户端业务代码只需要在xml中配置一下，就可以通过注解annotation等方式注入进来。</p>
</blockquote>

<h4 id="server业务接口实现代码">server业务接口实现代码</h4>

<blockquote>
  <p>这里给出接口对外发布和测试</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">RpcService</span> <span class="o">{</span>
    <span class="n">String</span> <span class="nf">sayHi</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RpcServiceImpl</span> <span class="kd">implements</span> <span class="n">RpcService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">sayHi</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Hello,"</span> <span class="o">+</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * 服务端测试main执行代码
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServerDemo</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

        <span class="c1">// 发布接口</span>
        <span class="n">ServiceProcessor</span><span class="o">.</span><span class="na">processor</span><span class="o">.</span><span class="na">publish</span><span class="o">(</span><span class="n">RpcService</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="k">new</span> <span class="n">RpcServiceImpl</span><span class="o">());</span>

        <span class="c1">// 启动server</span>
        <span class="n">ServerRemoter</span> <span class="n">remoter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ServerRemoter</span><span class="o">();</span>
        <span class="n">remoter</span><span class="o">.</span><span class="na">startServer</span><span class="o">(</span><span class="mi">9999</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<blockquote>
  <p>如上，我们构造了一个<code class="highlighter-rouge">RpcService</code>接口对外提供sayHi的服务。在main方法中，我们首先需要对外发布这个接口和对应的实现类对象。在一些框架中，这些对外暴露的接口，都是通过xml配置或者annotation来发布的。然后，我们就可以启动server服务，对外提供RPC服务。</p>
</blockquote>

<h4 id="6--client调用测试代码">6.  client调用测试代码</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClientDemo</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"----------start invoke----------------"</span><span class="o">);</span>
        <span class="n">RpcService</span> <span class="n">service</span> <span class="o">=</span> <span class="n">ServiceProxyClient</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">RpcService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">service</span><span class="o">.</span><span class="na">sayHi</span><span class="o">(</span><span class="s">"RPC World"</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"----------end invoke----------------"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>
<blockquote>
  <p>看我们的测试代码非常简单，当要远程调用某个接口方法时，只需要getInstance该接口类代理对象，然后就像调用本地方法一直执行方法执行和结果处理。</p>
</blockquote>

<h2 id="rpc技术深入">RPC技术深入</h2>

<p>上文简单的介绍了RPC模块各个部分，并且实现了一个简单的RPC组件。这一部分，我们要介绍在生产环节下RPC需要使用的一些技术点。</p>

<h3 id="rpc序列化">RPC序列化</h3>

<blockquote>
  <p>将RPC序列化和编解码分开，是因为个人觉得，虽然在很多时候，编解码其实就是序列化操作，但是有的时候，我们会自定义一些数据结构来封装业务数据对象，然后再序列化成二进制流。此外，在协议层，我们可能也会对普通序列化完了之后，还会对传输头进行编码工作。因此，为了更好的说明，这里分开来。</p>
</blockquote>

<p>序列化，说的简单，就是将对象转换成二进制流，也就是<code class="highlighter-rouge">byte[]</code>，而反序列化就是讲二进制流转换成对象。使用序列化/反序列化，主要是我们想把内存对象数据，持久化到文件fd或者通过网络传输到其他地方，而这只能使用二进制流来呈现。此外，由于RPC是通过网络通信的，所以序列化工具的性能和二进制流的大小，都是直接影响整体处理能力的关键因素。</p>

<p>目前基于Java的序列化工具，主要有：</p>
<ul>
  <li>JDK Serializable工具</li>
  <li>Hessian工具</li>
  <li>Kryo工具</li>
  <li>JSON工具</li>
</ul>

<h4 id="jdk内置序列化工具">JDK内置序列化工具</h4>

<p>JDK自带的序列化工作不需要引入任何第三方包就可以直接使用，我们仅仅只需要实现<code class="highlighter-rouge">java.io.Serializable</code>接口。然后，我们在需要序列化/反序列化的时候，直接使用<code class="highlighter-rouge">ObjectInputStream</code>/<code class="highlighter-rouge">ObjectOutStream</code>来readObject将流反序列化成对象或者writeObject将对象序列化成流。</p>

<p>很多时候，我们并不使用原生的JDK序列化工具进行序列化，主要原因是因为其序列化后的二进制流太大，并且序列化耗时也比较长。但是，其最大的优点就是原生支持，快速使用，引入成本低，此外，其支持java所有类型，所以在有些RPC组件中，其作为默认序列化工具。</p>

<blockquote>
  <p>使用JDK自带的序列化工具，尤其需要注意<code class="highlighter-rouge">serialVersionUID</code>这个静态变量，在反序列化的时候，会根据这个变量来判断两个类是否一样，如果修改了该变量，那么将无法兼容来的二进制数据的反序列化操作。</p>

  <p>此外，你可以通过在类中增加writeObject 和 readObject 方法可以实现自定义序列化。</p>
</blockquote>

<p>测试代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JdkSerialiable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">serial</span><span class="o">(</span><span class="n">Blog</span> <span class="n">blog</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">ByteArrayOutputStream</span> <span class="n">baos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayOutputStream</span><span class="o">();</span>
        <span class="n">ObjectOutputStream</span> <span class="n">os</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectOutputStream</span><span class="o">(</span><span class="n">baos</span><span class="o">);</span>
        <span class="n">os</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">blog</span><span class="o">);</span>
        <span class="n">os</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>

        <span class="n">ObjectInputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectInputStream</span><span class="o">(</span><span class="k">new</span> <span class="n">ByteArrayInputStream</span><span class="o">(</span><span class="n">baos</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">()));</span>
        <span class="n">Blog</span> <span class="n">blog1</span> <span class="o">=</span> <span class="o">(</span><span class="n">Blog</span><span class="o">)</span> <span class="n">is</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
        <span class="n">is</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">blog1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="hessian工具">Hessian工具</h4>

<p>Hessian,其实是一个开源的轻量级RPC组件。从上面分析RPC通用结构，可以看到很多RPC为了性能会自己实现序列化/反序列化工具，比如Thrift，而hessian也是如此。hessian2的性能相对JDK来说，提高了很多，而且序列化完了之后的流也小了很多。由于hessian已经生产实践了很长时间，所以其还是很值得使用的。</p>

<p>hessian在处理序列化的时候，会根据对象的数据类型采用不同的序列化策略，比如有些直接使用JavaSerializer，有些事自己来实现对应类型的序列化方法，其实就是如上面所介绍的那样，实现对应类型的<code class="highlighter-rouge">writeObject</code>和<code class="highlighter-rouge">readObject</code>方法。</p>

<p>我们只是使用hessian工具来完成序列化和反序列化工作，如果你需要自己实现一个自定义序列化工具，那么可以参考hessian的实现方式。</p>

<p>测试代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HessianSerialibale</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">serial</span><span class="o">(</span><span class="n">Blog</span> <span class="n">blog</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">{</span>

        <span class="n">ByteArrayOutputStream</span> <span class="n">baos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayOutputStream</span><span class="o">();</span>
        <span class="n">Hessian2Output</span> <span class="n">os</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Hessian2Output</span><span class="o">(</span><span class="n">baos</span><span class="o">);</span>
        <span class="n">os</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">blog</span><span class="o">);</span>
        <span class="n">os</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">Hessian2Input</span> <span class="n">is</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Hessian2Input</span><span class="o">(</span><span class="k">new</span> <span class="n">ByteArrayInputStream</span><span class="o">(</span><span class="n">baos</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">()));</span>
        <span class="n">Blog</span> <span class="n">blog1</span> <span class="o">=</span> <span class="o">(</span><span class="n">Blog</span><span class="o">)</span> <span class="n">is</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
        <span class="n">is</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">blog1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<blockquote>
  <p>尤其需要说明，在上面的测试代码中，如果不将os close掉，则一直会报错，告诉<code class="highlighter-rouge">java.io.EOFException: readObject: unexpected end of file</code>.</p>

  <p>此外，处理性能上的优势，hessian还可以在<code class="highlighter-rouge">serialVersionUID</code>被后期更改的时候，反序列化也没有问题。这是因为，hessian不依赖UID来匹配类型，而且hessian在序列化完了之后的二进制流里面，会保留每个field对应的一些属性信息，虽然这些信息会增加一点流大小，但是对反序列化工作很有帮助。</p>
</blockquote>

<h4 id="kryo工具">Kryo工具</h4>

<blockquote>
  <p>关于Kryo的性能对比，可以参考<a href="http://developer.51cto.com/art/201506/480273.htm">各种 Java 的序列化库的性能比较测试结果</a>。</p>
</blockquote>

<p>Kryo是一个快速高效的Java对象序列化框架，其在java的序列化上的性能指标甚至优于google著名的序列化框架protobuf，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。总之，Kryo性能非常霸道。</p>

<p>测试代码如下：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KryoSerializable</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">serial</span><span class="o">(</span><span class="n">Blog</span> <span class="n">blog</span><span class="o">)</span><span class="kd">throws</span> <span class="n">Exception</span><span class="o">{</span>
        <span class="n">Kryo</span> <span class="n">kryo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Kryo</span><span class="o">();</span>
        <span class="n">ByteArrayOutputStream</span> <span class="n">baos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayOutputStream</span><span class="o">();</span>
        <span class="n">Output</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Output</span><span class="o">(</span><span class="n">baos</span><span class="o">);</span>
        <span class="n">kryo</span><span class="o">.</span><span class="na">writeClassAndObject</span><span class="o">(</span><span class="n">output</span><span class="o">,</span> <span class="n">blog</span><span class="o">);</span>
        <span class="n">output</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>

        <span class="n">ByteArrayInputStream</span> <span class="n">bais</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayInputStream</span><span class="o">(</span><span class="n">baos</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">());</span>
        <span class="n">Input</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Input</span><span class="o">(</span><span class="n">bais</span><span class="o">);</span>
        <span class="n">Blog</span> <span class="n">blog1</span> <span class="o">=</span> <span class="o">(</span><span class="n">Blog</span><span class="o">)</span> <span class="n">kryo</span><span class="o">.</span><span class="na">readClassAndObject</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
        <span class="n">input</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">blog1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<blockquote>
  <p>由于Kryo工具生成的字节码中是不包含field元数据信息的，这样的话，在兼容性上就很难处理了。比如我现在对一个对象增加一个字段属性，但是这样子的话，老的所有序列化二进制流就无法被正常反序列化成对象了。在很多场景下，这都是无法容忍的。</p>
</blockquote>

<h4 id="json工具">JSON工具</h4>

<blockquote>
  <p>JSON工具进行序列化和反序列化在上文已经进行了说明，并且RPC示例代码就是使用这种方式。其性能上跟hessian差不多，并且反序列化兼容会很，但是其有个比较大的缺点，就是很多类型，可能JSON工具无法支持，并且其是基于String然后再转成二进制流的，所以流的大小，可能并没有想象的那么好。</p>
</blockquote>

<h3 id="rpc协议编解码">RPC协议编解码</h3>

<blockquote>
  <p>除了序列化，在编码的上/下游还需要对二进制流或者对象做一些额外的处理，而这些处理本身和二进制流化没有太大关系。</p>
</blockquote>

<p>比如dubbo给出的处理流程，可以清晰的看出序列化和编码之间的区别(个人觉得广义的编码应该包括序列化那部分)如下：</p>

<p><img src="/images/2016/12/dubbo_codec.png" alt="dubbo线程处理流程" /></p>

<p>每个RPC组件，基本上都是直接基于Socket来开发通信层功能，但是在网络传输的数据由于网络链路和协议的问题，会出现半包，分包和粘包情况。这样就需要设计编解码协议头来解码网络流，如上dubbo视图。</p>

<p>下面我们来看下dubbo的协议编码格式(具体参考：<a href="http://dubbo.io/Developer+Guide-zh.htm#DeveloperGuide-zh-%E8%BF%9C%E7%A8%8B%E9%80%9A%E8%AE%AF%E7%BB%86%E8%8A%82">远程通讯细节</a>)：</p>

<p><img src="/images/2016/12/dubbo_protocol.png" alt="dubbo协议头" /></p>

<p>Dubbo协议头分析：</p>
<blockquote>
  <p>协议头固定长度<code class="highlighter-rouge">16</code>个字节，也就是128位。这样，当我们解码流的时候，会首先提取前16byte来解析。</p>

  <p>先来看看MAGIC设计：</p>
  <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// magic header.</span>
<span class="kd">protected</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">short</span>    <span class="n">MAGIC</span>              <span class="o">=</span> <span class="o">(</span><span class="kt">short</span><span class="o">)</span> <span class="mh">0xdabb</span><span class="o">;</span>
<span class="kd">protected</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">byte</span>     <span class="n">MAGIC_HIGH</span>         <span class="o">=</span> <span class="n">Bytes</span><span class="o">.</span><span class="na">short2bytes</span><span class="o">(</span><span class="n">MAGIC</span><span class="o">)[</span><span class="mi">0</span><span class="o">];</span>
<span class="kd">protected</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">byte</span>     <span class="n">MAGIC_LOW</span>          <span class="o">=</span> <span class="n">Bytes</span><span class="o">.</span><span class="na">short2bytes</span><span class="o">(</span><span class="n">MAGIC</span><span class="o">)[</span><span class="mi">1</span><span class="o">];</span>
</code></pre></div>  </div>
  <p><code class="highlighter-rouge">SerializationID</code>表示序列化类型ID，Dubbo支持多种序列化工具，比如hessian，jdk，fastjson等，所以需要在协议头里面指定序列化方式，这样在解码完了之后才能知道内容使用哪种工具反序列化。</p>

  <p><code class="highlighter-rouge">event</code>表示事件，比如这个请求是<code class="highlighter-rouge">heartbeat</code>。<code class="highlighter-rouge">two way</code>表示请求是否是需要交互返回数据的请求。<code class="highlighter-rouge">req/res</code>表示该数据是请求还是响应。<code class="highlighter-rouge">status</code>表示状态位，当响应数据的时候，根据该字段判断是否成功。</p>

  <p><code class="highlighter-rouge">id</code>表示请求id。这个ID真的真的很重要！！！这个id是请求客户端生成的唯一id，保证在服务运行期内id不会重复。此外，在阿里内部的RPC组件HSF最开始是将id放在data数据内，这样只有在反序列化的时候，才能拿到ReqId，但是有些时候ReqId对应的RPC请求可能由于超时或者已经被处理，导致客户端对于这种case直接丢弃就可以。因此，将id放在head里面，则直接解码的时候就可以拿到ReqId去check，而不需要额外反序列化工作。</p>

  <p><code class="highlighter-rouge">data length</code>则表示正文内容的长度。解码是通过该字段来判断消息正文字节流的整个完整包，这样反序列化就可以进行正确的转换对象了。</p>
</blockquote>

<h3 id="rpc路由和负载均衡">RPC路由和负载均衡</h3>

<blockquote>
  <p>路由策略，是完成单个机器对于服务方调用链路的选择策略,然后把客户端的服务请求传输到具体的某台服务端的机器上。负载均衡是完成路由的一种实现方式，其将前端请求根据一定算法策略来分发到不同机器上，使得集群中机器资源得到充分均衡的利用，此外还可以将不可用机器剔出请求列表。但是，显然路由除了负载均衡之外，还有其他方式。</p>

  <p>我们知道，现在的服务后台都是多台机器部署的服务集群，在这些集群在请求的入口，一般会有负责负载均衡的机器部署，来完成请求的合理分发。RPC的结构也是客户端和服务端模式，但是其结构中我们发现是没有中间代理server层的，所以对于客户端在集群中的远程服务调用，就需要客户端自己来完成负载均衡的逻辑了。</p>

  <p>除负载均衡之外，我们还会存在其他路由加强方式。比如，我们有多个机房都部署服务的时候，我需要优先选择同机房内的服务调用。</p>
</blockquote>

<p>一般定义类似如下的接口，然后根据自己的需求实现自己的负载均衡/路由策略：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ILoadBalanceStrategy</span> <span class="o">{</span>

    <span class="cm">/**
     * 从众多连接池子中选择其中一个池子.
     *
     * @param invokeConns 客户端维持的和各个服务端维持的连接池对象列表
     * @param invocation 本次客户端调用服务端相关的信息
     * @return 返回和其中一个服务端维持链接的连接池对象
     */</span>
    <span class="kd">public</span> <span class="n">InvokeConn</span> <span class="nf">select</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">InvokeConn</span><span class="o">&gt;</span> <span class="n">invokeConns</span><span class="o">,</span> <span class="n">Invocation</span> <span class="n">invocation</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<blockquote>
  <p>一般RPC组件中，会实现两个通用的负载均衡策略。随机和轮询。具体实现可以参考：<a href="https://github.com/ketao1989/ourea/tree/master/ourea-core/src/main/java/com/taocoder/ourea/core/loadbalance">https://github.com/ketao1989/ourea/tree/master/ourea-core/src/main/java/com/taocoder/ourea/core/loadbalance</a></p>
</blockquote>

<p><em>再谈谈维护可用服务列表：</em></p>

<p>一般我们会在客户端和服务端之间维持长连接，然后通过心跳机制来确保服务端是否在线提供服务。此外，对一些没有维护长连接或者可选择不建立长连接的RPC组件来说，只能通过注册服务机制来监听服务端是否下线。</p>

<p>如果调用比较频繁的服务来说，客户端可以在服务连接未成功的情况下，将该机器从服务连接列表中剔除，放在<code class="highlighter-rouge">暂时不可用机器列表</code>，然后起一个定时任务，当机器暂存5s后，再放到可用列表尝试请求服务调用。</p>

<p>关于心跳请求的定时任务，可以参考使用Netty提供的<code class="highlighter-rouge">HashedWheelTimer</code><a href="https://zacard.net/2016/12/02/netty-hashedwheeltimer/">netty源码解读之时间轮算法实现-HashedWheelTimer</a>，其提供了在不要求高精度触发定时任务的场景下，性能非常高。</p>

<p><em>最后，再聊聊服务调用路由：</em></p>

<p>服务路由，这里特指除负载均衡之外的一些服务寻址策略。和负载均衡不同的是，这里的路由策略是单个机器根据自身特点做出的服务方选择策略，而负载均衡策略则是基于整个集群中所有机器的普适策略。如上所言，我们的多机房部署，再拿到集群机器列表之后，我们还需要维持一个本机房的机器列表(一般，对服务集群列表进行按IP前缀规则来过滤)，这样当我们选择调用机器的时候，会优先从本机房获取连接，如果没有才会按照负载均衡来获取服务调用连接。</p>

<p>此外，对于一些完善的RPC框架，可能还会支持动态可配置路由规则。比如，我们可以按照机器ip来配置，某些客户端调用只能路由到某些服务端机器上。对于线上测试问题跟踪而言，可以很好的根据服务调用链路，来查看日志解决问题。</p>

<h3 id="rpc超时管理">RPC超时管理</h3>

<p>作为一个健康的服务，一定需要超时机制。相当多的服务不可用问题，都是因为客户端没有超时机制，导致服务端抖动的一段时间内，客户端一直处于占用连接等待响应的阶段，耗尽服务端资源，最后导致服务端集群雪崩。所以在请求网络服务的时候，增加超时设置是多么重要(当然，连接使用现在最大连接数的连接池也非常重要)。</p>

<p>RPC的调用实现，一般会有一个IO线程池来处理RPC调用，也就是我们的业务线程会将调用请求交给RPC线程来处理，返回一个future对象。远程调用处理完成之后，RPC线程会将结果填充到<code class="highlighter-rouge">futrue</code>对象内部，然后告知调用方调用完成，可以使用<code class="highlighter-rouge">futrue.get</code>来获取返回数据。如下所示：</p>

<p><img src="/images/2016/12/timeout.png" alt="RPC客户端调用处理" /></p>

<p>从上图可以看出，<code class="highlighter-rouge">超时1</code>我们可以直接使用<code class="highlighter-rouge">futrue.get</code>特性来设置和处理超时问题。<code class="highlighter-rouge">超时2</code>指的是服务端执行的超时，比如我们客户端调用的时间是1s，但是服务端可能会超过1s，而这个时候客户端其实已经超时丢弃这次请求，但是服务端还一直执行直到完成返回，这个时候服务端需要序列化对象然后传输到客户端，但是这个流程其实可以简化的。</p>

<p>因此，服务端的超时管理，是当服务端业务逻辑执行完成之后(这期间实现超时中断比较难)，比较执行时间和客户端设置的超时时间，如果接近，则打包服务端超时错误信息返回给客户端即可。这样可以节省序列化数据时间(直接使用序列化好了的数据返回)，已经减少网络传输时间。</p>

<h3 id="rpc-服务发现">RPC 服务发现</h3>

<p>在对外http服务里，我们有一个配套的支撑基础组件叫做DNS，其根据域名找到某几个外网ip地址。然后，请求打到网站内部，一般首先到nginx群，nginx也会根据url规则找到配置好的一组ip地址，此外，nginx根据healthcheck来检查http服务是否可用。但是，使用nginx时，我们通常需要把ip地址离线配置到nginx上。</p>

<p>我们提供的RPC服务都是集群部署，所以我们需要在客户端维持一个服务调用地址列表。所以，我们也需要类似DNS功能的服务。 但是，我们不想我们的RPC服务集群有机器迁移或者增加时，所需要离线给客户端配置，这就是说，我们还需要实时更新集群机器列表的功能。</p>

<p>这，就是RPC服务发现模块需要解决的问题。</p>

<p>一般，服务发现主要包括2部分：</p>
<ol>
  <li>服务地址存储；</li>
  <li>服务状态感知。</li>
</ol>

<h4 id="服务地址存储">服务地址存储</h4>

<p>服务地址存储，首先需要一个组件来存放服务机器列表等RPC服务数据，提供存储服务的组件有很多，比如：zookeeper，redis，mysql等等。然后，在服务端正常启动可以提供服务之后，需要将自己的服务地址，比如ip，port，以及服务信息，比如接口，版本号等信息，提交到存储服务机器上。然后，客户端在启动的时候，从存储服务的机器上，根据接口，版本等服务信息来拿到提供对应服务的RPC地址列表，客户端根据这个列表就可以开始调用远程服务了。</p>

<p>此外，为了服务治理，比如我们需要知道哪些客户端调用了我们对外提供的服务，就需要客户端在启动的时候，把自己的地址数据和调用的服务信息提交到存储服务上去。</p>

<p>对于提供比较完善的服务治理功能，还可以提供后台操作界面，让某些服务端机器手动操作上/下线，这样让通过RPC调用的客户端不将流量打到下线的服务器上。</p>

<p>简单的服务发现，RPC方和存储组件之间的交互如下：</p>

<p><img src="/images/2016/12/find.png" alt="RPC服务发现结果" /></p>

<h4 id="服务状态感知">服务状态感知</h4>

<p>这里的服务感知，包括客户端感知服务端状态，以及存储服务感知RPC参与方的状态。</p>

<p>正常情况下，我们从存储组件那里拿到服务端地址后，自己来处理路由策略，然后选择一个服务端建立连接，执行远程调用。在执行的过程中，如果有服务不可用，我们可以从我们的服务列表中，将它剔除。但是，如果服务增加机器或者服务机器迁移了呢？这就需要我们及时了解服务端集群的整体机器状态。两种方式：</p>
<ol>
  <li>客户端其一个定时调度任务，周期去存储组件处拉取最新的服务集群地址列表，但是这个周期粒度比较难控制。</li>
  <li>客户端和存储组件建立一个长连接，当存储组件发现有服务集群状态发生变更，推送给客户端。但是，这又要求存储组件具有推送功能。</li>
</ol>

<p>目前有这个功能的存储组件，主要有zookeeper和redis，此外，也可以自己实现一个简单可靠的服务发现中间件，对外提供推送存储服务。</p>

<p>我们在服务启动的时候，会告知存储组件我们对外提供服务的地址信息和客户端的地址信息；在服务已知操作的服务下线的时候，会将存储组件中存储的服务相关信息清除掉。但是，显然，在服务下线或者客户端下线的时候，都存在没有清除存储信息就宕机的情况，这个时候就需要存储组件需要有感知各个参与方的状态了。</p>

<p>一般，我们会让RPC两方都和存储组件保持连接，然后通过心跳等方式来探测对方是否下线。</p>

<p>目前提供这个功能的存储组件，主要有zookeeper和redis。当然，你也可以实现一个，可以和所有注册服务和查找服务的server保持长连接。由于，可能有大量的机器建立长连接，所以服务器性能一定要高。</p>

<blockquote>
  <p>基于zookeeper实现服务发现功能的代码，可以参考：<a href="https://github.com/ketao1989/ourea">https://github.com/ketao1989/ourea</a></p>
</blockquote>

<h3 id="rpc-多线程io模型">RPC 多线程IO模型</h3>

<h2 id="最后">最后</h2>

<p>RPC其实是一个说简单简单，说复杂复杂的组件。就如上文写的一个简单的RPC示例，其本身就是一个具备RPC功能的组件。但是，在深入篇中，可以看到每一个模块都可以深入优化，以及支持模块化插件话设计开发。</p>

<p>本文从单机到集群，从本地调用到远程调用的渐进过度。然后再从一个满足RPC结构图的简单示例开始，代码介绍每个模块，进而深入成熟RPC框架所需要考虑和优化的各个技术点。</p>

<p>本文的目的，旨在对RPC整体结构和各个模块进行介绍和深入，然后根据这些点，可以去分析开源的RPC框架或者自己写一个RPC组件。</p>

<p>在本文中，很多点都是一边学习，一边总结，所以知识有限，如有问题，欢迎交流。</p>

<h2 id="参考文献">参考文献</h2>
<ol>
  <li><a href="https://yq.aliyun.com/articles/8931">linux内存管理浅析</a></li>
  <li><a href="http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1601_clark-trs/1601_clark.html">微服务、SOA 和 API：是敌是友？</a></li>
  <li><a href="http://tech.meituan.com/serialization_vs_deserialization.html">序列化和反序列化</a></li>
</ol>

                </div>
                <div class="read-all">
                    <a  href="/2016/12/10/rpc-theory-in-action/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2016/05/29/talk-about-java-gc/">聊聊 Java GC</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2016-05-29
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Java" title="Category: Java" rel="category">Java</a>&nbsp;
    
        <a href="/category/#GC" title="Category: GC" rel="category">GC</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <h2 id="序"><a id="Preface">序</a></h2>

<p>GC 是每一个Java程序员不可绕过的话题。GC 是在<code class="highlighter-rouge">某些时候</code>对<code class="highlighter-rouge">内存</code>的垃圾<code class="highlighter-rouge">对象数据</code>进行<code class="highlighter-rouge">搜寻定位</code>，然后进行内存空间<code class="highlighter-rouge">回收</code>。根据这个定义，则学习GC相关知识，需要关注：对JVM整个内存结构中哪些区域进行垃圾回收；在这些内存区域中的类数据或者实例数据等数据结构是什么样子的；然后想想如何在JVM内存空间中分配内存给这些实例数据；在所有已分配了的实例里，怎么找出需要回收的数据。</p>

<p>综上，对于JVM GC知识体系来说，就是弄清楚JVM在什么时候，对什么对象，进行什么操作来回收内存空间。</p>

<h2 id="jvm-内存结构"><a id="JVM_Memory">JVM 内存结构</a></h2>

<p>既然是对内存进行GC操作，那么首先需要了解 JVM 的内存结构了。</p>

<p>在Oracle的官方文档【<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">Java Garbage Collection Basics</a>】中，给出了JVM的整体架构图，如下所示：</p>

<p><img src="/images/2016/05/jvm_conponent.png" alt="JVM架构图" /></p>

<p>也就是说，对一个JVM来说，其主要由 <code class="highlighter-rouge">ClassLoader</code> 和 <code class="highlighter-rouge">Runtime Data 区域</code> ,<code class="highlighter-rouge">执行引擎</code>以及<code class="highlighter-rouge">本地方法</code>四大部分组成。(关键的性能优化集中在<code class="highlighter-rouge">Heap</code>,<code class="highlighter-rouge">JIT编译</code>和<code class="highlighter-rouge">GC</code>三大块)。</p>

<!-- more -->

<h3 id="classloader">ClassLoader</h3>

<p>从架构图中，可以看出，<code class="highlighter-rouge">ClassLoader</code>是用来加载java class文件的，也就是说，在java的世界里，所有的<code class="highlighter-rouge">*.class</code>都必须通过<code class="highlighter-rouge">ClassLoader</code>加载到JVM虚拟机中，才能被执行。</p>

<p>对于每一个JVM来说，都会有一个默认的<code class="highlighter-rouge">ClassLoader</code>，用来加载二进制文件到内存中。当然，既然是默认，必然就存在自定义的<code class="highlighter-rouge">ClassLoader</code>了。</p>

<p>但是，在JVM中，存在自定义的<code class="highlighter-rouge">ClassLoader</code>，就需要考虑如果不让自定义的实现类加载逻辑，导致java基础类库的对象发生不可预知的安全问题，所以JVM 的<code class="highlighter-rouge">ClassLoader</code> 对类加载的顺序逻辑进行的限制。这就是所谓的<code class="highlighter-rouge">双亲委派模型</code>。</p>

<p><img src="/images/2016/05/classloader.png" alt="ClassLoader架构" /></p>

<p>上图（来自【<a href="http://blog.csdn.net/xyang81/article/details/7292380">深入分析Java ClassLoader原理</a>】）展示了JVM ClassLoader 的三个模型的加载器以及应用可以自己实现的自定义加载器。从图上可以看出除了<code class="highlighter-rouge">Bootstrap ClassLoader</code>不存在父类之后，其他ClassLoader都有父类加载器。</p>

<p><code class="highlighter-rouge">双亲委派模型</code>就是说，ClassLoader 在加载类的时候，其首先去父类里查找是否其已经加载了该类，一层层递归查找，没有的话，就依次自己尝试加载该类，如果没找到，则会抛出<code class="highlighter-rouge">ClassNotFoundException</code>，当最外层的子类依然没加载成功，则最终的依次将会抛出到应用中。</p>

<p>简单来说，就是首先向上(父类方向)查找类是否加载，然后如果没有已经被加载，则向下(子类方向)尝试去加载类，直到加载成功，或者抛出异常。</p>

<p>简单地源码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">protected</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">loadClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">resolve</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">ClassNotFoundException</span>
    <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">getClassLoadingLock</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// First, check if the class has already been loaded</span>
            <span class="n">Class</span> <span class="n">c</span> <span class="o">=</span> <span class="n">findLoadedClass</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">long</span> <span class="n">t0</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span><span class="c1">//向上查找</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">findBootstrapClassOrNull</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// ClassNotFoundException thrown if class not found</span>
                    <span class="c1">// from the non-null parent class loader</span>
                <span class="o">}</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// If still not found, then invoke findClass in order</span>
                    <span class="c1">// to find the class.</span>
                    <span class="kt">long</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">findClass</span><span class="o">(</span><span class="n">name</span><span class="o">);</span><span class="c1">//自己加载</span>

                    <span class="c1">// this is the defining class loader; record the stats</span>
                    <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">PerfCounter</span><span class="o">.</span><span class="na">getParentDelegationTime</span><span class="o">().</span><span class="na">addTime</span><span class="o">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="o">);</span>
                    <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">PerfCounter</span><span class="o">.</span><span class="na">getFindClassTime</span><span class="o">().</span><span class="na">addElapsedTimeFrom</span><span class="o">(</span><span class="n">t1</span><span class="o">);</span>
                    <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">PerfCounter</span><span class="o">.</span><span class="na">getFindClasses</span><span class="o">().</span><span class="na">increment</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">resolve</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">resolveClass</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">c</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

</code></pre></div></div>

<h3 id="jvm-运行时内存空间">JVM 运行时内存空间</h3>

<p><img src="/images/2016/05/jvm_mm.png" alt="JVM架构-运行时数据区" /></p>

<p>上图【<a href="https://segmentfault.com/a/1190000002579346">JVM 的 工作原理，层次结构 以及 GC工作原理</a>】中可以看出线程和内存区域之间的关系。对于具体的内存空间结构，如下图所示：</p>

<p><img src="/images/2016/05/jvm_mm2.png" alt="内存结构" /></p>

<p>上图包含除<code class="highlighter-rouge">ClassLoader</code>之外，JVM架构的其他三个部分。执行引擎中JIT是对java程序执行时的优化操作，GC引擎则是本文的重点，后面会详细介绍。本地方法则是使用C/C++编写的底层代码程序，这里不作介绍。</p>

<p>下面重点来说说，绿色区域的运行时数据区。</p>

<h4 id="线程私有">线程私有</h4>

<ul>
  <li>程序计数器：和系统中PC一样，就是执行下一条需要执行的指令；每一个线程都对应一个程序计数器；但是执行本地方法由于对JVM透明，所以对应程序计数器为空。</li>
  <li>虚拟机栈：如上图所示，一个虚拟机栈包含局部变量，操作数栈，返回地址等信息。对于一个线程中的每一个方法，都有对应的虚拟机栈。虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StatckOverFlowError（栈溢出）；不过多数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，直到内存不足，此时，会抛出OutOfMemoryError（内存溢出）。</li>
  <li>本地方法栈：执行native方法时，所需要的栈空间。</li>
</ul>

<blockquote>
  <blockquote>
    <p>本地方法栈和虚拟机栈在HotSpot实现里，是合并在一起的，统称为栈。</p>
  </blockquote>
</blockquote>

<h4 id="线程共享">线程共享</h4>

<ul>
  <li>方法区：方法区是对所有类共享的，所以多线程操作需要进行同步处理。其内部主要存储加载类的相关信息（包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。
    <blockquote>
      <blockquote>
        <p>如上图，方法区中其中一个重要内容就是运行时常量池，但是这个在JDK7中已经移到堆中存储了。运行时常量池，包括编译后的字符常量，以及运行时的常量。因此，以前String.itern()导致的常量池爆掉抛出<code class="highlighter-rouge">java.lang.OutOfMemoryError: PermGen space</code>错误，现在没有了。</p>
      </blockquote>
    </blockquote>
  </li>
  <li>堆：一般来说，JVM所有的对象实例都是存储在堆上的，因此其也是线程共享的。对于JVM GC来说，其主战场就是堆空间。因此，后面的GC 操作都是基于堆空间的回收策略分析的。</li>
</ul>

<h3 id="小结">小结</h3>

<p>JVM 的内存结构，实际上就是堆和栈，栈是线程私有的，因此上面的对象不需要同步操作，并且重点是由于栈帧是伴随着线程方法的生命周期的，所以其内部的垃圾回收不用考虑(这里说的是存储在栈上的数据，当然方法里的变量，实例数据等分配在堆上的，还是需要垃圾回收的)。</p>

<p>堆上面包含几乎所有交互操作数据，各个对象实例，变量等信息都是由堆来分配管理，因此，JVM的垃圾回收就是基于堆的垃圾回收。</p>

<h2 id="jvm-对象实例结构"><a id="Class_Instace">JVM 对象实例结构</a></h2>

<p>垃圾回收是回收内存中标记为不再使用的对象实例，因此，需要了解对象的结构和对应的引用被访问的方式。</p>

<h3 id="对象实例结构">对象实例结构</h3>

<p>在C的世界里，我们会经常计算一个数据结构所占用的内存空间；那么对于Java而言，一个对象的数据结构和内存占用是怎样的呢。</p>

<p>对象的实例内存布局主要包括三部分：对象头(Header)、实例数据(Instance Data)和对其数据(Padding)。</p>

<h4 id="jvm-对象头">JVM 对象头</h4>
<p>对于JDK默认的虚拟机HotSpot来说，其对象头主要包含两部分：</p>
<ul>
  <li>所谓的<code class="highlighter-rouge">Mark Word</code>，用于存储对象自身的运行时数据，比如hashcode，<code class="highlighter-rouge">GC分代年龄</code>(这个在分代GC中很重要)以及锁状态标识和线程ID等相关信息。这部分在32bit和64bit的JVM上占用的空间是不同的，分别为4B 和 8B。如下图所示：</li>
</ul>

<p>32bit:<br />
<img src="/images/2016/05/32_bits.png" alt="32bit" /></p>

<p>64bit:<br />
<img src="/images/2016/05/64_bits.png" alt="64bit" /></p>

<p>不管32还是64，其GC分代年龄都是4bit，因此，分代年龄最高为15。</p>
<ul>
  <li>类型指针(kclass)，即对象指向其类元数据的指针，JVM通过这个指针可以确定该对象是哪个类的实例。比如，针对java对象调用 <code class="highlighter-rouge">ins instanceOf Clazz </code>方法，就是首先通过ins对象头中该指针来找到方法区中该类的相关信息，然后匹配Clazz以及其super链，匹配上了，则说明是其对应的实例对象。</li>
</ul>

<blockquote>
  <blockquote>
    <p>此外，如果是数组类型的话，则在对象头中还有一块空间是用来存储数组长度，不管32还是64，这个长度占用的空间都是4B，因此，数组最大长度为<code class="highlighter-rouge">Integer.MAX_VALUE</code>。</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>一般的，对象头在32bit下，大小为4B+4B=8B，而64bit为8B+8B=16B。(开启指针压缩，则为8B+4B=12B)</p>
  </blockquote>
</blockquote>

<h4 id="实例数据">实例数据</h4>
<p>顾名思义，就是对象真正存储有效信息的地方。无论数据是从父类继承下来的，还是子类中定义的，都在这里记录下来。java中基础类型的内存占用如下：</p>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th style="text-align: right">占用字节bytes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>boolean</td>
      <td style="text-align: right">1</td>
    </tr>
    <tr>
      <td>byte</td>
      <td style="text-align: right">1</td>
    </tr>
    <tr>
      <td>short</td>
      <td style="text-align: right">2</td>
    </tr>
    <tr>
      <td>char</td>
      <td style="text-align: right">2</td>
    </tr>
    <tr>
      <td>int</td>
      <td style="text-align: right">4</td>
    </tr>
    <tr>
      <td>float</td>
      <td style="text-align: right">4</td>
    </tr>
    <tr>
      <td>long</td>
      <td style="text-align: right">8</td>
    </tr>
    <tr>
      <td>double</td>
      <td style="text-align: right">8</td>
    </tr>
    <tr>
      <td>ref</td>
      <td style="text-align: right">4/8</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <blockquote>
    <p>一般来说，一个对象实例原生数据和实例在一起，而最引用类型只是一个地址，具体的数据，在指向堆上其他对应的实例。</p>
  </blockquote>
</blockquote>

<h4 id="对齐数据">对齐数据</h4>
<p>在HotSpot JVM 中，内存中的数据都要求是按8B字节对其的，如果一个对象大小不是8B，则会自动填充对其到8B的倍数。</p>

<h3 id="对象访问方式">对象访问方式</h3>

<p>如上文所述，一个对象的数据，可能会包含其他对象的引用，那么在使用的时候，就需要找到对应的对象数据信息。</p>

<p>【<a href="http://www.infoq.com/cn/articles/jvm-hotspot">HotSpot虚拟机对象探秘</a>】
Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范里面只规定了是一个指向对象的引用，并没有定义这个引用应该通过什么种方式去定位、访问到堆中的对象的具体位置，对象访问方式也是取决于虚拟机实现而定的。主流的访问方式有使用句柄和直接指针两种。</p>

<ul>
  <li>如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。如图1所示。</li>
</ul>

<p><img src="/images/2016/05/indirect.png" alt="indirect" /></p>

<ul>
  <li>如果使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如图2所示。</li>
</ul>

<p><img src="/images/2016/05/direct.png" alt="direct" /></p>

<p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p>

<p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项非常可观的执行成本。从上一部分讲解的对象内存布局可以看出，就虚拟机<code class="highlighter-rouge">HotSpot</code>而言，它是使用第二种方式进行对象访问，但在整个软件开发的范围来看，各种语言、框架中使用句柄来访问的情况也十分常见。</p>

<h2 id="jvm-垃圾对象判断"><a id="Garbage_Search">JVM 垃圾对象判断</a></h2>

<p>垃圾对象查找，首先需要明确什么对象可以认为是垃圾对象。</p>

<h3 id="垃圾对象">垃圾对象</h3>

<p>判断一个对象是不是垃圾对象，需要去回收其占用的内存空间，一般有两张方法，一种是基于引用计数，一种是可达性分析。</p>

<h4 id="引用计数">引用计数</h4>

<p>引用计数，操作起来非常简单。就是在全局维护一个Map，当引用一个对象的时候，就给对应的map entry 的value加1；当这个引用失效的时候，就将对应的value减1。当value的值为0的时候，就说明此刻该对象是垃圾对象，可以被回收掉。</p>

<p>因此，引用计数基本上可以做到实时去回收空间，但是它有一个大问题，就是无法处理循环引用的问题。此外，对每一个对象的申请或者销毁都会导致其内部引用的对象计数进行实时更改，这个操作量级还是相当大的，这种开销有时候对应用来说可能都不能容忍。比如，有一个对象内部包含了非常多的局部变量，并且引用的这些变量可能全局Map都剩1，则当这个对象销毁的时候，其会触发大量的引用计数为0，从而大量对象进行销毁回收操作，这些操作可能导致系统暂时无法响应其他请求。</p>

<p>因此，现在一些编译器即使使用引用计数自动回收垃圾，也会加上其他辅助算法，比如标记-清除。</p>

<h4 id="可达性分析">可达性分析</h4>

<p>可达性分享，也就是 <code class="highlighter-rouge">Tracing GC</code>。Tracing GC的核心操作之一就是从给定的根集合出发去遍历对象图。对象图是一种有向图，该图的节点是对象，边是引用。遍历它有两种典型顺序：深度优先（DFS）和广度优先（BFS）。【<a href="http://hllvm.group.iteye.com/group/topic/39376">HotSpot VM Serial GC的一个问题</a>】</p>

<blockquote>
  <blockquote>
    <p>由于深度优先DFS一般采用递归方式实现，处理tracing的时候，可能会导致栈空间溢出，所以一般采用广度优先来实现tracing。</p>
  </blockquote>
</blockquote>

<p>广度优先遍历其实很简单，就是将遍历到了的节点处理，然后将子节点放入到队列中，迭代处理每个队列节点，直到队列为空。如下图所示：</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/4/46/Animated_BFS.gif" alt="image" /></p>

<p>对于HotSpot来说，其<code class="highlighter-rouge">GC Roots</code>为：</p>
<ul>
  <li>虚拟机栈中引用的对象（栈帧中局部变量表中的对象）；</li>
  <li>方法区中静态属性和常量引用的对象；</li>
  <li>本地方法栈中的对象。</li>
</ul>

<p>因此，在遍历之前，将这些对象放入扫描的队列中，然后依次迭代遍历。</p>

<p>下面给出了一个简化版的遍历算法实现：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">void</span> <span class="nf">breadth_first_search</span><span class="p">(</span><span class="n">Graph</span><span class="o">*</span> <span class="n">graph</span><span class="p">)</span> <span class="p">{</span>  
  <span class="c1">// 记录灰色对象的队列  </span>
  <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">scanning</span><span class="p">;</span>  
  
  <span class="c1">// 1. 一开始对象都是白色的  </span>
  
  <span class="c1">// 2. 把根集合的引用能碰到的对象标记为灰色  </span>
  <span class="c1">// 由于根集合的引用有可能有重复，所以这里也必须  </span>
  <span class="c1">// 在把对象加入队列前先检查它是否已经被扫描到了  </span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">:</span> <span class="n">graph</span><span class="o">-&gt;</span><span class="n">root_edges</span><span class="p">())</span> <span class="p">{</span>  
    <span class="c1">// 如果出边指向的对象还没有被扫描过  </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">is_marked</span><span class="p">())</span> <span class="p">{</span>  
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">set_marked</span><span class="p">();</span>        <span class="c1">// 记录下它已经被扫描到了  </span>
      <span class="n">scanning</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">child</span><span class="p">);</span> <span class="c1">// 也把该对象放进灰色队列里等待扫描  </span>
    <span class="p">}</span>  
  <span class="p">}</span>  
  
  <span class="c1">// 3. 逐个扫描灰色对象的出边直到没有灰色对象  </span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">scanning</span><span class="p">.</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span>  
    <span class="n">Node</span><span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">scanning</span><span class="p">.</span><span class="n">dequeue</span><span class="p">();</span>  
    <span class="k">for</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">child</span> <span class="o">:</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">child_nodes</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 扫描灰色对象的出边  </span>
      <span class="c1">// 如果出边指向的对象还没有被扫描过  </span>
      <span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">is_marked</span><span class="p">())</span> <span class="p">{</span>  
        <span class="n">child</span><span class="o">-&gt;</span><span class="n">set_marked</span><span class="p">();</span>       <span class="c1">// 把它记录到黑色集合里  </span>
        <span class="n">scanning</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">child</span><span class="p">);</span> <span class="c1">// 也把该对象放进灰色队列里等待扫描  </span>
      <span class="p">}</span>  
    <span class="p">}</span>  
  <span class="p">}</span>  
<span class="p">}</span>  

</code></pre></div></div>

<p>如上遍历完之后，如果某些对象没有被遍历标记到，则它就有<code class="highlighter-rouge">可能</code>会被回收了。</p>

<blockquote>
  <blockquote>
    <p>可能被回收，则说明也有可能不会被回收。其实，在HotSpot的实现中，对象是有两次机会逃过被垃圾回收销毁的命运的。</p>

    <p>如果对象进行可达性遍历之后，发现没有和GC Roots有相连的引用，则将该对象标记为不可达对象，并且进行筛选：对象是否覆盖finalize方法或者是否已经执行了该方法来决定是否接下来执行<code class="highlighter-rouge">finalize()</code>方法。</p>

    <p>如果对象判定为需要执行finalize()方法，则将该对象放入<code class="highlighter-rouge">F-Queue</code>队列中，然后由一个虚拟机创建的低优先级Finalizer线程去触发执行队列中的finalize()方法，但是不一定会被执行（可能前面的finalize方法导致线程一直阻塞无法继续遍历执行下去）。因此，这种情况下，对象可能并不会被销毁回收。</p>

    <p>稍后GC将对<code class="highlighter-rouge">F-Queue</code>队列进行第二次标记，如果这次标记还无效的话，则真的被回收销毁了。</p>
  </blockquote>
</blockquote>

<h3 id="jvm-gc-引用">JVM GC 引用</h3>

<p>【<a href="http://www.zhihu.com/question/34341582/answer/58444959">这段 Java 代码中的局部变量能够被提前回收吗？编译器或 VM 能够实现如下的人工优化吗？</a>】<br />
【<a href="http://rednaxelafx.iteye.com/blog/1044951">找出栈上的指针/引用</a>】</p>

<p>在前面章节中已经介绍了内存对象结构和访问方式，并且知道栈帧中的引用类型是GC Roots集合中的一个重要的部分，因此要获取这些引用类型数据就是GC的重要一步了。</p>

<h4 id="保守gc">保守GC</h4>

<p>如果JVM选择不记录任何这种类型的数据，那么它就无法区分内存里某个位置上的数据到底应该解读为引用类型还是原生类型。这种GC就是“保守式GC（conservative GC）”。在进行GC的时候，JVM开始从一些已知位置（例如说JVM栈）开始扫描内存，扫描的时候每看到一个数字就看看它“像不像是一个指向GC堆中的指针”。这里会涉及上下边界检查（GC堆的上下界是已知的）、对齐检查（通常分配空间的时候会有对齐要求，假如说是8字节对齐，那么不能被8整除的数字就肯定不是指针），之类的。然后递归的这么扫描出去。</p>

<p>保守式GC的好处是相对来说实现简单些，而且可以方便的用在对GC没有特别支持的编程语言里提供自动内存管理功能。比如在C或者C++语言中自己实现。</p>

<p>保守式GC的缺点有：</p>

<ol>
  <li>
    <p>会有部分对象本来应该已经死了，但有疑似指针指向它们，使它们逃过GC的收集。这对程序语义来说是安全的，因为所有应该活着的对象都会是活的；但对内存占用量来说就不是件好事，总会有一些已经不需要的数据还占用着GC堆空间。具体实现可以通过一些调节来让这种无用对象的比例少一些，可以缓解（但不能根治）内存占用量大的问题。</p>
  </li>
  <li>
    <p>由于不知道疑似指针是否真的是指针，所以它们的值都不能改写；移动对象就意味着要修正指针。换言之，对象就<code class="highlighter-rouge">不可移动</code>了。有一种办法可以在使用保守式GC的同时支持对象的移动，那就是增加一个间接层，不直接通过指针来实现引用，而是添加一层“句柄”（handle）在中间，所有引用先指到一个句柄表里，再从句柄表找到实际对象。这样，要移动对象的话，只要修改句柄表里的内容即可。但是这样的话引用的访问速度就降低了。Sun JDK的Classic VM曾经用过这种全handle的设计，但效果实在算不上好。</p>
  </li>
</ol>

<p>由于JVM要支持丰富的反射功能，本来就需要让对象能了解自身的结构，而且这种信息GC的时候也可以利用上，所以JVM都会保留一些信息在对象上，而不会采用完全保守式的GC。</p>

<h4 id="半保守gc">半保守GC</h4>

<p>JVM可以选择在栈上不记录类型信息，而在对象上记录类型信息。这样的话，扫描栈的时候仍然会跟上面说的过程一样，但扫描到GC堆内的对象时，因为对象带有足够类型信息，JVM就够判断出在该对象内什么位置的数据是引用类型了。这种是“半保守式GC”。</p>

<p>为了支持半保守式GC，运行时需要在对象上带有足够的元数据。如果是JVM的话，这些数据可能在类加载器或者对象模型的模块里计算得到，但不需要JIT编译器的特别支持。</p>

<p>由于半保守式GC在堆内部的数据是准确的，所以它可以在直接使用指针来实现引用的条件下支持部分对象的移动，方法是只将保守扫描能直接扫到的对象设置为不可移动（pinned），而从它们出发再扫描到的对象就可以移动了。</p>

<p>完全保守的GC通常使用不移动对象的算法，例如mark-sweep。半保守方式的GC既可以使用mark-sweep，也可以使用移动部分对象的算法。半保守式GC对JNI方法调用的支持会比较容易：管它是不是JNI方法调用，是栈都扫过去，不需要对引用做任何额外的处理。当然代价跟完全保守式一样，会有“疑似指针”的问题。</p>

<h4 id="准确gc">准确GC</h4>

<p>与保守式GC相对的是“准确式GC”。也就是说给定某个位置上的某块数据，要能知道它的准确类型是什么，这样才可以合理地解读数据的含义；GC所关心的含义就是“这块数据是不是指针”。 要实现这样的GC，JVM就要能够判断出所有位置上的数据是不是指向GC堆里的引用，包括活动记录（栈+寄存器）里的数据。</p>

<p>实现方法是：从外部记录下类型信息，存成映射表。HotSpot把这样的数据结构叫做OopMap。其每次都遍历原始的映射表，循环的一个个偏移量扫描过去；这种用法也叫“解释式”；HotSpot采用的是这种方式。(示例可以参考safePoint例子)</p>

<p>在HotSpot中，对象的类型信息里有记录自己的OopMap，记录了在该类型的对象内什么偏移量上是什么类型的数据。所以从对象开始向外的扫描可以是准确的；这些数据是在类加载过程中计算得到的。</p>

<p>每个被JIT编译过后的方法也会在一些特定的位置记录下OopMap，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用。这样GC在扫描栈的时候就会查询这些OopMap就知道哪里是引用了。这些位置就是“安全点”（safepoint）。之所以要选择一些特定的位置来记录OopMap，是因为如果对每条指令（的位置）都记录OopMap的话，这些记录就会比较大，那么空间开销会显得不值得。选用一些比较关键的点来记录就能有效的缩小需要记录的数据量，但仍然能达到区分引用的目的。因为这样，HotSpot中GC不是在任意位置都可以进入，而只能在safepoint处进入。而仍然在解释器中执行的方法(非JIT优化的代码)则可以通过解释器里的功能自动生成出OopMap出来给GC用。</p>

<p>平时这些OopMap都是压缩了存在内存里的；在GC的时候才按需解压出来使用。</p>

<h4 id="gc-safepoint位置">GC SafePoint位置</h4>

<p>在HotSpot JVM中，解释执行的方法可以在任何字节码边界上执行GC，但是对于采用JIT编译执行的方法，则不能想GC就GC了，必须进入到GC SafePoint 位置。</p>

<ul>
  <li>主动SafePoint：由方法里的代码主动轮询去发现需要进入SafePoint，两种情况：
    <ul>
      <li>循环回跳处(loop backedge)；</li>
      <li>方法返回处(return)；</li>
      <li>可能抛出异常的问题(throw)。</li>
    </ul>
  </li>
  <li>被动SafePoint：调用别的方法的调用点。之所以叫做“被动”是因为并不是该方法主动发现要进入safepoint的，而是某个被调用的方法主动进入了safepoint，导致其整条调用链上的调用者都被动的进入了safepoint。</li>
</ul>

<p>比如下面的这个简单方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">LargeObject</span> <span class="n">lo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LargeObject</span><span class="o">();</span> <span class="c1">// safepoint 1/2: 被动safepoint</span>
  <span class="c1">// OopMap 1: 空。</span>
  <span class="c1">// 该栈帧里尚未有任何引用类型的局部变量是活跃的——new还没执行完</span>
  <span class="c1">// OopMap 2: 记录了一个变量：刚分配的对象的引用是活的，在OopMap里；不过这还不是局部变量lo而是求值栈上的一个slot</span>
  <span class="n">lo</span><span class="o">.</span><span class="na">doSomeThing</span><span class="o">();</span>                   <span class="c1">// safepoint 3: 被动safepoint</span>
  <span class="c1">// OopMap 3: 空。局部变量lo的最后一次使用是作为上面方法的"this"参数传递出去；</span>
  <span class="c1">// 维持"this"的存活是被调用方法的责任而不是调用方法的责任。此后局部变量lo再也没有被使用过，所以对main()来说lo在此处已死。</span>

  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">whatever</span><span class="o">();</span>                       <span class="c1">// safepoint 4: 被动safepoint</span>
    <span class="c1">// OopMap 4: 空。</span>

    <span class="c1">// safepoint 5: 主动safepoint：循环回跳轮询（backedge poll）</span>
    <span class="c1">// OopMap 5: 空。</span>
  <span class="o">}</span>
  <span class="c1">// 上面循环是无限循环，所以下面如果有代码都属于不可到达的代码（unreachable code）</span>

  <span class="c1">// 如果上面的循环不是无限循环的话，则：</span>
  <span class="c1">// safepoint 6: 主动safepoint：返回前轮询（return poll）</span>
  <span class="c1">// OopMap 6: 空</span>
<span class="o">}</span>

</code></pre></div></div>

<h2 id="jvm-内存管理"><a id="JVM_Management">JVM 内存管理</a></h2>

<p>前面讲了这么多，都是在介绍JVM内存中一些区域的划分，对象在内存中的结构，以及HotSpot JVM 支持的精确式GC所采用的数据结构等等。</p>

<p>下面，进入重点。Java 中创建一个对象时，JVM 内存如何处理，当内存空间不够时，又是如何触发垃圾回收的。</p>

<h3 id="内存分配">内存分配</h3>

<p>一般的，在java里面讨论内存分配都以为是建立在堆上，但这个不熟绝对的。细分的话，给一个新对象分配内存空间，可能是在栈上，TLAB(Thread Local Allocation Buffer) 或者堆上。</p>

<h4 id="逃逸分析之栈分配">逃逸分析之栈分配</h4>

<p>在 JVM中提供了一种内存分配优化的方式，就是基于逃逸分析技术，将新的对象实例分配到栈上。所谓逃逸分析，就是分析指针<code class="highlighter-rouge">动态范围</code>的方法。简而言之，就是当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。而用来分析这种逃逸现象的方法，就称之为逃逸分析。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">class</span> <span class="nc">Test</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setList</span><span class="o">(){</span>
        <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span> <span class="c1">// list是全局变量，发生逃逸</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">getListValue</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();;</span>    <span class="c1">// 返回了list，发生了逃逸</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">echoTmp</span><span class="o">(){</span>
        <span class="n">TestClass</span> <span class="n">clazz</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestClass</span><span class="o">();</span><span class="c1">//未发生逃逸</span>
        <span class="n">clazz</span><span class="o">.</span><span class="na">echo</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="err">'</span><span class="n">ok</span><span class="o">.</span><span class="err">'</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>那么，当一个方法中有变量没有发生逃逸事件，则VM可以根据设置进行内存分配优化。</p>

<p>从上文的对象定位可以看到，一般情况下，java对象都是在堆上分配，然后其引用指针保存在调用栈对应位置，然后在访问的时候，需要两次查找才能获取完所有的需要的对象信息，而在栈上分配对象内存的话，就避免了这个耗时。此外，当对象不在使用的时候，由于只是方法内部使用，所以下次GC就需要回收这些对象，这又需要GC线程去遍历对象树来回收内存。</p>

<blockquote>
  <blockquote>
    <p>逃逸分析的内存优化并不能在静态编译的时候进行，而需要在JIT动态编译的时候触发。逃逸分析是基于方法内部执行来的，当时在静态编译的时候，由于Java动态代理，反射等特性导致最终运行时候的逻辑是无法知道的。关于这个话题具体讨论参考【<a href="https://www.zhihu.com/question/27963717">逃逸分析为何不能在编译期进行？</a>】</p>

    <p>在测试的时候，你需要<code class="highlighter-rouge"> -XX:+DoEscapeAnalysis</code>设置来打开逃逸分析的优化技术。但是由于基于逃逸分析开销会有一些，而这些未必能抵住获得的性能，所以需要仔细测试是否需要打开该项优化。</p>
  </blockquote>
</blockquote>

<h4 id="tlab-分配区">TLAB 分配区</h4>

<p>在创建新的对象而申请内存的时候，则需要去堆上获取内存空间，在多线程的情况下，则需要进行同步锁操作，进而影响分配效率，因此，JVM在内存新生代<code class="highlighter-rouge">Eden Space</code>中开辟了一小块线程私有的区域，称作TLAB。默认设定为占用Eden Space的1%。</p>

<p>在Java程序中很多对象都是小对象且用完之后就需要回收，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。</p>

<blockquote>
  <blockquote>
    <p>TLAB是针对线程的小对象的，如果需要分配的对象过大，还是需要在堆上进行分配。<code class="highlighter-rouge">-XX:TLABWasteTargetPercent</code>来设置TLAB占用Eden区的比例。</p>
  </blockquote>
</blockquote>

<h4 id="堆空间分配">堆空间分配</h4>

<p>如果优化全开，则JVM会先进行逃逸分析，如果未逃逸则在栈上进行分配；否则在TLAB是否有足够的空间分配，如果有，则在TLAB上分配空间；如果依然失败，则要在堆上进行分配了。</p>

<blockquote>
  <blockquote>
    <p>Notes：由于堆是所有线程共享的，所以分配时是需要加锁同步的。</p>
  </blockquote>
</blockquote>

<p>Oracle官方参考文档【<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html#t1s2">Java Garbage Collection Basics</a>】</p>

<p>首先，来看看JVM 堆空间详细的分代划分：</p>

<p><img src="/images/2016/05/jvm_heap.png" alt="image" /></p>

<blockquote>
  <blockquote>
    <p>一般，我们使用<code class="highlighter-rouge">-Xms</code>来设置JVM初始内存空间大小，<code class="highlighter-rouge">-Xmx</code>设计JVM最大内存空间大小，<code class="highlighter-rouge">-Xmn</code>来设置新生代的内存大小(推荐为整个堆的3/8)，<code class="highlighter-rouge">-Xss</code>来设置虚拟机栈的空间大小。默认，Eden区和Survivor区的内存空间比例为<code class="highlighter-rouge">8:1:1</code>，</p>
  </blockquote>
</blockquote>

<p>然后，看一个新对象是如何创建的：</p>

<ol>
  <li>
    <p>一个对象分配到Eden区，此时survivor区还是一个空内存。
<img src="/images/2016/05/allocate_1.png" alt="image" /></p>
  </li>
  <li>
    <p>然后，当Eden区逐渐增加，当Eden空间不足以分配新的内存申请操作的时候，就会触发minor GC。
<img src="/images/2016/05/allocate_2.png" alt="image" /></p>
  </li>
  <li>
    <p>在Eden中仍存活的对象，则copy到survivor0区中，没有存活的对象则被清除掉。
<img src="/images/2016/05/allocate_3.png" alt="image" /></p>
  </li>
  <li>
    <p>循环进行，当下一个minor GC发生的时候，不存活的对象被删除回收，存活的对象被copy到survivor1中。此外，上一次 minor GC被迁移到Survior0上的对象，存活的迁移到Survivor1上，并且对应的对象分代年龄上的value+1。因此，在S1上，就存在不同分代年龄的对象了。
<img src="/images/2016/05/allocate_4.png" alt="image" /></p>
  </li>
  <li>
    <p>在下一次minor GC中，依然重复上面的动作，将Eden区和S1区的仍然存活的对象copy到S0上，并且对应对象的分代年龄+1。
<img src="/images/2016/05/allocate_5.png" alt="image" /></p>
  </li>
  <li>
    <p>在minor GC 之后，如果存在对象的分代年龄超过设置的<code class="highlighter-rouge">-XX:MaxTenuringThreshold</code>值时，则copy到年老代Tenured区。
<img src="/images/2016/05/allocate_6.png" alt="image" /></p>
  </li>
  <li>
    <p>minor GC 继续，将会有越来越多的对象分配到Tenured区。
<img src="/images/2016/05/allocate_7.png" alt="image" /></p>
  </li>
  <li>
    <p>最后，随着Tenured区的对象越来越多，从而触发了major GC，改GC会将年老代的不用对象进行清除，然后压缩年老代内存空间。
<img src="/images/2016/05/allocate_8.png" alt="image" /></p>
  </li>
</ol>

<blockquote>
  <blockquote>
    <p>当需要分配的对象内存足够大时，则直接分配到Tenured区。Full GC和major GC 不一样，其GC时，包含minor GC 和 major GC。</p>
  </blockquote>
</blockquote>

<h3 id="内存回收">内存回收</h3>

<p>在介绍内存回收之前，需要对内存对象生命周期进行分析。IBM研究表明，绝大部分新生对象都是朝生夕死的，也就是一次GC之后就会把对应内存空间释放出来，最后存活下来的对象很少。如下图所示（显然绝大部分对象在第一次GC的时候就被回收掉了）：<br />
<img src="/images/2016/05/gc_mm.png" alt="image" /></p>

<p>上图还表明，不同的对象的生命周期不同，对不同的GC策略影响也是不同的。这种表现行为说明，需要对内存对象空间进行分类，因此，在HotSpot中，进行了分代：年轻代和年老代，简单来理解(不完全)：年轻代都是最近才分配内存空间的对象，而年老代则是在年轻代存活足够多的时间升级到年老代来的对象。它的分代内存空间可以参考上图(内存分配)。</p>

<p>常见的GC策略：</p>

<ul>
  <li>
    <p>标记-清除策略(Mark-Sweep)。</p>

    <p>标记-清除策略应该是垃圾回收策略里面最基础最容易想到的算法。其核心思想，就是将需要进行回收的对象进行标记，然后再将没有标记的内存对象进行回收销毁。因此，这个算法存在两个阶段，首先需要从GC Rootes开始根据前面介绍的可达性分析来遍历整个内存对象树，把遍历过得对象进行标记；然后，GC算法将所有未marked的对象delete掉。整个算法很容易明白，但是对于内存分配和回收策略来说，其存在二个比较大的问题：</p>
    <ul>
      <li>内存碎片化问题。对内存进行大量的标记清除操作之后，会导致整个内存区域存在大量不连续内存碎片，最后如果需要分配大内存对象时，很可能需要进入下一次GC操作，甚至会导致分配失败，但是实际上内存空间总量是很充足的。针对碎片化，一般采取的策略是压缩整理方式，即将对象的内存碎片压缩移动到一起，然后将所有区域外的内存全部delete掉即可。</li>
      <li>效率问题。标记-清除，需要首先标记整个内存空间，然后回收未被标记的对象。都是比较影响性能的操作。</li>
    </ul>
  </li>
  <li>
    <p>复制策略(Copying)。</p>

    <p>由于标记-清除策略效率不高，对于高并发实时服务来说，是很致命的。
根据内存生命周期的特点，我们将新生的对象放在一个新生代的Eden内存区域中，然后GC存活下来的对象复制到另一块小的内存区域S0/S1中。此外，新生代可能内存不足或者一些需要长期存活的对象，这些对象就需要分配移动到年老代的内存区域中。</p>

    <p>对于标记-清除两步骤的操作，复制策略由于采取的内存对象操作不同，导致其只需要一个步骤就能完成GC操作。在遍历GC Roots 对象树的时候，同时将标记到得对象复制到新生代小的S0/S1内存区域中，这样，当我们遍历完对象空间的时候，可以将整个新生代Eden区域内存分配的当前有效内存开始指针置为开始位置，这样，我们就操作完了对新生代对象的GC回收。</p>
  </li>
  <li>
    <p>标记-整理策略(Mark-Compact/Sweep)。</p>

    <p>复制策略效率非常高，但是其是针对新生代的对象特性而优化的，对于年老代的对象来说，其没有那么高的效率，此外主要的就是其浪费大量的内存空间用于复制GC下来的对象。因此，标记-清除策略对于老年代来说，比复制算法还是更好的，我们只需要解决内存碎片化问题即可。因此，这就是标记-整理算法了。</p>

    <p>也就是，我们在标记完整个内存区域的对象树之后，将存活下来的对象依次移动到内存的一端，然后将内存分配指针设置为存活对象的最后，从而完成内存的清理。</p>
  </li>
</ul>

<h2 id="jdk-gc-算法"><a id="GC_Algorithm">JDK GC 算法</a></h2>

<p>HotSpot VM 对外提供的垃圾回收：</p>

<p><img src="/images/2016/05/gc.png" alt="image" /></p>

<h3 id="年轻代三大gc">年轻代三大GC</h3>

<p>如上图所示，对于年轻代的垃圾回收主要有三种：Serial GC，ParNew GC，ParallelScavenge(PS)。</p>

<h4 id="串行serial-gc">串行Serial GC</h4>

<p>单线程垃圾回收。单线程串行的，所以在进行垃圾回收的时候，需要所有的应用线程都暂停(<code class="highlighter-rouge">Stop The World</code>)。全局单线程执行垃圾回收，会得到最好的单线程收集效率，因此对于client来说，其实默认的垃圾回收策略。</p>

<h4 id="parnew-gc">ParNew GC</h4>

<p>顾名思义，就是Serial GC的多线程版本，同样也是<code class="highlighter-rouge">Stop The World</code>。由于ParNew GC 是目前唯一一个可以专注于老年代GC收集器CMS 配合的并行年轻代GC收集器，CMS优秀的GC性能，导致ParNew GC 被很多server应用采用。</p>

<blockquote>
  <blockquote>
    <p>并发和并行收集器：并发指应用工作线程和GC线程可以同时执行，分别在不同地CPU上；并行指的是多个GC线程同时工作，此时的工作线程是STOP的状态。</p>
  </blockquote>
</blockquote>

<h4 id="parallel-scavenge-吞吐量gc">Parallel Scavenge (吞吐量GC)</h4>

<p>ParallelSvavenge 收集器也是采用复制算法的多线程年轻代收集器。和ParNew GC不同的是，其关注点在可控吞吐量上，而后者则重视的是GC时间。因此，ParNew收集器适用于用户交互场景，而PS则适用于CPU计算而少交互的场景。吞吐量指CPU用于运行用户代码的时间和CPU总运行时间的比例，即吞吐量=用户代码运行时间/(用户代码运行时间+GC时间)。</p>

<blockquote>
  <blockquote>
    <p>ParallelScavenge和ParNew都是并行GC，主要是并行收集年轻代，目的和性能其实都差不多。</p>

    <p>最明显的区别有下面几点：</p>
    <ol>
      <li>
        <p>在JDK6u18之后，PS只用深度优先遍历。ParNew则是一直都只用广度优先顺序来遍历。</p>
      </li>
      <li>PS完整实现了自适应大小策略，而ParNew内则没有实现完。所以千万别在用<code class="highlighter-rouge">ParNew + CMS</code>的组合下用UseAdaptiveSizePolicy，请只在使用UseParallelGC或UseParallelOldGC的时候用它。</li>
      <li>由于在”分代式GC框架”内，ParNew可以跟CMS搭配使用，而ParallelScavenge不能。当时ParNew GC被从Exact VM移植到HotSpot VM的最大原因就是为了跟CMS搭配使用。</li>
    </ol>
  </blockquote>
</blockquote>

<h3 id="年老代三代gc">年老代三代GC</h3>

<p>如上图所示，对于年轻代的垃圾回收主要有三种：Serial Old，Parallel Old，Concurrent Mark Sweep(CMS)。</p>

<h4 id="串行serial-old">串行Serial Old</h4>

<p>老年代单线程收集器，使用标记整理策略。Serial Old的标记-整理策略是先标记存活对象，然后先清理掉需要回收的对象，然后将存活的对象进行移动，保证一部分都是存活对象，一部分是空闲的内存空间。和SerialGC 一样，都需要暂停所有工作线程。</p>

<blockquote>
  <blockquote>
    <p>client模式下默认的Old GC。在Server模式下，当CMS GC时出现<code class="highlighter-rouge">Concurrent Mode Failure</code>，则回退使用Serial Old 收集器。</p>
  </blockquote>
</blockquote>

<h4 id="parallel-old">Parallel Old</h4>

<p>Parallel Old 是多线程并行的老年代GC收集器，其主要是配合年轻代PS收集器的老年代版本。</p>

<blockquote>
  <blockquote>
    <p>和Serial Old不同的整理策略，其首先汇总存活的对象复制到一个区域，然后压缩起来，而不是直接清除再压缩（为什么不直接将存活的对象移动到一侧呢？）。</p>
  </blockquote>
</blockquote>

<p><em>以上所有的收集器在执行GC的整个过程中都需要Stop The World，即不允许工作线程在GC的时候运行。</em></p>

<h4 id="cms">CMS</h4>

<blockquote>
  <blockquote>
    <p>遇到的绝大部分server一般都是采用ParNew + CMS 收集器策略。</p>
  </blockquote>
</blockquote>

<p>CMS收集器目标是获取最短停顿时间的收集器，所以和上面的收集器不同，虽然其也会<code class="highlighter-rouge">Stop The World</code>，但是在有些阶段是可以并发进行的。因此，特别适合用户交互场景的服务系统。</p>

<p>CMS 主要分为4个阶段：</p>

<ul>
  <li>初始化标记(STW)：标记GC Roots可以直接关联到的对象，速度非常快。</li>
  <li>并发标记：进行GC Roots Tracing的过程。</li>
  <li>重新标记(STW)：修正在并发标记期间工作线程操作导致变更的部分对象的标记记录。</li>
  <li>并发清除。</li>
</ul>

<p>上面四个步骤中，1和3是需要暂停工作线程的。</p>

<p>由于在实际中，应用特别多，所以这里具体分析下CMS收集器。</p>

<p>【<a href="http://www.cnblogs.com/zhguang/p/3257367.html">Java系列笔记(3) - Java 内存区域和GC机制</a>】</p>

<p>CMS收集的执行过程是：初始标记(CMS-initial-mark) -&gt; 并发标记(CMS-concurrent-mark) –&gt;预清理(CMS-concurrent-preclean)–&gt;可控预清理(CMS-concurrent-abortable-preclean)-&gt; 重新标记(CMS-remark) -&gt; 并发清除(CMS-concurrent-sweep) -&gt;并发重设状态等待下次CMS的触发(CMS-concurrent-reset)
具体的说，先2次标记，1次预清理，1次重新标记，再1次清除。</p>

<ol>
  <li>首先jvm根据-XX:CMSInitiatingOccupancyFraction，-XX:+UseCMSInitiatingOccupancyOnly来决定什么时间开始垃圾收集；</li>
  <li>如果设置了-XX:+UseCMSInitiatingOccupancyOnly，那么只有当old代占用确实达到了-XX:CMSInitiatingOccupancyFraction参数所设定的比例时才会触发cms gc；</li>
  <li>如果没有设置-XX:+UseCMSInitiatingOccupancyOnly，那么系统会根据统计数据自行决定什么时候触发cms gc；因此有时会遇到设置了80%比例才cms gc，但是50%时就已经触发了，就是因为这个参数没有设置的原因；</li>
  <li>当cms gc开始时，首先的阶段是初始标记(CMS-initial-mark)，是stop the world阶段，因此此阶段标记的对象只是从root集最直接可达的对象；
  CMS-initial-mark：961330K（1572864K），指标记时，old代的已用空间和总空间</li>
  <li>下一个阶段是并发标记(CMS-concurrent-mark)，此阶段是和应用线程并发执行的，所谓并发收集器指的就是这个，主要作用是标记可达的对象，此阶段不需要用户停顿。
    此阶段会打印2条日志：CMS-concurrent-mark-start，CMS-concurrent-mark</li>
  <li>下一个阶段是CMS-concurrent-preclean，此阶段主要是进行一些预清理，因为标记和应用线程是并发执行的，因此会有些对象的状态在标记后会改变，此阶段正是解决这个问题因为之后的Rescan阶段也会stop the world，为了使暂停的时间尽可能的小，也需要preclean阶段先做一部分工作以节省时间
  此阶段会打印2条日志：CMS-concurrent-preclean-start，CMS-concurrent-preclean</li>
  <li>下一阶段是CMS-concurrent-abortable-preclean阶段，加入此阶段的目的是使cms gc更加可控一些，作用也是执行一些预清理，以减少Rescan阶段造成应用暂停的时间
  此阶段涉及几个参数：
  -XX:CMSMaxAbortablePrecleanTime：当abortable-preclean阶段执行达到这个时间时才会结束
  -XX:CMSScheduleRemarkEdenSizeThreshold（默认2m）：控制abortable-preclean阶段什么时候开始执行，
   即当eden使用达到此值时，才会开始abortable-preclean阶段
  -XX:CMSScheduleRemarkEdenPenetratio（默认50%）：控制abortable-preclean阶段什么时候结束执行
   此阶段会打印一些日志如下：
  CMS-concurrent-abortable-preclean-start，CMS-concurrent-abortable-preclean，
   CMS：abort preclean due to time XXX</li>
  <li>再下一个阶段是第二个stop the world阶段了，即Rescan阶段，此阶段暂停应用线程，停顿时间比并发标记小得多，但比初始标记稍长。对对象进行重新扫描并标记；
    YG occupancy：964861K（2403008K），指执行时young代的情况
    CMS remark：961330K（1572864K），指执行时old代的情况
   此外，还打印出了弱引用处理、类卸载等过程的耗时</li>
  <li>再下一个阶段是CMS-concurrent-sweep，进行并发的垃圾清理</li>
  <li>最后是CMS-concurrent-reset，为下一次cms gc重置相关数据结构</li>
</ol>

<p>有2种情况会触发CMS 的悲观full gc，在悲观full gc时，整个应用会暂停
       A，concurrent-mode-failure：预清理阶段可能出现，当cms gc正进行时，此时有新的对象要进行old代，但是old代空间不足造成的。其可能性有：1，O区空间不足以让新生代晋级，2，O区空间用完之前，无法完成对无引用的对象的清理。这表明，当前有大量数据进入内存且无法释放。
       B，promotion-failed：新生代young gc可能出现，当进行young gc时，有部分young代对象仍然可用，但是S1或S2放不下，因此需要放到old代，但此时old代空间无法容纳此。</p>

<p>影响cms gc时长及触发的参数是以下2个：
        -XX:CMSMaxAbortablePrecleanTime=5000
        -XX:CMSInitiatingOccupancyFraction=80
解决也是针对这两个参数来的，根本的原因是每次请求消耗的内存量过大
解决方式：
      A，针对cms gc的触发阶段，调整-XX:CMSInitiatingOccupancyFraction=50，提早触发cms gc，就可以缓解当old代达到80%，cms gc处理不完，从而造成concurrent mode failure引发full gc
     B，修改-XX:CMSMaxAbortablePrecleanTime=500，缩小CMS-concurrent-abortable-preclean阶段的时间
     C，考虑到cms gc时不会进行compact，因此加入-XX:+UseCMSCompactAtFullCollection
       （cms gc后会进行内存的compact）和-XX:CMSFullGCsBeforeCompaction=4（在full gc4次后会进行compact）参数</p>

<p>在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。
CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。
另外，在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”，本次无法清理，只能下一次Full GC才清理，因此在GC期间，需要预留足够的内存给用户线程使用。所以使用CMS的收集器并不是老年代满了才触发Full GC，而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full GC，如果用户线程消耗内存不是特别大，可以适当调高-XX:CMSInitiatingOccupancyFraction以降低GC次数，提高性能，如果预留的用户线程内存不够，则会触发Concurrent Mode Failure，此时，将触发备用方案：使用Serial Old 收集器进行收集，但这样停顿时间就长了，因此-XX:CMSInitiatingOccupancyFraction不宜设的过大。
还有，CMS采用的是标记清除算法，会导致内存碎片的产生，可以使用-XX：+UseCMSCompactAtFullCollection来设置是否在Full GC之后进行碎片整理，用-XX：CMSFullGCsBeforeCompaction来设置在执行多少次不压缩的Full GC之后，来一次带压缩的Full GC。</p>


                </div>
                <div class="read-all">
                    <a  href="/2016/05/29/talk-about-java-gc/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2016/04/29/thrift-service-discory-using-zookeeper-ourea/">Ourea-基于Zookeeper的Thrift服务发现框架实现</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2016-04-29
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Java" title="Category: Java" rel="category">Java</a>&nbsp;
    
        <a href="/category/#Thrift" title="Category: Thrift" rel="category">Thrift</a>&nbsp;
    
        <a href="/category/#Zookeeper" title="Category: Zookeeper" rel="category">Zookeeper</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <h2 id="框架背景"><a id="Introduction">框架背景</a></h2>

<p>Apache Thrift是Facebook实现的一种高效的,支持多种编程语言的远程服务调用的框架.在多语言并行于业务之中的公司,其是一个很好的RPC框架选择,但是由于缺少服务发现管理功能,在使用的时候,需要告知业务方现有业务部署的地址,并且调用方需要自己实现服务状态的感知和重试机制.此外,对于互联网公司而言,业务快速变化必然导致机器的增减,这些变化,需要通知到所有调用方来更改调用机器的配置,是非常麻烦的.</p>

<p>显然，对于Thrift来说，一个服务发现管理框架是多么的重要。</p>

<p>那么，服务发现管理框架其实可以做的很重，也可以做的很轻；对于我们，需要满足什么需求：</p>

<ul>
  <li>服务调用方自动获取服务提供方地址；</li>
  <li>服务提供方服务分组；</li>
  <li>服务调用方负载均衡策略；</li>
  <li>服务非兼容升级；</li>
</ul>

<p>具体的需求分析和实现，将在 <a href="#Ourea_Implement">Ourea服务发现实现原理</a>介绍。</p>

<h2 id="thrift服务原生使用"><a id="Thrift_Native_Demo">Thrift服务原生使用</a></h2>

<p>Thrift 接口使用还是比较简单地，对外提供的server和client接口封装了所有的内部实现细节，所以，一般我们只需要告诉<code class="highlighter-rouge">Thrift</code>地址端口信息，然后就可以完成简单地RPC调用。</p>

<p>下面，给出一个简单地示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// 服务端示例</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleThriftServer</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">SimpleThriftServer</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">9999</span><span class="o">;</span>

    <span class="kd">public</span>  <span class="kt">void</span> <span class="nf">simple</span><span class="o">(</span><span class="kt">int</span> <span class="n">port</span><span class="o">){</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">TServerSocket</span> <span class="n">tServerSocket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TServerSocket</span><span class="o">(</span><span class="n">port</span><span class="o">);</span>
            <span class="n">Hello</span><span class="o">.</span><span class="na">Processor</span> <span class="n">processor</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Hello</span><span class="o">.</span><span class="na">Processor</span><span class="o">(</span><span class="k">new</span> <span class="n">HelloService</span><span class="o">());</span>

            <span class="n">TServer</span> <span class="n">server</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TSimpleServer</span><span class="o">(</span><span class="k">new</span> <span class="n">TServer</span><span class="o">.</span><span class="na">Args</span><span class="o">(</span><span class="n">tServerSocket</span><span class="o">).</span><span class="na">processor</span><span class="o">(</span><span class="n">processor</span><span class="o">)</span> <span class="o">);</span>
            <span class="n">server</span><span class="o">.</span><span class="na">serve</span><span class="o">();</span>

        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"server start error........"</span><span class="o">,</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="n">SimpleThriftServer</span> <span class="n">server</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleThriftServer</span><span class="o">();</span>
        <span class="n">server</span><span class="o">.</span><span class="na">simple</span><span class="o">(</span><span class="n">port</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// client 端示例</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleThriftClient</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">SimpleThriftClient</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">9999</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">ip</span> <span class="o">=</span> <span class="s">"127.0.0.1"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">TTransport</span> <span class="n">transport</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">transport</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TSocket</span><span class="o">(</span><span class="n">ip</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span>
            <span class="n">TProtocol</span> <span class="n">protocol</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TBinaryProtocol</span><span class="o">(</span><span class="n">transport</span><span class="o">);</span>
            <span class="n">Hello</span><span class="o">.</span><span class="na">Client</span> <span class="n">client</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Hello</span><span class="o">.</span><span class="na">Client</span><span class="o">(</span><span class="n">protocol</span><span class="o">);</span>
            <span class="n">transport</span><span class="o">.</span><span class="na">open</span><span class="o">();</span>
            <span class="n">HelloResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">sayHello</span><span class="o">(</span><span class="s">"hello world"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"client invoke fail. "</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">transport</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">transport</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>Note:</p>
    <ul>
      <li>TProtocol 协议和编解码组件</li>
      <li>TTransport 传输通信组件</li>
      <li>TProcessor 服务处理相关组件</li>
      <li>TServer 服务提供组件</li>
      <li>Client 服务调用客户端</li>
    </ul>
  </blockquote>
</blockquote>

<p>Thrift 原生的对外接口已经很简单了，但是为什么还需要去封装呢？上文的代码虽然简单，但是有几个点需要去注意：</p>

<ol>
  <li>对于生产环境的服务，在发布新功能，出现故障down机，都会导致服务出现不可用的情况；此外，对外的服务一般都是集群部署，集群机器的增减也是很可能会出现的事情，因此，就会出现最初对外提供的服务IP地址会出现新增(新建服务)，减少(缩减服务)，暂时停服(机器故障)，这些所有变更通知所有业务服务调用方去更改是很难处理的事情。此外，由于服务可能存在大量的机器列表，这些配置在业务代码中，本身也是不可取的。</li>
  <li>服务调用的时候，可能存在某些服务当时负载过高，或者服务网络问题等导致服务调用策略需要调整。也就是在选择调用集群中某台机器的时候，每个业务都要自己去实现策略，这是不可取的。此外，对于服务的负载情况无法感知，即使是静态的服务提供权重都无法获取，导致了即使客户端自己实现均衡策略，由于缺少必要的数据支持，导致只能采用轮询和随机。</li>
  <li>业务上，服务调用之间隔离，服务接口的灰度升级等，是比较常见的技术需求。Thrift 对外发布的服务的所有IP，对于调用方来说都是平等的，也就是，如果我需要将集群中某些机器进行接口的非兼容的灰度升级，或者某些机器独立出来给一些非常重要的业务使用。目前，这种场景，只能新加机器来解决了。</li>
  <li>对于调用方Client的调用，每次都需要去创建连接，然后和server端交互，对于大请求场景下的应用，对性能的影响是很大的。创建connection对象，是很重的，需要进行池化。</li>
  <li>……</li>
</ol>

<p>基于以上的一些原因，开发了基于<code class="highlighter-rouge">Zookeeper</code>的Thrift服务发现机制框架。</p>

<!-- more -->

<h2 id="-ourea服务发现实现原理"><a id="Ourea_Implement"> Ourea服务发现实现原理</a></h2>

<p>服务发现机制，在很多RPC套件中都会提供。<code class="highlighter-rouge">Zookeeper</code>一直作为经典实现服务发现机制的底层服务，所以这里显然也是这样的。下面给出，实现的模块交互图：</p>

<p><img src="/images/2016/04/ourea.png" /></p>

<h3 id="交互说明">交互说明</h3>

<p>在设计交互图中，<code class="highlighter-rouge">Server</code>服务提供方会在启动的时候，读取服务相关配置属性，比如版本号、组名等信息，以及注册<code class="highlighter-rouge">Zookeeper</code>地址及相关zk操作配置信息；然后根据配置去指定<code class="highlighter-rouge">Zookeeper</code>集群注册服务，其路径为<code class="highlighter-rouge">/ourea/service_name_xxx/group_yyy/version_zzz/provider/ip=mmm&amp;port=nnn&amp;weight=lll</code>,注册完成之后，就可以启动Thrift服务了；如果发现服务启动失败，则去<code class="highlighter-rouge">Zookeeper</code>上注销该路径节点。</p>

<p>服务调用方启动的时候，同样也会读取相关配置，然后去<code class="highlighter-rouge">Zookeeper</code>上注册服务调用信息，注册完了之后，服务调用方会去查询<code class="highlighter-rouge">/ourea/service_name_xxx/group_yyy/version_zzz/provider/</code>下地子节点列表，并且注册监听逻辑，等待子节点变更则触发重新查询操作。服务调用方拿到ip列表之后，就可以按照选择的选择策略来拿到指定服务器的连接去调用相关服务接口。</p>

<p>需要说明的是，由于服务调用方拿到服务提供方的地址列表后，其只会监听<code class="highlighter-rouge">Zookeeper</code>的变更通知，调用方是直接和服务方交互的，因此，当<code class="highlighter-rouge">Zookeeper</code>出现不可服务时，并不会影响Thrift的服务提供和调用交互。因此，也不会影响Thrift的性能。</p>

<h3 id="针对thrift原生接口的解决方案">针对Thrift原生接口的解决方案</h3>

<ol>
  <li>
    <p>服务扩张自动感知
当服务提供方的服务状态发生变更，比如新加机器扩展，或者服务发布上下线等，会自动在指定路径创建一个临时节点，节点包含机器相关信息，利用<code class="highlighter-rouge">Zookeeper</code>的临时节点特性来实现服务状态自动感知功能。</p>
  </li>
  <li>
    <p>服务调用负载策略
目前，ourea 也只支持方法级轮询策略和权重随机分布策略。服务会记录某个方法上次调用情况，然后从服务list中找出这次选择的机器进行服务调用。权重随机分布，是根据服务提供方在服务启动的时候，配置的机器权重来计算，权重大的服务机器，被选择的几率大于权重小的服务提供者。</p>
  </li>
  <li>
    <p>服务提供粒度细化 
服务隔离保证重要业务调用方不被其他业务干扰；此外，由于前期设计的问题，需要对部分接口进行非兼容升级(虽然我们非常不提倡这种行为)，这些问题都需要对服务提供进行细化隔离。因此，在ourea中，增加了<code class="highlighter-rouge">group</code>和<code class="highlighter-rouge">version</code>的控制。在server端，初始都是为默认的group提供服务，当存在某个重要的业务需要抗干扰服务级别时，下面一些机器，配置为特定group给改业务调用，这时，其他业务是无法自动获取到这些服务提供者地址的，从而到达服务隔离的目的。</p>
  </li>
  <li>
    <p>Thrift连接池化
java client端，会对获取到得服务提供者地址列表分别创建对应的socket连接池，保证经过策略选择到指定机器后，可以直接和服务端交互。</p>
  </li>
</ol>

<h2 id="-ourea服务发现框架使用示例"><a id="Ourea_Demo"> Ourea服务发现框架使用示例</a></h2>

<p>使用ourea框架非常简单，生成jar包，引入到项目，然后如下调用方法即可完成Thrift交互。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ZkThriftServerSample</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Ourea</span><span class="o">.</span><span class="na">Processor</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getCanonicalName</span><span class="o">());</span>

        <span class="n">Properties</span> <span class="n">properties</span> <span class="o">=</span> <span class="n">PropertiesUtils</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="s">"provider.properties"</span><span class="o">);</span>

        <span class="n">ThriftServerConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThriftServerConfig</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">properties</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"port"</span><span class="o">)));</span>
        <span class="n">config</span><span class="o">.</span><span class="na">setGroup</span><span class="o">(</span><span class="n">properties</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"group"</span><span class="o">));</span>
        <span class="n">ServiceProviderFactory</span><span class="o">.</span><span class="na">exposeService</span><span class="o">(</span><span class="k">new</span> <span class="n">OureaImpl</span><span class="o">(),</span> <span class="k">new</span> <span class="n">ZkConfig</span><span class="o">(</span><span class="n">properties</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"zkAddress"</span><span class="o">)),</span>
                <span class="n">config</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ZkThriftClientSample</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

    <span class="n">Properties</span> <span class="n">properties</span> <span class="o">=</span> <span class="n">PropertiesUtils</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="s">"consumer.properties"</span><span class="o">);</span>

    <span class="n">Ourea</span><span class="o">.</span><span class="na">Iface</span> <span class="n">client</span> <span class="o">=</span> <span class="n">ConsumerProxyFactory</span><span class="o">.</span><span class="na">getProxyClient</span><span class="o">(</span><span class="n">Ourea</span><span class="o">.</span><span class="na">Iface</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
        <span class="k">new</span> <span class="nf">ZkConfig</span><span class="o">(</span><span class="n">properties</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"zkAddress"</span><span class="o">)));</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">++</span> <span class="o">&lt;</span><span class="mi">1000</span><span class="o">){</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">count</span> <span class="o">+</span> <span class="s">"-----"</span> <span class="o">+</span> <span class="n">client</span><span class="o">.</span><span class="na">queryEcho</span><span class="o">(</span><span class="s">"hello"</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">-</span> <span class="n">start</span><span class="o">);</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>服务最少配置如下：</p>

<div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#zookeeper注册地址
</span><span class="py">zkAddress</span><span class="p">=</span><span class="s">10.10.33.134:2181</span>
<span class="c">#zookeeper超时时间
</span><span class="py">zkTimeout</span><span class="p">=</span><span class="s">3000</span>
</code></pre></div></div>

<div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#对外提供服务端口号
</span><span class="py">port</span><span class="p">=</span><span class="s">9999</span>
<span class="c">#zookeeper注册地址
</span><span class="py">zkAddress</span><span class="p">=</span><span class="s">10.10.33.134:2181</span>
<span class="c">#zookeeper超时时间
</span><span class="py">zkTimeout</span><span class="p">=</span><span class="s">3000</span>
<span class="c">#服务细分的组/topic
</span><span class="py">group</span><span class="p">=</span><span class="s">bbb</span>
</code></pre></div></div>

<h2 id="-总结"><a id="Summary"> 总结</a></h2>

<p>项目源码开源地址：https://github.com/ketao1989/ourea</p>


                </div>
                <div class="read-all">
                    <a  href="/2016/04/29/thrift-service-discory-using-zookeeper-ourea/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2016/03/10/junit-mockito-guice-in-action-and-junit-test-mechanism/">基于JUnit Mockito Guice测试实践及JUnit运行机制浅析</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2016-03-10
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#JUnit" title="Category: JUnit" rel="category">JUnit</a>&nbsp;
    
        <a href="/category/#Guice" title="Category: Guice" rel="category">Guice</a>&nbsp;
    
        <a href="/category/#Java" title="Category: Java" rel="category">Java</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <h2 id="前言"><a id="Introduction">前言</a></h2>

<p>对于一个合格的项目来说,单元测试是必不可少的一部分。尤其是，如果对于TDD思想来说，单元测试则是整个项目开发的基石。对于Javaer来说,Junit 是一个基础的单元测试框架.对于Spring框架来说, 其实现了JUnit的接口来直接支持单元测试, 但是对于Guice来说, 其定位为一个轻量级的依赖注入框架, 所以这些就需要自己来实现. 此外, 对于依赖外部的接口服务的应用, 我们在测试的时候, 是不希望其服务的不稳定导致我们单测失败; 此外, 对外部接口进行屏蔽, 也可以达到对每一个外部服务返回逻辑分支的覆盖.</p>

<p>因此，本文基于<code class="highlighter-rouge">JUnit + Mockito + Guice</code>框架说，然后基于简单地实例来说明JUnit的运行机制。</p>

<h2 id="-单元测试实践"><a id="Action"> 单元测试实践</a></h2>

<p>Guice 作为一个注入框架，和Spring相比，并没有什么特别的。使用Guice介绍单元测试，其一是项目开发中使用Guice，其二由于我们需要去自己实现JUnit接口来支持Guice，能够更深入地了解JUnit结构。Mockito 是java中我比较喜欢的mock工具，当然，我也没有用过其他的。O(∩_∩)O~</p>

<p>首先，需要引入两个实现：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/**
 * @author tao.ke Date: 16/3/9 Time: 下午4:24
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GuiceJUnitRunner</span> <span class="kd">extends</span> <span class="n">BlockJUnit4ClassRunner</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">Injector</span> <span class="n">injector</span><span class="o">;</span>

    <span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
    <span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
    <span class="nd">@Inherited</span>
    <span class="kd">public</span> <span class="nd">@interface</span> <span class="n">GuiceModules</span> <span class="o">{</span>
        <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">value</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">createTest</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">createTest</span><span class="o">();</span>
        <span class="n">injector</span><span class="o">.</span><span class="na">injectMembers</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">GuiceJUnitRunner</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">klass</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InitializationError</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">klass</span><span class="o">);</span>
        <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">classes</span> <span class="o">=</span> <span class="n">getModulesFor</span><span class="o">(</span><span class="n">klass</span><span class="o">);</span>
        <span class="n">injector</span> <span class="o">=</span> <span class="n">createInjectorFor</span><span class="o">(</span><span class="n">classes</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">Injector</span> <span class="nf">createInjectorFor</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">classes</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InitializationError</span> <span class="o">{</span>
        <span class="n">Module</span><span class="o">[]</span> <span class="n">modules</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Module</span><span class="o">[</span><span class="n">classes</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">classes</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">modules</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">Module</span><span class="o">)</span> <span class="o">(</span><span class="n">classes</span><span class="o">[</span><span class="n">i</span><span class="o">]).</span><span class="na">newInstance</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InstantiationException</span> <span class="o">|</span> <span class="n">IllegalAccessException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">InitializationError</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">Guice</span><span class="o">.</span><span class="na">createInjector</span><span class="o">(</span><span class="n">modules</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">getModulesFor</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">klass</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InitializationError</span> <span class="o">{</span>
        <span class="n">GuiceModules</span> <span class="n">annotation</span> <span class="o">=</span> <span class="n">klass</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">GuiceModules</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">annotation</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">Class</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">annotation</span><span class="o">.</span><span class="na">value</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>GuiceJUnitRunner 实现了JUnit框架<code class="highlighter-rouge">BlockJUnit4ClassRunner</code>接口，Runner是JUnit的核心，所有测试的运行，最后都是Runner来衔接运作起来的。在<code class="highlighter-rouge">JuiceJUnitRunner</code>中，我们根据annotation来初始化Guice环境需要的一些初始化配置，拦截器等；此外，熟悉Guice的同学知道，其有一个非常不好的体验，就是需要在最外层手动注入实例调用服务，这里我们希望可以直接注入service实例，因此在Runner初始化时完成这一动作。</p>

<!-- more -->

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/**
 * @author tao.ke Date: 16/3/9 Time: 下午4:30
 */</span>
<span class="nd">@RunWith</span><span class="o">(</span><span class="n">GuiceJUnitRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@GuiceJUnitRunner</span><span class="o">.</span><span class="na">GuiceModules</span><span class="o">({</span> <span class="n">GuiceModule</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BaseTest</span> <span class="o">{</span>

    <span class="nd">@Before</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">MockitoAnnotations</span><span class="o">.</span><span class="na">initMocks</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 全局初始化，加载数据库配置，注入拦截器等</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GuiceModule</span> <span class="kd">implements</span> <span class="n">Module</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">configure</span><span class="o">(</span><span class="n">Binder</span> <span class="n">binder</span><span class="o">)</span> <span class="o">{</span>

       <span class="c1">//binder.bind(GuiceBiz.class);</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">BaseTest</code>是一个基础的测试类，完成所有测试共同的工作。各个测试类可以继承该基类，然后就可以最简单的关注业务逻辑的测试。比如，下面这个测试类：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GuiceUnitSampleTest</span> <span class="kd">extends</span> <span class="n">BaseTest</span> <span class="o">{</span>

    <span class="nd">@Inject</span>
    <span class="kd">private</span> <span class="n">GuiceBiz</span> <span class="n">guiceBiz</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testConcatString</span><span class="o">(){</span>
        <span class="c1">//就是一个简单地测试而已</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">guiceBiz</span><span class="o">.</span><span class="na">concatString</span><span class="o">(</span><span class="s">"ktcoder"</span><span class="o">,</span><span class="s">"hello,"</span><span class="o">));</span>
        <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="s">"hello,ktcoder"</span><span class="o">,</span><span class="n">guiceBiz</span><span class="o">.</span><span class="na">concatString</span><span class="o">(</span><span class="s">"ktcoder"</span><span class="o">,</span><span class="s">"hello,"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>接下来，来一个复杂的测试case，这里，我们调用的外部的服务，比如数据库查询，或者其他RPC服务等等，但是我们只想测试自己的业务分支是否运行正常。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GuiceUnitMockSampleTest</span> <span class="kd">extends</span> <span class="n">BaseTest</span><span class="o">{</span>

    <span class="nd">@InjectMocks</span>
    <span class="nd">@Inject</span>
    <span class="kd">private</span> <span class="n">GuiceBiz</span> <span class="n">guiceBiz</span><span class="o">;</span>

    <span class="nd">@Mock</span>
    <span class="kd">private</span> <span class="n">GuiceServiceImpl</span> <span class="n">guiceServiceImpl</span><span class="o">;</span>


    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetRoleAdmin</span><span class="o">(){</span>

        <span class="n">Mockito</span><span class="o">.</span><span class="na">when</span><span class="o">(</span><span class="n">guiceServiceImpl</span><span class="o">.</span><span class="na">getRole</span><span class="o">(</span><span class="n">Matchers</span><span class="o">.</span><span class="na">anyString</span><span class="o">())).</span><span class="na">thenReturn</span><span class="o">(</span><span class="s">"admin"</span><span class="o">);</span>

        <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="s">"hello Admin"</span><span class="o">,</span><span class="n">guiceBiz</span><span class="o">.</span><span class="na">helloRole</span><span class="o">(</span><span class="s">"test"</span><span class="o">));</span>

    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetRoleGuest</span><span class="o">(){</span>

        <span class="n">Mockito</span><span class="o">.</span><span class="na">when</span><span class="o">(</span><span class="n">guiceServiceImpl</span><span class="o">.</span><span class="na">getRole</span><span class="o">(</span><span class="n">Matchers</span><span class="o">.</span><span class="na">anyString</span><span class="o">())).</span><span class="na">thenReturn</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>

        <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="s">"hello Guest"</span><span class="o">,</span><span class="n">guiceBiz</span><span class="o">.</span><span class="na">helloRole</span><span class="o">(</span><span class="s">"test"</span><span class="o">));</span>

    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GuiceBiz</span> <span class="o">{</span>

    <span class="nd">@Inject</span>
    <span class="kd">private</span> <span class="n">GuiceServiceImpl</span> <span class="n">guiceServiceImpl</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">helloRole</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">){</span>

        <span class="n">String</span> <span class="n">res</span> <span class="o">=</span> <span class="n">guiceServiceImpl</span><span class="o">.</span><span class="na">getRole</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">StringUtils</span><span class="o">.</span><span class="na">isBlank</span><span class="o">(</span><span class="n">res</span><span class="o">)){</span>
            <span class="k">return</span> <span class="s">"hello "</span> <span class="o">+</span> <span class="s">"Guest"</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="s">"hello "</span> <span class="o">+</span> <span class="s">"Admin"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>从上面的case可以看到，不管外部的GuiceServiceImpl是如何处理的，是否服务可靠都无所谓。我们只需要关注自己的业务逻辑，然后mock掉外部的接口，这样就可以更好地覆盖各个逻辑分支了。</p>

<h2 id="-junit-运行浅析"><a id="Flow"> JUnit 运行浅析</a></h2>

<p>一般在开发的时候，我们都使用idea 或者 eclipse 来运行测试用例，那么对于可运行的java代码，必然有一个main方法入口。</p>

<h3 id="idea-junit-主方法入口">idea JUnit 主方法入口</h3>

<p>在 idea 中存在一个<code class="highlighter-rouge">JUnitStarter</code>类，该类就有一个main方法，也就是说，当我们在idea ide工具中点击执行test方法时，实际上执行的就是这个类的入口方法。</p>

<p>main 方法很简单，就是准备输入输出流，一些参数准备，然后调用<code class="highlighter-rouge">prepareStreamsAndStart</code> 方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">prepareStreamsAndStart</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">isJUnit4</span><span class="o">,</span> <span class="n">ArrayList</span> <span class="n">listeners</span><span class="o">,</span> <span class="n">SegmentedOutputStream</span> <span class="n">out</span><span class="o">,</span> <span class="n">SegmentedOutputStream</span> <span class="n">err</span><span class="o">)</span> <span class="o">{</span>

    <span class="n">PrintStream</span> <span class="n">oldOut</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">;</span>
    <span class="n">PrintStream</span> <span class="n">oldErr</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">setOut</span><span class="o">(</span><span class="k">new</span> <span class="n">PrintStream</span><span class="o">(</span><span class="n">out</span><span class="o">));</span>
      <span class="n">System</span><span class="o">.</span><span class="na">setErr</span><span class="o">(</span><span class="k">new</span> <span class="n">PrintStream</span><span class="o">(</span><span class="n">err</span><span class="o">));</span>
      <span class="n">IdeaTestRunner</span> <span class="n">testRunner</span> <span class="o">=</span> <span class="o">(</span><span class="n">IdeaTestRunner</span><span class="o">)</span><span class="n">getAgentClass</span><span class="o">(</span><span class="n">isJUnit4</span><span class="o">).</span><span class="na">newInstance</span><span class="o">();</span>
      <span class="n">testRunner</span><span class="o">.</span><span class="na">setStreams</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">err</span><span class="o">);</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">testRunner</span><span class="o">.</span><span class="na">startRunnerWithArgs</span><span class="o">(</span><span class="n">args</span><span class="o">,</span> <span class="n">listeners</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// ......</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="o">}</span>

</code></pre></div></div>

<p>因为我们使用的是JUnit4，所以会接着调用 <code class="highlighter-rouge">JUnit4IdeaTestRunner</code>类，在这个类中将直接和JUnit的相关接口交互，调用相关方法，进入到具体的JUnit测试中。该类首先构造JUnit工具中需要的Request类，通过Request可以获取Runner实例，然后开始运行测试case。
比如我们这里需要运行的时Test类中得一个方法，所以这里列出对应的处理逻辑代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// suiteClassNames[0]="io.github.ketao1989.guice.GuiceUnitSampleTest,testConcatString"</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="n">Request</span> <span class="nf">buildRequest</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">suiteClassNames</span><span class="o">,</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">notForked</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">suiteClassNames</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">Vector</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">suiteClassNames</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">suiteClassName</span> <span class="o">=</span> <span class="n">suiteClassNames</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">suiteClassName</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="sc">','</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">loadTestClass</span><span class="o">(</span><span class="n">suiteClassName</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">index</span><span class="o">));</span>
            <span class="kd">final</span> <span class="n">String</span> <span class="n">methodName</span> <span class="o">=</span> <span class="n">suiteClassName</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="kd">final</span> <span class="n">RunWith</span> <span class="n">clazzAnnotation</span> <span class="o">=</span> <span class="o">(</span><span class="n">RunWith</span><span class="o">)</span><span class="n">clazz</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">RunWith</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="kd">final</span> <span class="n">Description</span> <span class="n">testMethodDescription</span> <span class="o">=</span> <span class="n">Description</span><span class="o">.</span><span class="na">createTestDescription</span><span class="o">(</span><span class="n">clazz</span><span class="o">,</span> <span class="n">methodName</span><span class="o">);</span>
            <span class="kd">final</span> <span class="n">Request</span> <span class="n">request</span> <span class="o">=</span> <span class="n">getParameterizedRequest</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">methodName</span><span class="o">,</span> <span class="n">clazz</span><span class="o">,</span> <span class="n">clazzAnnotation</span><span class="o">);/</span><span class="err">反射构造</span><span class="n">runner</span><span class="err">及</span><span class="n">request</span>
            <span class="nf">if</span> <span class="o">(</span><span class="n">request</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">request</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>构造完了Request，然后就可以通过new 一个 JUnitCore对象来运行request中得runner了。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">private</span> <span class="n">Result</span> <span class="nf">startRunnerWithArgs</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">,</span> <span class="n">ArrayList</span> <span class="n">listeners</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">sendTree</span><span class="o">){</span>

    <span class="kd">final</span> <span class="n">Request</span> <span class="n">request</span> <span class="o">=</span> <span class="n">JUnit4TestRunnerUtil</span><span class="o">.</span><span class="na">buildRequest</span><span class="o">(</span><span class="n">args</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">sendTree</span><span class="o">);</span>
    <span class="kd">final</span> <span class="n">Runner</span> <span class="n">testRunner</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getRunner</span><span class="o">();</span>
    <span class="n">Description</span> <span class="n">description</span> <span class="o">=</span> <span class="n">getDescription</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">testRunner</span><span class="o">);</span>
    <span class="c1">//.......</span>
    <span class="kd">final</span> <span class="n">JUnitCore</span> <span class="n">runner</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JUnitCore</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">runner</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">testRunner</span><span class="o">);</span>

<span class="o">}</span>

</code></pre></div></div>

<p>在上面的<code class="highlighter-rouge">startRunnerWithArgs</code>方法中会设置一些监听器负责收集运行成功失败的结果，开始结束运行等，为了了解整个运行流程，就不分析了。</p>

<h3 id="request-构建-runner">Request 构建 Runner</h3>

<p>从上面的代码中看到，idea 是通过buildRequest来获取 Runner的。实际上，Request 就是一个RunnerBuilder构建工具，默认有三种实现：<code class="highlighter-rouge">FilterRequest</code>、<code class="highlighter-rouge">ClassRequest</code>和<code class="highlighter-rouge">SortingRequest</code>，顾名思义了，核心自然是 ClassRequest。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClassRequest</span> <span class="kd">extends</span> <span class="n">Request</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Object</span> <span class="n">runnerLock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">fTestClass</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">canUseSuiteMethod</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="n">Runner</span> <span class="n">runner</span><span class="o">;</span>
    <span class="c1">// ......</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Runner</span> <span class="nf">getRunner</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">runner</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">runnerLock</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">runner</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">runner</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AllDefaultPossibilitiesBuilder</span><span class="o">(</span><span class="n">canUseSuiteMethod</span><span class="o">).</span><span class="na">safeRunnerForClass</span><span class="o">(</span><span class="n">fTestClass</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">runner</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>从<code class="highlighter-rouge">getRunner</code>方法中可以知道这里根据需要测试的类 fTestClass 来构造runner.</p>

<blockquote>
  <blockquote>
    <p>Notes:这里使用fTestClass明明变量，竟然是因为在idea的调用代码中使用<code class="highlighter-rouge">field = ClassRequest.class.getDeclaredField("fTestClass");</code>,所以无法更改成正常的testClass.</p>
  </blockquote>
</blockquote>

<p>AllDefaultPossibilitiesBuilder类是一个builder的总入口，其会根据配置选择正确的RunnerBuilder构建Runner对象：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AllDefaultPossibilitiesBuilder</span> <span class="kd">extends</span> <span class="n">RunnerBuilder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">canUseSuiteMethod</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AllDefaultPossibilitiesBuilder</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">canUseSuiteMethod</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">canUseSuiteMethod</span> <span class="o">=</span> <span class="n">canUseSuiteMethod</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 从这个方法可以看出构造器的优先级，构造器会一个一个尝试，直到找到正确地为止，一般使用注解方式指定Runner</span>
    <span class="c1">// 所以这里介绍annotatedBuilder.</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Runner</span> <span class="nf">runnerForClass</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">testClass</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">RunnerBuilder</span><span class="o">&gt;</span> <span class="n">builders</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
                <span class="n">ignoredBuilder</span><span class="o">(),</span>
                <span class="n">annotatedBuilder</span><span class="o">(),</span>
                <span class="n">suiteMethodBuilder</span><span class="o">(),</span>
                <span class="n">junit3Builder</span><span class="o">(),</span>
                <span class="n">junit4Builder</span><span class="o">());</span>

        <span class="k">for</span> <span class="o">(</span><span class="n">RunnerBuilder</span> <span class="n">each</span> <span class="o">:</span> <span class="n">builders</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Runner</span> <span class="n">runner</span> <span class="o">=</span> <span class="n">each</span><span class="o">.</span><span class="na">safeRunnerForClass</span><span class="o">(</span><span class="n">testClass</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">runner</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">runner</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 根据RunWith 注解获取Runner类，然后反射实例化一个对象出来，即：</span>
    <span class="c1">// runnerClass.getConstructor(Class.class).newInstance(testClass);</span>
    <span class="kd">protected</span> <span class="n">AnnotatedBuilder</span> <span class="nf">annotatedBuilder</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">AnnotatedBuilder</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// ......</span>
<span class="o">}</span>

</code></pre></div></div>

<h3 id="junitcore-运行-runner">JUnitCore 运行 Runner</h3>

<p>JUnitCore 是对 JUnit的Runner类的一个Fecade，兼容3.x和4.x的不同runner的运行，同时，可以在command中执行命令<code class="highlighter-rouge">java org.junit.runner.JUnitCore TestClass1 TestClass2</code> 运行测试用例。</p>

<p>此外，作为Facade来说，其在调用runner的run方法时，会再方法开始和结束的时候，触发相应地监听器，发布相关通知事件。如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//通过命令运行，这就是入口</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Result</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JUnitCore</span><span class="o">().</span><span class="na">runMain</span><span class="o">(</span><span class="k">new</span> <span class="n">RealSystem</span><span class="o">(),</span> <span class="n">args</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">wasSuccessful</span><span class="o">()</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 测试case真正的运行方法</span>
    <span class="kd">public</span> <span class="n">Result</span> <span class="nf">run</span><span class="o">(</span><span class="n">Runner</span> <span class="n">runner</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Result</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Result</span><span class="o">();</span>
        <span class="n">RunListener</span> <span class="n">listener</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">createListener</span><span class="o">();</span>
        <span class="n">notifier</span><span class="o">.</span><span class="na">addFirstListener</span><span class="o">(</span><span class="n">listener</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">notifier</span><span class="o">.</span><span class="na">fireTestRunStarted</span><span class="o">(</span><span class="n">runner</span><span class="o">.</span><span class="na">getDescription</span><span class="o">());</span>
            <span class="n">runner</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">notifier</span><span class="o">);</span>
            <span class="n">notifier</span><span class="o">.</span><span class="na">fireTestRunFinished</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">removeListener</span><span class="o">(</span><span class="n">listener</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>Notes: 这里特别说明下通知notify的实现，代码中创建一个<code class="highlighter-rouge">SafeNotifier</code>类，来发布一个通知，但是我们知道监听器不可能只有一个，因此，对于外部的调用来说，必须调用<code class="highlighter-rouge">SafeNotifier.run</code>方法，这个方法会依次遍历listeneres监听器列表，然后调用对应的方法触发监听事件。</p>
  </blockquote>
</blockquote>

<p>在实现中，我们自己自定义了Runner方法为<code class="highlighter-rouge">GuiceJUnitRunner</code>继承了<code class="highlighter-rouge">ParentRunner</code>,所以，我们直接看其run方法的实现：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="kd">final</span> <span class="n">RunNotifier</span> <span class="n">notifier</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Statement</span> <span class="n">statement</span> <span class="o">=</span> <span class="n">classBlock</span><span class="o">(</span><span class="n">notifier</span><span class="o">);</span>
        <span class="n">statement</span><span class="o">.</span><span class="na">evaluate</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 这里只分析最简单的方法调用，before和after是单独实现了Statement子类，执行时根据</span>
    <span class="c1">// 先后属性来决定先执行test方法还是先运行before class工作</span>
    <span class="kd">protected</span> <span class="n">Statement</span> <span class="nf">classBlock</span><span class="o">(</span><span class="kd">final</span> <span class="n">RunNotifier</span> <span class="n">notifier</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Statement</span> <span class="n">statement</span> <span class="o">=</span> <span class="n">childrenInvoker</span><span class="o">(</span><span class="n">notifier</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">areAllChildrenIgnored</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">statement</span> <span class="o">=</span> <span class="n">withBeforeClasses</span><span class="o">(</span><span class="n">statement</span><span class="o">);</span>
            <span class="n">statement</span> <span class="o">=</span> <span class="n">withAfterClasses</span><span class="o">(</span><span class="n">statement</span><span class="o">);</span>
            <span class="n">statement</span> <span class="o">=</span> <span class="n">withClassRules</span><span class="o">(</span><span class="n">statement</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">statement</span><span class="o">;</span>
    <span class="o">}</span>    

    <span class="c1">// statement其实就是对需要执行动作的一个封装，其真正的动作就是调用evaluate方法</span>
    <span class="kd">protected</span> <span class="n">Statement</span> <span class="nf">childrenInvoker</span><span class="o">(</span><span class="kd">final</span> <span class="n">RunNotifier</span> <span class="n">notifier</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Statement</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">evaluate</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">runChildren</span><span class="o">(</span><span class="n">notifier</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>


    <span class="c1">// 下面两个是实现很有意思。对于RunnerScheduler来说，字面意思就是调度，因此，其是针对不同的调用策略，执行动作的接口</span>
    <span class="c1">// 当然这里，我们直接调用运行，然后执行完所有测试的case方法之后，调用finished动作。</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">runChildren</span><span class="o">(</span><span class="kd">final</span> <span class="n">RunNotifier</span> <span class="n">notifier</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">RunnerScheduler</span> <span class="n">currentScheduler</span> <span class="o">=</span> <span class="n">scheduler</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kd">final</span> <span class="n">T</span> <span class="n">each</span> <span class="o">:</span> <span class="n">getFilteredChildren</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">currentScheduler</span><span class="o">.</span><span class="na">schedule</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
                    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                        <span class="n">ParentRunner</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">runChild</span><span class="o">(</span><span class="n">each</span><span class="o">,</span> <span class="n">notifier</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">});</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">currentScheduler</span><span class="o">.</span><span class="na">finished</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">volatile</span> <span class="n">RunnerScheduler</span> <span class="n">scheduler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RunnerScheduler</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">schedule</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">childStatement</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">childStatement</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">finished</span><span class="o">()</span> <span class="o">{</span>
            <span class="c1">// do nothing</span>
        <span class="o">}</span>
    <span class="o">};</span>

</code></pre></div></div>

<p>其实，根据 <code class="highlighter-rouge">ParentRunner</code>类的代码，基本上已经能够很清晰的明白了运行测试case的流程。其流程就是：首先，我们拿到测试类中所有需要执行的test方法；然后，把测试类中需要执行的test方法封装为一个执行动作，这个动作就是分别运行各个子方法，这些方法的执行则是根据RunnerScheduler内部的调度执行策略来的。</p>

<p>所以，根据上面的代码，发现其实有两个方法，是需要子类去实现的，其一是怎么获取测试类中需要test的方法，其二就是如果执行这些方法，之所以会如此，是因为<code class="highlighter-rouge">ParentRunner</code>这个类除了针对测试类里地方法，还针对测试包下面各种测试类，所以不同的情形，其处理逻辑是不一样的。针对包Suite，其会继续遍历解析，知道拆分成测试类，对应下面的测试方法FrameworkMethod，然后调用针对测试类的处理逻辑执行。</p>

<h3 id="guicejunitrunner-继承-blockjunit4classrunner">GuiceJUnitRunner 继承 BlockJUnit4ClassRunner</h3>

<p>如上所述，<code class="highlighter-rouge">ParentRunner</code> 关注的两个方法，需要在子类去实现。</p>

<p>获取需要test的方法，这个显然 BlockJUnit4ClassRunner 就可以给出具体实现，即根据<code class="highlighter-rouge">@Test</code>注解来获取测试类中需要执行test的方法，如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="c1">// getTestClass 获取的就是需要执行的测试类</span>
    <span class="kd">protected</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">FrameworkMethod</span><span class="o">&gt;</span> <span class="nf">computeTestMethods</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getTestClass</span><span class="o">().</span><span class="na">getAnnotatedMethods</span><span class="o">(</span><span class="n">Test</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>而，另外一个问题就是如何执行测试方法。其实现也很简单，就是首先构造测试类实例，然后根据具体的测试方法，依次通过menthod.invoke调用执行就可以了。而针对构造类实例，由于Guice获取方式是通过注入，所以是需要覆盖重写的。因此，我们看父类BlockJUnit4ClassRunner代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">runChild</span><span class="o">(</span><span class="kd">final</span> <span class="n">FrameworkMethod</span> <span class="n">method</span><span class="o">,</span> <span class="n">RunNotifier</span> <span class="n">notifier</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Description</span> <span class="n">description</span> <span class="o">=</span> <span class="n">describeChild</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isIgnored</span><span class="o">(</span><span class="n">method</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">notifier</span><span class="o">.</span><span class="na">fireTestIgnored</span><span class="o">(</span><span class="n">description</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// runLeaf 核心动作就是 statement.evaluate()</span>
            <span class="n">runLeaf</span><span class="o">(</span><span class="n">methodBlock</span><span class="o">(</span><span class="n">method</span><span class="o">),</span> <span class="n">description</span><span class="o">,</span> <span class="n">notifier</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 下面createTest就是需要实例化一个测试类对象了，然后再构造一个 methodInvoker 对象，methodInvoker</span>
    <span class="c1">// 从名字就可看出来其作用就是为了反射执行method方法。</span>
    <span class="kd">protected</span> <span class="n">Statement</span> <span class="nf">methodBlock</span><span class="o">(</span><span class="n">FrameworkMethod</span> <span class="n">method</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Object</span> <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReflectiveCallable</span><span class="o">()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">protected</span> <span class="n">Object</span> <span class="nf">runReflectiveCall</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="nf">createTest</span><span class="o">();</span>
                <span class="o">}</span>
        <span class="o">}.</span><span class="na">run</span><span class="o">();</span>
        <span class="c1">// 实际上就是方法执行 method.invoke(test, params)</span>
        <span class="n">Statement</span> <span class="n">statement</span> <span class="o">=</span> <span class="n">methodInvoker</span><span class="o">(</span><span class="n">method</span><span class="o">,</span> <span class="n">test</span><span class="o">);</span>
        <span class="c1">// ......</span>
        <span class="k">return</span> <span class="n">statement</span><span class="o">;</span>
    <span class="o">}</span>

</code></pre></div></div>

<p>ok，整个流程基本上就已经分析清楚了。此外，需要注意的是，对于继承实现Runner来说，其构造函数是带有一个testClass的参数的。例如：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="kd">public</span> <span class="nf">GuiceJUnitRunner</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">klass</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InitializationError</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">klass</span><span class="o">);</span>
        <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">classes</span> <span class="o">=</span> <span class="n">getModulesFor</span><span class="o">(</span><span class="n">klass</span><span class="o">);</span>
        <span class="n">injector</span> <span class="o">=</span> <span class="n">createInjectorFor</span><span class="o">(</span><span class="n">classes</span><span class="o">);</span><span class="c1">//创建一个injector，在createTest中，使用该injector来注入类中得各种依赖</span>
    <span class="o">}</span>

</code></pre></div></div>

<h2 id="遗留问题和总结"><a id="Problem_and_Summary">遗留问题和总结</a></h2>

<p>本文主要是基于Guice+JUnit+Mockito来构建一个单元测试实践，然后简要分析了JUnit的源码运行逻辑，但是并没深入到源码的细节。但是不得不说，JUnit不仅仅是一个非常优秀的测试框架，而且其代码结构和实现也非常的优美和可扩展，非常值得学习和借鉴。</p>

<p>后面有机会，会更深入分析其内部的实现细节，以及一些非常值得借鉴的代码设计思想。</p>

                </div>
                <div class="read-all">
                    <a  href="/2016/03/10/junit-mockito-guice-in-action-and-junit-test-mechanism/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2016/01/02/delayed-message-consume-service-use-kafka/">基于kafka的定时消息/任务服务</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2016-01-02
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Kafka" title="Category: Kafka" rel="category">Kafka</a>&nbsp;
    
        <a href="/category/#Java" title="Category: Java" rel="category">Java</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <h2 id="前言"><a id="Introduction">前言</a></h2>

<p>定时任务,在很多业务场景中都会存在.一般,我们简单解决的话,就是使用数据库来存储数据供服务端周期获取执行.显然,对于数据库处理,如果多线程或者多机器处理,就会存在扩展的问题.比如:现在一个任务记录到时间了需要执行,同时被多个executor抓取来执行,就会浪费不必要的资源;并且,这种场景还非常常见. 因此, 需要额外状态处理,或者其他分库分表策略保证尽量一个executor来操作一个记录,并且如果executor失败了,其他的executor才会去执行分配给失败executor的任务. 整个设计相对而言,就相当复杂了.</p>

<p>基于上面的一些原因,这里我们设计了一个简单的基于kafka消息队列的定时任务方案.</p>

<p>这里，首先定义一下定时消息。所谓定时消息，就是业务方根据自己的业务需求，指定在接下来的大概某个时间点来发送某条消息，从而保证该消息在某个时间点之后可接受的时间区间内消费该消息。所以这里需要指出：</p>

<blockquote>
  <blockquote>
    <p>Note:
消息机制都是异步的，所以如果存在大量消息累积未消费，则无法保证定时消息指定的时间区间。因此，使用的时候，必须预计定时消息服务提供的服务能否满足业务的QPS要求。定时消息服务设计保证支持水平扩展，因此，可以根据业务性能需求，部署足够的服务。</p>

  </blockquote>
</blockquote>

<p>kafka消息队列，所有触发都是基于消息机制的。所以，定时任务的设计必须要有定时消息服务来提供基础核心功能。首先，就需要设计一个基于kafka队列的定时消息服务。</p>

<!-- more -->

<h2 id="定时消息服务总体设计"><a id="Delayed_Message_Service_Design">定时消息服务总体设计</a></h2>

<p>定时消息服务，这里主要是服务于定时任务设计的；但是，这不意味着它不能单独提供服务。相反，定时消息服务设计时，考虑是单独部署，单独提供服务的。而定时任务，是基于定时消息服务进行封装的client端，便于没有kafka或者其他消息队列的开发者，可以直接使用，而不需要额外学习kafka的使用，虽然其接口很简便。</p>

<p>首先，给出定时消息服务整体的交互图：</p>

<p><img src="/images/2016/01/dms.png" /></p>

<p>从以上的交互图可以看到，业务方produce的定时消息，其 topic 是让 定时消息服务单独consume的；然后kafka-dms 服务将业务方produce生成的消息进行解析处理，剥离出真实的topic和payload，以及可能有的partitioner。拿到真实业务的消息，kafka-dms就可以根据业务的要求，延迟到指定的时间去produce kafka消息。这样，真实的业务consumer就可以在指定时间后消费定时消息。</p>

<p>整个交互并不复杂，简洁满足需求，可以更容易的后期维护。</p>

<p>和很多同学一样，简洁的设计并不意味着实现起来就简单。在实现过程中，考虑到业务的需求，以及开发的成本，做了一些折中权衡。</p>

<h2 id="定时消息服务具体设计与关键实现"><a id="Delayed_Message_Service_Implement">定时消息服务具体设计与关键实现</a></h2>

<p>在实现的时候，为了简单且满足需求，对于开发遇到的一些问题，进行了处理和简化。</p>

<h3 id="定时时间限制">定时时间限制</h3>

<p>由于每个业务对于需要延迟多长时间来让消费者消费消息是多种多样的，此外，基于定时消息模式处理的业务，对于时间的精准性要求并不是很高。比如，存在一个业务场景，调用外部的异步接口，接口只会告知调用已接受并处理，但是处理结果一般是通过异步回调的方式来告知；但是由于回调未必会成功，但是业务一直处于中间状态，这个时候是需要通过查询机制来获取真实状态，完成状态调整的。这种场景，是不会对定时执行时间要求很高的，一般其只需要在约定业务处理时间后的某个时间触发即可。</p>

<p>基于很多上面类似场景的情况，这里我们对定时时间进行限制。也就是，业务方只能在指定的延迟时间来选择。当然，这里的延迟时间是可以根据具体使用来具体调整的。默认，我们的延迟时间级别如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">enum</span> <span class="n">MsgDelayedLevel</span> <span class="o">{</span>

    <span class="c1">// 1MS 主要服务异步任务</span>
    <span class="n">ONE_MS_DELAYED</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1L</span><span class="o">),</span>
    <span class="c1">// 1秒</span>
    <span class="n">ONE_S_DELAYED</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 5秒</span>
    <span class="n">FIVE_S_DELAYED</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 10秒</span>
    <span class="n">TEN_S_DELAYED</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 20秒</span>
    <span class="n">TWENTY_S_DELAYED</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">20</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 30秒</span>
    <span class="n">THIRTY_S_DELAYED</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 1分钟</span>
    <span class="n">ONE_M_DELAYED</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 5分钟</span>
    <span class="n">FIVE_M_DELAYED</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 10分钟</span>
    <span class="n">TEN_M_DELAYED</span><span class="o">(</span><span class="mi">8</span><span class="o">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 20分钟</span>
    <span class="n">TWENTY_M_DELAYED</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">20</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 30分钟</span>
    <span class="n">THIRTY_M_DELAYED</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 1小时</span>
    <span class="n">ONE_H_DELAYED</span><span class="o">(</span><span class="mi">11</span><span class="o">,</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 2小时</span>
    <span class="n">TWO_H_DELAYED</span><span class="o">(</span><span class="mi">12</span><span class="o">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 3小时</span>
    <span class="n">THREE_H_DELAYED</span><span class="o">(</span><span class="mi">13</span><span class="o">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 6小时</span>
    <span class="n">SIX_H_DELAYED</span><span class="o">(</span><span class="mi">14</span><span class="o">,</span> <span class="mi">6</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 12小时</span>
    <span class="n">TWELVE_H_DELAYED</span><span class="o">(</span><span class="mi">15</span><span class="o">,</span> <span class="mi">12</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 1天</span>
    <span class="n">ONE_D_DELAYED</span><span class="o">(</span><span class="mi">16</span><span class="o">,</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),</span>
    <span class="c1">// 2天</span>
    <span class="n">TWO_D_DELAYED</span><span class="o">(</span><span class="mi">17</span><span class="o">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000L</span><span class="o">),;</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">level</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">delayedMs</span><span class="o">;</span>

    <span class="n">MsgDelayedLevel</span><span class="o">(</span><span class="kt">int</span> <span class="n">level</span><span class="o">,</span> <span class="kt">long</span> <span class="n">delayedMs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">level</span> <span class="o">=</span> <span class="n">level</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">delayedMs</span> <span class="o">=</span> <span class="n">delayedMs</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h3 id="topic-细分">Topic 细分</h3>

<p>延迟时间限制，很大的原因，是因为实现的时候，基于kafka的消息必须顺序消费，这就意味着，如果同一个topic的partitioner内，必须定时的时间都按照顺序排序的。否则，我们只能将所有队列的消息都拿出来消费，然后在内存中排序（万一down机就完了），或者保存在数据库中（又回到最初避免的问题上了）。</p>

<p>基于以上问题，我们对延迟时间进行了级别限制，然后这些级别反映到 Topic 上面。也就是，目前的设计中，我们对每个级别的延迟，都单独提供了一个 Topic 来处理。这就很好地规避了以上 kafka 特性而导致实现上的问题。</p>

<p>每个 topic 的对应的消息队列都是一个水平的超时时间，因此，后面进入到消息队列的消息，执行时间肯定是在前面消息之后的（不考虑不同服务器的网络差异问题）。这就意味着，如果前面消息未到处理时间，后面消息，肯定可以不需要处理。</p>

<p>Topic 生成规则：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">DELAYED_MSG_PREFIX</span> <span class="o">=</span> <span class="s">"KAFKA_DELAYED_MSG_"</span><span class="o">;</span>
<span class="n">String</span> <span class="n">topic</span> <span class="o">=</span> <span class="n">KafkaConstants</span><span class="o">.</span><span class="na">DELAYED_MSG_PREFIX</span> <span class="o">+</span> <span class="n">delayedLevel</span><span class="o">.</span><span class="na">getLevel</span><span class="o">()</span><span class="err">；</span>

</code></pre></div></div>

<h3 id="延迟消息处理">延迟消息处理</h3>

<p>从 kafka 消息队列中 pull到消息，按照约定的格式进行解析，然后进行处理，produce 真实的业务消息，push 到kafka消息队列中。当我们pull到的消息还未到定时时间，则阻塞等待时间，交给schedulerThread来执行，执行完了之后，会手动触发commit offset，从而消费对应partitioner的下一条消息。这里可能性能有问题，不过通过多部署实例和多partitioner来扩展。</p>

<p>核心的定时消息处理：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">processHandler</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="kd">final</span> <span class="n">MessageBody</span> <span class="n">body</span><span class="o">,</span> <span class="kd">final</span> <span class="n">ConsumerConnector</span> <span class="n">connector</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">body</span><span class="o">.</span><span class="na">getCurrentTime</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">now</span> <span class="o">||</span> <span class="n">body</span><span class="o">.</span><span class="na">getCurrentTime</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">body</span><span class="o">.</span><span class="na">setCurrentTime</span><span class="o">(</span><span class="n">now</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kt">long</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">body</span><span class="o">.</span><span class="na">getCurrentTime</span><span class="o">()</span> <span class="o">-</span> <span class="n">DELAYED_LEVEL_MS_TIMES</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">diff</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>

            <span class="k">try</span> <span class="o">{</span>
                <span class="n">MsgProducerUtils</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">body</span><span class="o">.</span><span class="na">getTopic</span><span class="o">(),</span> <span class="n">body</span><span class="o">.</span><span class="na">getPartitionNum</span><span class="o">(),</span> <span class="n">body</span><span class="o">.</span><span class="na">getRealPayLoad</span><span class="o">());</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalArgumentException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"producer params illegal. key:{},body:{},e:"</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">body</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">connector</span><span class="o">.</span><span class="na">commitOffsets</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>

            <span class="n">schedulerExecutor</span><span class="o">.</span><span class="na">schedule</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                    <span class="n">processHandler</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">body</span><span class="o">,</span> <span class="n">connector</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">},</span> <span class="o">-</span><span class="n">diff</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>

        <span class="o">}</span>

    <span class="o">}</span>


</code></pre></div></div>

<h2 id="基于定时消息的定时任务总体设计"><a id="Delayed_Task_Base_Message_Service_Design">基于定时消息的定时任务总体设计</a></h2>

<p>定时任务，实际上是基于定时消息封装的client客户端。业务方，引入对应的jar包后，调用相关的方法，就可以完成对某个类的某个方法进行调用。</p>

<p>由于定时任务主要是对调用方屏蔽掉使用生产kafka定时消息以及消费kafka消息带来的额外学习成本，因此，其主要提供两个方面的功能，produce 和 consume kafka消息。</p>

<p>基于定时消息的定时任务整体交互流程如下：</p>

<p><img src="/images/2016/01/dts.png" /></p>

<p>从交互图可以显然的看到，我们在client内定义了一个调用方法相关的数据结构，业务代码将该数据结构交给client，client根据该数据结构，构建topic，发送到kafka-dms服务上；然后client 根据业务配置的project.topic 来pull消息，反射执行方法，完成定时任务调用。</p>

<h2 id="基于定时消息的定时任务具体设计与关键实现"><a id="Delayed_Task_Base_Message_Service_Implement">基于定时消息的定时任务具体设计与关键实现</a></h2>

<p>定时任务client实现，其实质就是根据业务级别来封装处理kafka消息。一般的，对于这种需求，显然需要配置的kafka相关设置越少越好，因此为了使用简便，对于很多功能都省去。</p>

<h3 id="broker-获取和-partitioner-获取">Broker 获取和 partitioner 获取</h3>

<p>一般，对于producer使用中，需要设置broker list来告知kafka的服务地址。在client中，我们不希望业务方去了解设置这些。因此，需要通过代码获取broker地址。由于kafka的获取是scala实现，因此，这里首先使用java来重写，对java来进行调用。</p>

<p>同样，对于分区逻辑，业务方也不会关心（如果想保证先后顺序，即在一个分区内，可以通过数据结构的key来实现），业务需要根据topic去获取对应的实际分区数来达到分区效果。对于分区，kafka定时消息是根据业务方的key直接push到对应的业务消息分区的。</p>

<p>获取broker实现如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">KafkaZkUtils</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">KafkaZkUtils</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">BrokerIdsPath</span> <span class="o">=</span> <span class="s">"/brokers/ids"</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">BrokerTopicsPath</span> <span class="o">=</span> <span class="s">"/brokers/topics"</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TopicConfigPath</span> <span class="o">=</span> <span class="s">"/config/topics"</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">DeleteTopicsPath</span> <span class="o">=</span> <span class="s">"/admin/delete_topics"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getTopicPath</span><span class="o">(</span><span class="n">String</span> <span class="n">topic</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">BrokerTopicsPath</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="n">topic</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getTopicPartitionsPath</span><span class="o">(</span><span class="n">String</span> <span class="n">topic</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getTopicPath</span><span class="o">(</span><span class="n">topic</span><span class="o">)</span> <span class="o">+</span> <span class="s">"/partitions"</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 获取topic 分区. 由于构造CuratorFramework 成功很大,所以请缓存结果,或者使用下面的方法来获取
     * 
     * @param zkAddress
     * @param topic
     * @return
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">getPartitionsForTopic</span><span class="o">(</span><span class="n">String</span> <span class="n">zkAddress</span><span class="o">,</span> <span class="n">String</span> <span class="n">topic</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">CuratorFramework</span> <span class="n">client</span> <span class="o">=</span> <span class="n">CuratorFrameworkFactory</span><span class="o">.</span><span class="na">newClient</span><span class="o">(</span><span class="n">zkAddress</span><span class="o">,</span> <span class="mi">6000</span><span class="o">,</span> <span class="mi">6000</span><span class="o">,</span> <span class="k">new</span> <span class="n">RetryForever</span><span class="o">(</span><span class="mi">1000</span><span class="o">));</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">client</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

            <span class="k">return</span> <span class="nf">getPartitionsForTopic</span><span class="o">(</span><span class="n">client</span><span class="o">,</span> <span class="n">topic</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">client</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">getBrokers</span><span class="o">(</span><span class="n">String</span> <span class="n">zkAddress</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">CuratorFramework</span> <span class="n">client</span> <span class="o">=</span> <span class="n">CuratorFrameworkFactory</span><span class="o">.</span><span class="na">newClient</span><span class="o">(</span><span class="n">zkAddress</span><span class="o">,</span> <span class="mi">6000</span><span class="o">,</span> <span class="mi">6000</span><span class="o">,</span> <span class="k">new</span> <span class="n">RetryForever</span><span class="o">(</span><span class="mi">1000</span><span class="o">));</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">client</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

            <span class="k">return</span> <span class="nf">getBrokers</span><span class="o">(</span><span class="n">client</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">client</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 获取某个指定topic 的分区情况.
     * 
     * @param zkClient 已经start,并且close由其关闭
     * @param topic
     * @return
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">getPartitionsForTopic</span><span class="o">(</span><span class="n">CuratorFramework</span> <span class="n">zkClient</span><span class="o">,</span> <span class="n">String</span> <span class="n">topic</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">{</span>

            <span class="k">return</span> <span class="n">zkClient</span><span class="o">.</span><span class="na">getChildren</span><span class="o">().</span><span class="na">forPath</span><span class="o">(</span><span class="n">getTopicPartitionsPath</span><span class="o">(</span><span class="n">topic</span><span class="o">));</span>

        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>

            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"getPartitionsForTopic error.topic:{}, e:"</span><span class="o">,</span> <span class="n">topic</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * 简单需求的时候,可以使用,对应broker,一般使用zk的watch保存监听比较好
     * 
     * @param zkClient
     * @return
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">getBrokers</span><span class="o">(</span><span class="n">CuratorFramework</span> <span class="n">zkClient</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">{</span>

            <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">brokerIds</span> <span class="o">=</span> <span class="n">zkClient</span><span class="o">.</span><span class="na">getChildren</span><span class="o">().</span><span class="na">forPath</span><span class="o">(</span><span class="n">BrokerIdsPath</span><span class="o">);</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">brokerIds</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">brokerIds</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">brokerHostInfo</span> <span class="o">=</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">id</span> <span class="o">:</span> <span class="n">brokerIds</span><span class="o">)</span> <span class="o">{</span>

                <span class="n">String</span> <span class="n">info</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">zkClient</span><span class="o">.</span><span class="na">getData</span><span class="o">().</span><span class="na">forPath</span><span class="o">(</span><span class="n">BrokerIdsPath</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="n">id</span><span class="o">));</span>

                <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">JsonUtils</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">info</span><span class="o">,</span> <span class="n">Map</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

                <span class="n">brokerHostInfo</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"host"</span><span class="o">)</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"port"</span><span class="o">));</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="n">brokerHostInfo</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>

            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"getBrokers error. e:"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="client-调用业务接口">client 调用业务接口</h3>

<p>在业务调用接口的时候，它需要把定时任务执行的方法和相关参数序列化，然后client pull到消息后，将这些信息通过反射机制来执行。</p>

<p>首先看一下，业务调用异步任务接口时，需要提供的数据结构：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DelayedTaskProperty</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">6227226019751603874L</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">String</span> <span class="n">classFullName</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">String</span> <span class="n">methodName</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">;</span>

    <span class="cm">/**
     * 路由规则的key,如果不设置,则随机路由到不同的分区
     */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">routeKey</span><span class="o">;</span>

<span class="o">}</span>

</code></pre></div></div>

<p>然后根据上面数据结构的信息，client的consumer端就可以来执行相应的方法了：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/**
     * 处理的核心逻辑,反射方式调用方法
     * 
     * @param property
     * @param connector
     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">processHandler</span><span class="o">(</span><span class="n">DelayedTaskProperty</span> <span class="n">property</span><span class="o">,</span> <span class="n">ConsumerConnector</span> <span class="n">connector</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">CLASS_MAP</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">property</span><span class="o">.</span><span class="na">getClassFullName</span><span class="o">());</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">clazz</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">LOCK</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">clazz</span> <span class="o">=</span> <span class="n">ClassUtils</span><span class="o">.</span><span class="na">getClass</span><span class="o">(</span><span class="n">property</span><span class="o">.</span><span class="na">getClassFullName</span><span class="o">());</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"class reflect error.class:{} not find.e:"</span><span class="o">,</span> <span class="n">property</span><span class="o">.</span><span class="na">getClassFullName</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
                    <span class="n">connector</span><span class="o">.</span><span class="na">commitOffsets</span><span class="o">();</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">CLASS_MAP</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">property</span><span class="o">.</span><span class="na">getClassFullName</span><span class="o">(),</span> <span class="n">clazz</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// FIXME: 16/1/2 这里的异常等处理后续需要细化,确保有些额外异常不进行commit?</span>
        <span class="k">try</span> <span class="o">{</span>

            <span class="n">Object</span> <span class="n">target</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
            <span class="n">Reflection</span><span class="o">.</span><span class="na">invokeN</span><span class="o">(</span><span class="n">clazz</span><span class="o">,</span> <span class="n">property</span><span class="o">.</span><span class="na">getMethodName</span><span class="o">(),</span> <span class="n">target</span><span class="o">,</span> <span class="n">property</span><span class="o">.</span><span class="na">getArgs</span><span class="o">());</span>

        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"e:"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">connector</span><span class="o">.</span><span class="na">commitOffsets</span><span class="o">();</span>
        <span class="o">}</span>

    <span class="o">}</span>

</code></pre></div></div>

<h2 id="遗留问题和总结"><a id="Problem_and_Summary">遗留问题和总结</a></h2>

<p>显然，这个基于kafka消息队列的定时消息，还可以完成其他一些需求。</p>

<p>目前的设计，还处在使用kafka完成我们需要的定时消息的功能，以及基于此的定时任务；其性能和设计上的优化，还有很多进步的空间，代码还没有进行优化和统一等等。</p>

<p>此外，对于client的使用，显然需要封装成jar包，然后给业务方引入。</p>

<p>具体的代码请参考：<a href="https://github.com/ketao1989/JavaApiUtilsProject/tree/master/src/main/java/io/github/ketao1989/scheduler">https://github.com/ketao1989/JavaApiUtilsProject/tree/master/src/main/java/io/github/ketao1989/scheduler</a></p>

<p>整体的项目在：git@github.com:ketao1989/JavaApiUtilsProject.git</p>

                </div>
                <div class="read-all">
                    <a  href="/2016/01/02/delayed-message-consume-service-use-kafka/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
        </ul>



        <!-- Pagination links -->
        <div class="pagination">
          
            <span class="previous disable"><i class="fa fa-angle-double-left"></i></span>
            <span class="previous disable"><i class="fa fa-angle-left"></i></span>
          
          <span class="page_number ">1/8</span>
          
            <a href="/page2" class="next"><i class="fa fa-angle-right"></i></a>
            <a href="/page8" class="next"><i class="fa fa-angle-double-right"></i></a>
          
        </div>
    </div>
    <!-- <button class="anchor"><i class="fa fa-anchor"></i></button> -->
    <div class="right">
        <div class="wrap">
            <div class="side">
                <div>
                    <i class="fa fa-pencil-square-o" aria-hidden="true"></i>
                    Recent Posts
                </div>
                <ul class="content-ul" recent>
                    
                        <li><a href="/2017/03/29/java-server-in-action/">深入浅出Java服务端原理之基础篇</a></li>
                    
                        <li><a href="/2016/12/10/rpc-theory-in-action/">深入浅出RPC原理</a></li>
                    
                        <li><a href="/2016/05/29/talk-about-java-gc/">聊聊 Java GC</a></li>
                    
                        <li><a href="/2016/04/29/thrift-service-discory-using-zookeeper-ourea/">Ourea-基于Zookeeper的Thrift服务发现框架实现</a></li>
                    
                        <li><a href="/2016/03/10/junit-mockito-guice-in-action-and-junit-test-mechanism/">基于JUnit Mockito Guice测试实践及JUnit运行机制浅析</a></li>
                    
                        <li><a href="/2016/01/02/delayed-message-consume-service-use-kafka/">基于kafka的定时消息/任务服务</a></li>
                    
                        <li><a href="/2015/09/05/zookeeper-programmer-guide/">Zookeeper 编程指南</a></li>
                    
                        <li><a href="/2015/08/30/nginx-proxy-configure-and-sduty/">Nginx 反向代理配置和工作原理</a></li>
                    
                        <li><a href="/2015/04/29/LogBack-Implemention-And-Slf4j-Mdc/">Slf4j MDC 使用和 基于 Logback 的实现分析</a></li>
                    
                        <li><a href="/2015/02/26/Python-Tutoril-Python-Object-Oriented-Programming/">Python 教程学习之 Python 面向对象编程</a></li>
                    
                </ul>
            </div>

            <!-- Content -->
            <div class="side ">
                <div>
                    <i class="fa fa-th-list"></i>
                    Categories
                </div>
                <ul class="content-ul" cate>
                    
                    <li>
                        <a href="/category/#Java" class="categories-list-item" cate="Java">
                            <span class="name">
                                Java
                            </span>
                            <span class="badge">19</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#IDE" class="categories-list-item" cate="IDE">
                            <span class="name">
                                IDE
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Log" class="categories-list-item" cate="Log">
                            <span class="name">
                                Log
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Thread" class="categories-list-item" cate="Thread">
                            <span class="name">
                                Thread
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Spring" class="categories-list-item" cate="Spring">
                            <span class="name">
                                Spring
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#GC" class="categories-list-item" cate="GC">
                            <span class="name">
                                GC
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Mysql" class="categories-list-item" cate="Mysql">
                            <span class="name">
                                Mysql
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Script" class="categories-list-item" cate="Script">
                            <span class="name">
                                Script
                            </span>
                            <span class="badge">3</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Linux" class="categories-list-item" cate="Linux">
                            <span class="name">
                                Linux
                            </span>
                            <span class="badge">5</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Python" class="categories-list-item" cate="Python">
                            <span class="name">
                                Python
                            </span>
                            <span class="badge">5</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Redis" class="categories-list-item" cate="Redis">
                            <span class="name">
                                Redis
                            </span>
                            <span class="badge">6</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Redis Cookbook" class="categories-list-item" cate="Redis Cookbook">
                            <span class="name">
                                Redis Cookbook
                            </span>
                            <span class="badge">6</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#tools" class="categories-list-item" cate="tools">
                            <span class="name">
                                tools
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Json" class="categories-list-item" cate="Json">
                            <span class="name">
                                Json
                            </span>
                            <span class="badge">3</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Dubbo" class="categories-list-item" cate="Dubbo">
                            <span class="name">
                                Dubbo
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Git" class="categories-list-item" cate="Git">
                            <span class="name">
                                Git
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Nginx" class="categories-list-item" cate="Nginx">
                            <span class="name">
                                Nginx
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Zookeeper" class="categories-list-item" cate="Zookeeper">
                            <span class="name">
                                Zookeeper
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Translation" class="categories-list-item" cate="Translation">
                            <span class="name">
                                Translation
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Kafka" class="categories-list-item" cate="Kafka">
                            <span class="name">
                                Kafka
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#JUnit" class="categories-list-item" cate="JUnit">
                            <span class="name">
                                JUnit
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Guice" class="categories-list-item" cate="Guice">
                            <span class="name">
                                Guice
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Thrift" class="categories-list-item" cate="Thrift">
                            <span class="name">
                                Thrift
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#rpc" class="categories-list-item" cate="rpc">
                            <span class="name">
                                rpc
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#dubbo" class="categories-list-item" cate="dubbo">
                            <span class="name">
                                dubbo
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#thrift" class="categories-list-item" cate="thrift">
                            <span class="name">
                                thrift
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#java" class="categories-list-item" cate="java">
                            <span class="name">
                                java
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#socket" class="categories-list-item" cate="socket">
                            <span class="name">
                                socket
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <div class="side">
                <div>
                    <i class="fa fa-tags"></i>
                    Tags
                </div>
                <div class="tags-cloud">
                    
                    
                    
                    

                    

                    
                </div>
            </div>

            <!-- <div class="side">
                <div>
                    <i class="fa fa-external-link"></i>
                    Links
                </div>
                <ul  class="content-ul">

                </ul>
            </div> -->
        </div>
    </div>
</div>
<!-- <script src="/js/scroll.min.js " charset="utf-8"></script> -->
<!-- <script src="/js/pageContent.js " charset="utf-8"></script> -->


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
             本站保留着一点点技术积蓄！ 
        </p>
        <p class="contact">
            Contact me at: 
            <a href="https://github.com/ketao1989" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a>  
            <a href="mailto:ketao1989@126.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>  
            <a href="http://weibo.com/柯小小西" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a>       
        </p>
        <p>
            本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </p>
        <p class="power">
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>.
            </span>
            <span>
                Theme designed by <a href="https://github.com/Gaohaoyang">HyG</a>.
            </span>
        </p>
    </div>
</footer>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <div class="back-to-top">
    <a href="#top" data-scroll>
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /js/main.js " charset="utf-8"></script>
    <script src=" /js/smooth-scroll.min.js " charset="utf-8"></script>
    <script type="text/javascript">
      smoothScroll.init({
        speed: 500, // Integer. How fast to complete the scroll in milliseconds
        easing: 'easeInOutCubic', // Easing pattern to use
        offset: 20, // Integer. How far to offset the scrolling anchor location in pixels
      });
    </script>
    <!-- <script src=" /js/scroll.min.js " charset="utf-8"></script> -->
  </body>

</html>
