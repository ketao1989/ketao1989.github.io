<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>柯小小西</title>
    <meta name="description" content="">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_8v3czwksspqlg14i.css">
    <link rel="stylesheet" href="/css/main.css ">
    <link rel="canonical" href="http://localhost:4000/page4/">
    <link rel="alternate" type="application/rss+xml" title="柯小小西" href="http://localhost:4000/feed.xml ">


    <script>
    // 百度统计代码
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?a9b0f47a0e50b02dafb8a7088436a9bc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>




</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">柯小小西</a>
        <small>留着一点点技术积蓄</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                    <a href="/">
                    
                        <i class="fa fa-home"></i>Home
                    </a>
                </li>

                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>Archives
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>Categories
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/tag/">
                        
                            <i class="fa fa-tags"></i>Tags
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/about/">
                        
                            <i class="fa fa-heart"></i>About
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" index>
    <div class="left">
        <h1>Welcome to 柯小小西's Blog!</h1>
        <small>留着一点点技术积蓄</small>
        <hr>
        <ul>
            
              <li>
                <h2>
                  <a class="post-link" href="/2014/12/20/Redis-Cookbook-Chat-System/">Redis Cookbook 之 基于Redis 实现一个聊天系统</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2014-12-20
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Redis" title="Category: Redis" rel="category">Redis</a>&nbsp;
    
        <a href="/category/#Redis Cookbook" title="Category: Redis Cookbook" rel="category">Redis Cookbook</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <h2 id="问题"><a id="Problem">问题</a></h2>

<p>想要借助 <code class="highlighter-rouge">Redis</code>的<code class="highlighter-rouge">PUB/SUB</code>功能，使用node.js和Socket.io实现一个轻量级的实时聊天系统。</p>

<h2 id="解决方法"><a id="Solution">解决方法</a></h2>

<p>由于Redis 天生就支持发布订阅(pub/sub)模式，所以我们可以很容易就使用<code class="highlighter-rouge">Node.js</code> 和 <code class="highlighter-rouge">Socket.IO</code>来快速创建一个实时的聊天系统。</p>

<p>发布订阅模式，其实就是接收者订阅某种特定模式的消息(比如，发送到某个指定channel的消息)，而发送者发送一个消息到消息云上。当一个消息到达云上的时候，订阅了这一种类的客户端就会获得消息。这中发布订阅模式，然后就可以允许发送者和接收客户端在不知道彼此的情况下，亲密结对交流。而他们仅仅需要以一种既定的模式发送消息和接收匹配类型的消息即可。</p>

<p><code class="highlighter-rouge">Redis</code>直接支持<code class="highlighter-rouge">pub/sub</code>模式，意味着其可以让接收客户端订阅指定的匹配消息频道channel，以及发布消息到一个给定的频道channel。这意味着，我们可以很简单地创建像<code class="highlighter-rouge">chat:cars</code>的聊车频道；或者像<code class="highlighter-rouge">chat:sausage</code>这种关于食物的谈话。此外，频道channel的命名跟Redis 的keySpace无关，所以不用担心会存在某些冲突情况。下面给出，Redis支持的一些命令：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    * PUBLISH：发布消息到指定的频道；

    * SUBSCRIBE：订阅一个指定频道的消息；

    * UNSUBSCRIBE：取消订阅一个指定频道；

    * PSUBSCRIBE：订阅一个满足给定模式的频道集；

    * PUNSUBSCRIBE：取消订阅满足指定模式的频道集。
</code></pre></div></div>

<p>拥有上面这些知识，为在应用程序逻辑部分之间的终端用户或者流消息实现一个聊天和统计系统，其实还是很琐碎的。
<code class="highlighter-rouge">pub/sub</code>甚至可以被用来作为一个内建的强壮阻塞队列系统。接下来看看，如何去实现这么一个消息聊天系统吧。</p>

<p>在服务端，<code class="highlighter-rouge">Node.js</code> 和 <code class="highlighter-rouge">Socket.IO</code>将来实现网络层，然后Redis将作为一个在客户端之间递交消息的<code class="highlighter-rouge">pub/sub</code>功能的实现。在客户端，我们使用jQuery来处理消息，然后发送数据到服务器上。</p>

<!-- more -->

<h2 id="讨论"><a id="Discussion">讨论</a></h2>

<p>由于本文使用Node.js来实现一个聊天系统，所以我们假设你已经安装了node.js，并且我们也希望你可以按顺序安装支持我们聊天系统所需要的<code class="highlighter-rouge">node库(Socket.IO and Redis)</code>。</p>

<h3 id="初始设置">初始设置</h3>
<p>安装所需要的第三方库：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    npm install socket.io

    npm install redis
</code></pre></div></div>

<h3 id="服务端代码实现">服务端代码实现</h3>

<p>在服务端，我们正在运行<code class="highlighter-rouge">Redis</code>并且创建了一个运行node.js的javaScript文件。该代码主要负责建立到Redis服务之间的链接conn，然后一直监听来自clients端连接请求的端口。因此，我们创建一个javascript代码文件<code class="highlighter-rouge">chat.js</code>:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
        
    <span class="kd">var</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'http'</span><span class="p">),</span> 
    <span class="nx">io</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'socket.io'</span><span class="p">),</span> 
    <span class="nx">redis</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'redis'</span><span class="p">),</span> 
    <span class="nx">rc</span> <span class="o">=</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">createClient</span><span class="p">();</span>

</code></pre></div></div>

<p>上面的代码，可以建立redis连接，和引入http,socket.io,redis库。接下来，我们需要设置一个简单地server，让客户端可以连接，请求数据：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
        
    <span class="nx">server</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
        <span class="c1">// we may want to redirect a client that hits this page </span>
        <span class="c1">// to the chat URL instead</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">writeHead</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span><span class="p">:</span> <span class="s1">'text/html'</span><span class="p">});</span> 
        <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s1">'&lt;h1&gt;Hello world&lt;/h1&gt;'</span><span class="p">);</span>
    <span class="p">});</span>
    
    <span class="c1">// Set up our server to listen on 8000 and serve socket.io server.listen(8000);</span>
    <span class="kd">var</span> <span class="nx">socketio</span> <span class="o">=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="nx">server</span><span class="p">);</span>

</code></pre></div></div>

<p>接下来，建立连接了就可以开始使用node.js来完成开发连接redis，客户端订阅某个channel，接收到消息处理动作等功能。所以，接下来使用redis来完成订阅消息：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
        
    <span class="c1">// if the Redis server emits a connect event, it means we're ready to work, </span>
    <span class="c1">// which in turn means we should subscribe to our channels. Which we will. rc.on("connect", function() {</span>
        <span class="nx">rc</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s2">"chat"</span><span class="p">);</span>
        <span class="c1">// we could subscribe to more channels here </span>
    <span class="p">});</span>
        <span class="c1">// When we get a message in one of the channels we're subscribed to, // we send it over to all connected clients.</span>
    <span class="nx">rc</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"message"</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Sending: "</span> <span class="o">+</span> <span class="nx">message</span><span class="p">);</span>
        <span class="nx">socketio</span><span class="p">.</span><span class="nx">sockets</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">'message'</span><span class="p">,</span> <span class="nx">message</span><span class="p">);</span> 
    <span class="p">})</span>

</code></pre></div></div>

<p>ok，如你所见，这段代码非常简单。其实现，就是我们在特定的channel监听消息，当有消息接收到的时候，服务端就广播给所有订阅该消息的客户端。</p>

<h3 id="客户端代码实现">客户端代码实现</h3>

<p>完成了server端部分的开发，接下来完成一个小页面来连接Node.js，建立客户端的Socket.IO，然后处理进来和出去的消息。所以我们创建了一个很简单的<code class="highlighter-rouge">HTML5</code>页面：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
        
    <span class="cp">&lt;!doctype html&gt;</span> <span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span> <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span>Chat with Redis<span class="nt">&lt;/title&gt;</span> <span class="nt">&lt;/head&gt;</span>
    <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;ul</span> <span class="na">id=</span><span class="s">"messages"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- chat messages go here --&gt;</span> <span class="nt">&lt;/ul&gt;</span>
    <span class="nt">&lt;/body&gt;</span> <span class="nt">&lt;/html&gt;</span>

</code></pre></div></div>

<p>现在我们需要引入两个非常重要的库来获得想要的功能：jQuery 和 Socket.IO：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
        
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span> 
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"http://localhost:8000/socket.io/socket.io.js"</span><span class="nt">&gt;&lt;/script&gt;</span>

</code></pre></div></div>

<p>现在我们准备好了从页面连接Node.js，然后开始监听处理消息。在页面的头部增加下面的代码：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
        
    <span class="nt">&lt;script&gt;</span>
    <span class="kd">var</span> <span class="nx">socket</span> <span class="o">=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span><span class="s1">'localhost'</span><span class="p">,</span> <span class="p">{</span> <span class="na">port</span><span class="p">:</span> <span class="mi">8000</span> <span class="p">});</span>
    <span class="nx">socket</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'message'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">li</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Element</span><span class="p">(</span><span class="s1">'li'</span><span class="p">).</span><span class="nx">insert</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
        <span class="nx">$</span><span class="p">(</span><span class="s1">'messages'</span><span class="p">).</span><span class="nx">insert</span><span class="p">({</span><span class="na">top</span><span class="p">:</span> <span class="nx">li</span><span class="p">});</span> 
    <span class="p">});</span>
    <span class="nt">&lt;/script&gt;</span>

</code></pre></div></div>

<p>这个javascript代码片段表示，客户端使用<code class="highlighter-rouge">Socket.IO</code>连接我们的node.js实例8000端口，然后开始监听消息事件。当一个消息到达时，它创建一个新的list元素，并且把它添加到我们事先已经建好的未排序list中。</p>

<p>到这里，还剩下的，就是客户端发送消息了。和server端一样，我们使用<code class="highlighter-rouge">Socket.IO emit</code>方法，如下所示：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
        
    <span class="nt">&lt;form</span> <span class="na">id=</span><span class="s">"chatform"</span> <span class="na">action=</span><span class="s">""</span><span class="nt">&gt;</span>
        <span class="nt">&lt;input</span> <span class="na">id=</span><span class="s">"chattext"</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">value=</span><span class="s">""</span> <span class="nt">/&gt;</span> 
        <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"submit"</span> <span class="na">value=</span><span class="s">"Send"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/form&gt;</span>
    
    
    <span class="nt">&lt;script&gt;</span> 
    <span class="nx">$</span><span class="p">(</span><span class="s1">'#chatform'</span><span class="p">).</span><span class="nx">submit</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">socket</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">'message'</span><span class="p">,</span> <span class="nx">$</span><span class="p">(</span><span class="s1">'chattext'</span><span class="p">).</span><span class="nx">val</span><span class="p">());</span> 
        <span class="nx">$</span><span class="p">(</span><span class="s1">'chattext'</span><span class="p">).</span><span class="nx">val</span><span class="p">(</span><span class="s2">""</span><span class="p">);</span> <span class="c1">// cleanup the field </span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">});</span> 
    <span class="nt">&lt;/script&gt;</span>

</code></pre></div></div>

<p>当一个用户写东西到<code class="highlighter-rouge">form</code>中，然后点击<code class="highlighter-rouge">Send</code>，jQuery将会使用我们的socket变量emit发送一个消息事件到服务器端，服务器然后会广播这条消息给其他所有人。最后返回false表示消息事件真的被发送提交出去了。提交的这个动作是由<code class="highlighter-rouge">Socket.IO</code>完成的。</p>


                </div>
                <div class="read-all">
                    <a  href="/2014/12/20/Redis-Cookbook-Chat-System/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2014/12/19/Guava-Cache-Guide-And-Implement-Analyse/">Guava LocalCache 缓存介绍及实现源码深入剖析</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2014-12-19
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Java" title="Category: Java" rel="category">Java</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <h2 id="前言"><a id="Intro">前言</a></h2>
<p>Guava是Google开源出来的Java常用工具集库,包括集合|缓存|并发|字符串|IO操作等在Java开发过程中经常需要去实现的工具类.</p>

<p>显然,对于这种十分常见的需求,Guava提供了自己的工具类实现.GuavaCache 提供了一般我们使用缓存所需要的几乎所有的功能,主要有:</p>

<ul>
  <li>
    <p>自动将entry节点加载进缓存结构中;</p>
  </li>
  <li>
    <p>当缓存的数据已经超过预先设置的最大值时，使用LRU算法移除一些数据；</p>
  </li>
  <li>
    <p>具备根据entry节点上次被访问或者写入的时间来计算过期机制；</p>
  </li>
  <li>
    <p>缓存的key被封装在<code class="highlighter-rouge">WeakReference</code>引用内;</p>
  </li>
  <li>
    <p>缓存的value被封装在<code class="highlighter-rouge">WeakReference</code>或者<code class="highlighter-rouge">SoftReference</code>引用内；</p>
  </li>
  <li>
    <p>移除entry节点，可以触发监听器通知事件；</p>
  </li>
  <li>
    <p>统计缓存使用过程中命中率/异常率/未命中率等数据。</p>
  </li>
</ul>

<p>此外，<code class="highlighter-rouge">Guava Cache</code>其核心数据结构大体上和<code class="highlighter-rouge">ConcurrentHashMap</code>一致，具体细节上会有些区别。功能上，ConcurrentMap会一直保存所有添加的元素，直到显式地移除.相对地,<code class="highlighter-rouge">Guava Cache</code>为了限制内存占用,通常都设定为自动回收元素.在某些场景下,尽管它不回收元素,也是很有用的,因为它会自动加载缓存.</p>

<!-- more -->

<h2 id="guava-cache-介绍"><a id="CacheGuide">Guava Cache 介绍</a></h2>

<p>在介绍<code class="highlighter-rouge">Guava Cache</code>使用之前，先需要引入下官方推荐的使用场景：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* 愿意消耗一些内存空间来提升速度；
    
* 能够预计某些key会被查询一次以上；
    
* 缓存中存放的数据总量不会超出内存容量(`Guava Cache`是单个应用运行时的本地缓存)。
</code></pre></div></div>

<p>不管性能，还是可用性来说，<code class="highlighter-rouge">Guava Cache</code>绝对是本地缓存类库中首要推荐的工具类。其提供的<code class="highlighter-rouge">Builder模式</code>的CacheBuilder生成器来创建缓存的方式，十分方便，并且各个缓存参数的配置设置，类似于函数式编程的写法，也特别棒。</p>

<p><code class="highlighter-rouge">Guava Cache</code>的官方文档地址：<a href="http://code.google.com/p/guava-libraries/wiki/CachesExplained">http://code.google.com/p/guava-libraries/wiki/CachesExplained</a>. 该文档对<code class="highlighter-rouge">Cache</code>有详细的介绍。
<br /></p>

<blockquote>
  <blockquote>
    <p>Tips：在官方文档中，提到三种方式加载<code class="highlighter-rouge">&lt;key,value&gt;</code>到缓存中。分别是:</p>

    <ol>
      <li>
        <p><code class="highlighter-rouge">LoadingCache</code>在构建缓存的时候，使用build方法内部调用<code class="highlighter-rouge">CacheLoader</code>方法加载数据；</p>
      </li>
      <li>
        <p>在使用get方法的时候，如果缓存不存在该key或者key过期等，则调用<code class="highlighter-rouge">get(K, Callable&lt;V&gt;)</code>方式加载数据；</p>
      </li>
      <li>
        <p>使用粗暴直接的方式，直接想缓存中put数据。</p>
      </li>
    </ol>

    <p>需要说明的是，如果不能通过key快速计算出value时，则还是不要在初始化的时候直接调用<code class="highlighter-rouge">CacheLoader</code>加载数据到缓存中。</p>
  </blockquote>
</blockquote>

<h3 id="21-guava-cache使用示例">2.1 Guava Cache使用示例</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">java.util.Date</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.Callable</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.TimeUnit</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.slf4j.Logger</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.slf4j.LoggerFactory</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.google.common.cache.Cache</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.common.cache.CacheBuilder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.common.cache.CacheLoader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.common.cache.LoadingCache</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.common.cache.RemovalListener</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.common.cache.RemovalNotification</span><span class="o">;</span>

<span class="cm">/**
 * @author tao.ke Date: 14-12-20 Time: 下午1:55
 * @version \$Id$
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CacheSample</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">CacheSample</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="c1">// Callable形式的Cache</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Cache</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">CALLABLE_CACHE</span> <span class="o">=</span> <span class="n">CacheBuilder</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
            <span class="o">.</span><span class="na">expireAfterWrite</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">).</span><span class="na">maximumSize</span><span class="o">(</span><span class="mi">1000</span><span class="o">).</span><span class="na">recordStats</span><span class="o">()</span>
            <span class="o">.</span><span class="na">removalListener</span><span class="o">(</span><span class="k">new</span> <span class="n">RemovalListener</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onRemoval</span><span class="o">(</span><span class="n">RemovalNotification</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">notification</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Remove a map entry which key is {},value is {},cause is {}."</span><span class="o">,</span> <span class="n">notification</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span>
                            <span class="n">notification</span><span class="o">.</span><span class="na">getValue</span><span class="o">(),</span> <span class="n">notification</span><span class="o">.</span><span class="na">getCause</span><span class="o">().</span><span class="na">name</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}).</span><span class="na">build</span><span class="o">();</span>

    <span class="c1">// CacheLoader形式的Cache</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">LoadingCache</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">LOADER_CACHE</span> <span class="o">=</span> <span class="n">CacheBuilder</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
            <span class="o">.</span><span class="na">expireAfterAccess</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">).</span><span class="na">maximumSize</span><span class="o">(</span><span class="mi">1000</span><span class="o">).</span><span class="na">recordStats</span><span class="o">().</span><span class="na">build</span><span class="o">(</span><span class="k">new</span> <span class="n">CacheLoader</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="n">String</span> <span class="nf">load</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="n">key</span> <span class="o">+</span> <span class="k">new</span> <span class="n">Date</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">});</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">times</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">times</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>

            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">900</span><span class="o">);</span>

            <span class="n">String</span> <span class="n">valueCallable</span> <span class="o">=</span> <span class="n">CALLABLE_CACHE</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"key"</span><span class="o">,</span> <span class="k">new</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="n">String</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="s">"key"</span> <span class="o">+</span> <span class="k">new</span> <span class="n">Date</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">});</span>

            <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Callable Cache -----&gt;&gt;&gt;&gt;&gt; key is {},value is {}"</span><span class="o">,</span> <span class="s">"key"</span><span class="o">,</span> <span class="n">valueCallable</span><span class="o">);</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Callable Cache -----&gt;&gt;&gt;&gt;&gt; stat miss:{},stat hit:{}"</span><span class="o">,</span><span class="n">CALLABLE_CACHE</span><span class="o">.</span><span class="na">stats</span><span class="o">().</span><span class="na">missRate</span><span class="o">(),</span><span class="n">CALLABLE_CACHE</span><span class="o">.</span><span class="na">stats</span><span class="o">().</span><span class="na">hitRate</span><span class="o">());</span>

            <span class="n">String</span> <span class="n">valueLoader</span> <span class="o">=</span> <span class="n">LOADER_CACHE</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"key"</span><span class="o">);</span>

            <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Loader Cache -----&gt;&gt;&gt;&gt;&gt; key is {},value is {}"</span><span class="o">,</span> <span class="s">"key"</span><span class="o">,</span> <span class="n">valueLoader</span><span class="o">);</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Loader Cache -----&gt;&gt;&gt;&gt;&gt; stat miss:{},stat hit:{}"</span><span class="o">,</span><span class="n">LOADER_CACHE</span><span class="o">.</span><span class="na">stats</span><span class="o">().</span><span class="na">missRate</span><span class="o">(),</span><span class="n">LOADER_CACHE</span><span class="o">.</span><span class="na">stats</span><span class="o">().</span><span class="na">hitRate</span><span class="o">());</span>

        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>上述代码，简单的介绍了<code class="highlighter-rouge">Guava Cache </code>的使用，给了两种加载构建Cache的方式。在<code class="highlighter-rouge">Guava Cache</code>对外提供的方法中， <code class="highlighter-rouge">recordStats</code>和<code class="highlighter-rouge">removalListener</code>是两个很有趣的接口，可以很好的帮我们完成统计功能和Entry移除引起的监听触发功能。</p>

    <p>此外，虽然在<code class="highlighter-rouge">Guava Cache</code>对外方法接口中提供了丰富的特性，但是如果我们在实际的代码中不是很有需要的话，建议不要设置这些属性，因为会额外占用内存并且会多一些处理计算工作，不值得。</p>

  </blockquote>
</blockquote>

<h2 id="guava-cache-分析前置知识"><a id="PrepareKnowledge">Guava Cache 分析前置知识</a></h2>

<p><code class="highlighter-rouge">Guava Cache</code>就是借鉴Java的<code class="highlighter-rouge">ConcurrentHashMap</code>的思想来实现一个本地缓存，但是它内部代码实现的时候，还是有很多非常精彩的设计实现，并且如果对<code class="highlighter-rouge">ConcurrentHashMap</code>内部具体实现不是很清楚的话，通过阅读<code class="highlighter-rouge">Cache</code>的实现，对<code class="highlighter-rouge">ConcurrentHashMap</code>的实现基本上会有个全面的了解。</p>

<h3 id="31-builder模式">3.1 Builder模式</h3>

<p>设计模式之 Builder模式 在Guava中很多地方得到的使用。<code class="highlighter-rouge">Builder模式</code>是将一个复杂对象的构造与其对应配置属性表示的分离，也就是可以使用基本相同的构造过程去创建不同的具体对象。</p>

<p>Builder模式典型的结构图如：</p>

<p><img src="/images/2014/12/builder.png" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Builder：为创建一个Product对象的各个部件制定抽象接口；

ConcreteBuilder：具体的建造者，它负责真正的生产；

Director：导演, 建造的执行者，它负责发布命令；

Product：最终消费的产品
</code></pre></div></div>

<p>各类之间的交互关系如下图：</p>

<p><img src="/images/2014/12/builder-relation.png" /></p>

<p><code class="highlighter-rouge">Builder模式</code>的关键是其中的Director对象并不直接返回对象，而是通过（BuildPartA，BuildPartB，BuildPartC）来一步步进行对象的创建。当然这里Director可以提供一个默认的返回对象的接口（即返回通用的复杂对象的创建，即不指定或者特定唯一指定BuildPart中的参数）。</p>

<blockquote>
  <blockquote>
    <p>Tips：在<code class="highlighter-rouge">Effective Java</code>第二版中，<code class="highlighter-rouge">Josh Bloch</code>在第二章中就提到使用Builder模式处理需要很多参数的构造函数。他不仅展示了Builder的使用，也描述了相这种方法相对使用带很多参数的构造函数带来的好处。</p>

  </blockquote>
</blockquote>

<p>下面给出一个使用Builder模式来构造对象，这种方式优点和不足（代码量增加）非常明显。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">org.apache.commons.lang3.builder.ToStringBuilder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.commons.lang3.builder.ToStringStyle</span><span class="o">;</span>

<span class="cm">/**
 * @author tao.ke Date: 14-12-22 Time: 下午8:57
 * @version \$Id$
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BuilderPattern</span> <span class="o">{</span>

    <span class="cm">/**
     * 姓名
     */</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="cm">/**
     * 年龄
     */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="cm">/**
     * 性别
     */</span>
    <span class="kd">private</span> <span class="n">Gender</span> <span class="n">gender</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">BuilderPattern</span> <span class="nf">newBuilder</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BuilderPattern</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">BuilderPattern</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">BuilderPattern</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">BuilderPattern</span> <span class="nf">setGender</span><span class="o">(</span><span class="n">Gender</span> <span class="n">gender</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">gender</span> <span class="o">=</span> <span class="n">gender</span><span class="o">;</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">ToStringBuilder</span><span class="o">.</span><span class="na">reflectionToString</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">ToStringStyle</span><span class="o">.</span><span class="na">SHORT_PREFIX_STYLE</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">enum</span> <span class="n">Gender</span> <span class="o">{</span>
        <span class="n">MALE</span><span class="o">,</span> <span class="n">FEMALE</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">BuilderPattern</span> <span class="n">bp</span> <span class="o">=</span> <span class="n">BuilderPattern</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">setAge</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="na">setName</span><span class="o">(</span><span class="s">"zhangsan"</span><span class="o">).</span><span class="na">setGender</span><span class="o">(</span><span class="n">Gender</span><span class="o">.</span><span class="na">FEMALE</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bp</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>

<h3 id="32-java对象引用">3.2 Java对象引用</h3>

<p>对象引用之前需要先看看对象的访问定位。</p>

<p>当虚拟机执行时，遇到一条new指令时，首先会去检查这个指令在常量池中是否已经存在该类对应的符号引用，并且检查这个符号引用对应的类是否已经被加载，解析和初始化。如果没有，则执行相应的类加载过程。</p>

<p>然后虚拟机为新的对象分配内存。虚拟机根据我们配置的垃圾收集器规则采取不同的分配方式，包括：指针碰撞分配方式和空闲列表分配方式。</p>

<p>内存分配完成之后，开始执行init方法。init方法会按照代码的指定过程来初始化，对一些类属性进行赋值。</p>

<p>然后，我们需要访问这个对象，怎么办？在Java运行时内存区域模型中，线程拥有一个虚拟机栈，这个栈会有一个本地方法表，这个表内部就会存放一个引用地址，如下图所示（HotSpot虚拟机采用这种方式，还有另外一种形式这里不做介绍）：</p>

<p><img src="/images/2014/12/reference.png" /></p>

<p>在JDK 1.2之前，Java中关于引用的定义是：如果reference类型的数据中存储的数值表示的是另外一块内存的起始地址，就说明这块内存称为引用。这种定义表明对象只有两种：被引用的对象和没有被引用的对象。这种方式对于垃圾收集GC来说，效果并不是很好，因为很多对象划为为被引用和非被引用都不是很重要，这种现象就无法划分。垃圾收集的时候，就无法更好更精准的划为可GC的对象。</p>

<p>因此，在JDK 1.2之后，Java对引用的概念进行扩展，有如下四种类型的引用（按强度排序）：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* 强引用(Strong Reference)

* 软引用(SoftReference)

* 弱引用(WeakReference)

* 虚引用(PhantomReference)
</code></pre></div></div>

<ol>
  <li>
    <p><em>强引用</em>：强引用在程序代码中随处可见，十分普遍。比如： <code class="highlighter-rouge">Object object = new Object()</code> ，这类引用只要还存在，垃圾收集器就永远不会回收掉这类引用的对象。</p>
  </li>
  <li>
    <p><em>软引用</em>：软引用用来描述一些虽然有用但是并不是必须的对象。对于软引用关联的对象，在系统将可能发生内存溢出异常之前，垃圾收集器将会把这些引用的对象进行第二次回收。只有这次垃圾回收还没有足够的内存的时候，才会抛出内存溢出异常。</p>
  </li>
  <li>
    <p><em>弱引用</em>：弱引用是一种比软引用强度还要弱的引用，因此这些引用的对象也是非必须的。但是，对于弱引用的对象只能生存到下一次垃圾回收发生之前。当垃圾收集工作开始后，无论当前的内存是否够用，都会把这些弱引用的对象回收掉。</p>
  </li>
  <li>
    <p><em>虚引用</em>：虚引用是最弱的一种引用。一个对象是否被虚引用关联，完全不会对其生存时间构成影响，也无法通过虚引用获得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p>
  </li>
</ol>

<blockquote>
  <blockquote>
    <p>Notes：关于引用，最典型的使用就是对HashMap的自定义开发，包括JDK内部也存在。</p>

    <ol>
      <li>
        <p><code class="highlighter-rouge">Strong Reference</code>—&gt; <code class="highlighter-rouge">HashMap</code>：默认情况下，HashMap使用的引用就是强引用，也就是说垃圾收集的时候，Map中引用的对象不会被GC掉。</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">Weak Reference</code>—&gt; <code class="highlighter-rouge">WeakHashMap</code>：JDK中还有一种基于引用类型实现的HashMap，WeakHashMap。当节点的key不在被使用的时候，该entry就会被自动回收掉。因此，对于一个mapping映射，不能保证接下来的GC不会把这个entry回收掉。</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">Soft Reference</code>—&gt; <code class="highlighter-rouge">SoftHashMap</code>：在JDK中没有提供基于软引用实现的HashMap，原因可能是一般大家都不能期待出现内存溢出，而当出现内存溢出，一点点的软引用GC余下的内存空间，肯定不会起到关键作用。但是，虽然不广泛，在<code class="highlighter-rouge">aspectj</code>提供的<code class="highlighter-rouge">ClassLoaderRepository</code>类中实现了SoftHashMap，作为一个基于ClassLoader字节码实现的方法，在OOM的时候，显然需要考虑通过GC释放内存空间，并且SoftHashMap在内部是作为缓存使用。</p>
      </li>
    </ol>
  </blockquote>
</blockquote>

<h3 id="33-jmm可见性">3.3 JMM可见性</h3>

<p>在<a href="http://ketao1989.github.io/posts/java-some-tips.html">Java一些小Tips</a>博文中，简单地介绍了JMM模型，但是Java内存模型涉及了大量的规则内容指令。</p>

<p><em>什么叫可见性？</em></p>

<p>可见性就是，当程序中一个线程修改了某个全局共享变量的值之后，其他使用该值的线程都可以获知，在随后他们读该共享变量的时候，查询的都是最新的改改修改的值。</p>

<p>在上一篇博文中，我们给出了内存模型访问的图。根据图可以了解，一个线程上修改共享变量，这个变量的最新的值不会立刻写入到共享内存中，还是暂时存放在线程本地缓存，然后某一时刻触发写入到共享内存中。可见性就是，当我们对共享变量修改的时候，立刻把新值同步到主内存中，然后该变量被读的时候从主内存获取最新的值确保所有对该变量的读取操作，总是获取最新最近修改的值。</p>

<p><em>为什么会有可见性问题？</em></p>

<p>学过计算机组成原理的同学都知道，在现代CPU结构中，存在多级缓存架构，如下图所示：</p>

<p><img src="/images/2014/12/cpu_cache.jpg" /></p>

<p>同样，在Java虚拟机中分为两种内存：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt; 主内存(Main Memory)：所有线程共享的内存区域，虚拟机内存的一部分。

&gt;&gt; 工作内存(Working Memory)：线程自己操作的内存区域，线程直接无法访问对方的工作内存区域。
</code></pre></div></div>

<p>之所以分为两部分内存区域，原因和CPU很类似。为了线程可以快速访问操作变量，当线程全部直接操作共享内存，则会导致大量线程之间竞争等问题出现，影响效率。</p>

<p>关于Java中线程，工作内存，主内存之间的交互关系如下图（深入理解Java虚拟机配图）：</p>

<p><img src="/images/2014/12/java_mmm.png" /></p>

<p>为了保证共享变量可见性，除了上篇博文中介绍的<code class="highlighter-rouge">volatile</code>之外，还有<code class="highlighter-rouge">synchronized</code>和<code class="highlighter-rouge">final</code>关键字。</p>

<p><em>synchronized</em>：执行synchronized代码块时，在对变量执行unlock操作之前，一定会把此变量写入到主内存中。<em>final</em>：该关键字修饰的变量在构造函数中初始化完成之后（不考虑指针逃逸，变量初始化一半的问题），其他线程就可以看到这个final变量的值，并且由于变量不能修改，所以能确保可见性。</p>

<blockquote>
  <blockquote>
    <p>Notes：<em>保证JMM可见性，并不代表确保变量的线程安全性！！！</em></p>

  </blockquote>
</blockquote>

<h3 id="34-指令重排序">3.4 指令重排序</h3>

<p>重排序通常是编译器或者运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：编译期重排序和运行期重排序，分别对应编译时和运行时环境。</p>

<p>编译期重排序主要的原因是CPU导致的。在编译期的微指令翻译阶段，许多操作同时执行，并且执行的顺序是乱序的，所以有可能出现一条指令读一个寄存器的同时，另外一条指令正在对这个寄存器进行写操作。此外，翻译之后，就是重排序缓存阶段。不同的微指令在不同的执行单元中同时执行，而且每个执行单元都全速运行。只要当前微指令所需要的数据就绪，而且有空闲的执行单元，微指令就可以立即执行，有时甚至可以跳过前面还未就绪的微指令。通过这种方式，需要长时间运行的操作不会阻塞后面的操作，流水线阻塞带来的损失被极大的减小了。</p>

<p>运行期JVM会对指令进行重排序以提高程序性能，当然其会通过<code class="highlighter-rouge">happens-before</code>原则保证顺序执行语义，也就是不会随便对代码指令进行重排序。</p>

<p>借用一个例子说明（来源<a href="http://www.infoq.com/cn/articles/java-memory-model-2">http://www.infoq.com/cn/articles/java-memory-model-2</a>）：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">class</span> <span class="nc">ReorderExample</span> <span class="o">{</span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">writer</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>                   <span class="c1">//1</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>             <span class="c1">//2</span>
<span class="o">}</span>

<span class="n">Public</span> <span class="kt">void</span> <span class="nf">reader</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">flag</span><span class="o">)</span> <span class="o">{</span>                <span class="c1">//3</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span>  <span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="o">;</span>        <span class="c1">//4</span>
        <span class="err">……</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>上述的代码会造成很多的不同结果，由于数据的可见性问题，或者就是重排序。比如重排序后执行顺序如下，则会存在问题。</p>

<p><img src="/images/2014/12/reorder.png" /></p>

<h3 id="35-锁细化">3.5 锁细化</h3>

<p><em>锁粒度细化，是所有保证线程安全的程序方法优化的必经之路</em>。</p>

<p>这两年十分火的用于线程间通信的高性能消息组件，其虽然有很多创新的设计，但是很多优化的基本就是，锁细化，包括核心数据结构 <code class="highlighter-rouge">Ringbuffer</code>。<a href="http://ifeve.com/dissecting-disruptor-whats-so-special/">剖析Disruptor:为什么会这么快？（一）Ringbuffer的特别之处</a></p>

<p>此外，在Linux内核2.6之后采用的RCU锁机制，本质上也是锁粒度细化。<a href="https://www.ibm.com/developerworks/cn/linux/l-rcu/">Linux 2.6内核中新的锁机制–RCU</a></p>

<p>在Java语言中，最经典的锁细化提高多线程并发性能的案例，就是<code class="highlighter-rouge">ConcurrentHashMap</code>，其采用多个<code class="highlighter-rouge">segment</code>，每个segment对应一个锁，来分散全局锁带来的性能损失。从而，当我们put某一个entry的时候，在实现的时候，一般只需要拥有某一个segment锁就可以完成。</p>

<p>关于普通的<code class="highlighter-rouge">HashTable</code>结构和<code class="highlighter-rouge">ConcurrentHashMap</code>结构，借用一张图来说明：</p>

<p><img src="/images/2014/12/currentHashMap.jpg" /></p>

<p>从结构上，可以很显而易见的看出两者的区别。所以，就锁这个层面上，concurrentHashMap就会比HashTable性能好。</p>

<h3 id="36-guava-listenablefuture接口">3.6 Guava ListenableFuture接口</h3>

<p>我们强烈地建议你在代码中多使用<code class="highlighter-rouge">ListenableFuture</code>来代替JDK的 Future, 因为：</p>

<ul>
  <li>
    <p>大多数Futures 方法中需要它。</p>
  </li>
  <li>
    <p>转到<code class="highlighter-rouge">ListenableFuture</code> 编程比较容易。</p>
  </li>
  <li>
    <p>Guava提供的通用公共类封装了公共的操作方方法，不需要提供Future和<code class="highlighter-rouge">ListenableFuture</code>的扩展方法。</p>
  </li>
</ul>

<p><em>创建ListenableFuture实例</em></p>

<p>首先需要创建<code class="highlighter-rouge">ListeningExecutorService</code>实例，Guava 提供了专门的方法把JDK中提供<code class="highlighter-rouge">ExecutorService</code>对象转换为<code class="highlighter-rouge">ListeningExecutorService</code>。然后通过submit方法就可以创建一个ListenableFuture实例了。</p>

<p>代码片段如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">ListeningExecutorService</span> <span class="n">service</span> <span class="o">=</span> <span class="n">MoreExecutors</span><span class="o">.</span><span class="na">listeningDecorator</span><span class="o">(</span><span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">10</span><span class="o">));</span>
<span class="n">ListenableFuture</span> <span class="n">explosion</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">Callable</span><span class="o">()</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Explosion</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">pushBigRedButton</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">});</span>
<span class="n">Futures</span><span class="o">.</span><span class="na">addCallback</span><span class="o">(</span><span class="n">explosion</span><span class="o">,</span> <span class="k">new</span> <span class="n">FutureCallback</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// we want this handler to run immediately after we push the big red button!</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">Explosion</span> <span class="n">explosion</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">walkAwayFrom</span><span class="o">(</span><span class="n">explosion</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFailure</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">thrown</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">battleArchNemesis</span><span class="o">();</span> <span class="c1">// escaped the explosion!</span>
  <span class="o">}</span>
<span class="o">});</span>

</code></pre></div></div>

<p>也就是说，对于异步的方法，我可以通过监听器来根据执行结果来判断接下来的处理行为。</p>

<p><em>ListenableFuture 链式操作</em></p>

<p>使用ListenableFuture 最重要的理由是它可以进行一系列的复杂链式的异步操作。</p>

<p>一般，使用AsyncFunction来完成链式异步操作。不同的操作可以在不同的Executors中执行，单独的ListenableFuture 可以有多个操作等待。</p>

<blockquote>
  <blockquote>

    <p>Tips:  AsyncFunction接口常被用于当我们想要异步的执行转换而不造成线程阻塞时，尽管Future.get()方法会在任务没有完成时造成阻塞，但是AsyncFunction接口并不被建议用来异步的执行转换，它常被用于返回Future实例。</p>

    <p>下面给出这个链式操作完成一个简单的异步字符串转换操作：</p>
  </blockquote>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">java.util.concurrent.Callable</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutorService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.Executors</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.google.common.util.concurrent.AsyncFunction</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.common.util.concurrent.FutureCallback</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.common.util.concurrent.Futures</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.common.util.concurrent.ListenableFuture</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.common.util.concurrent.ListeningExecutorService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.common.util.concurrent.MoreExecutors</span><span class="o">;</span>

<span class="cm">/**
 * @author tao.ke Date: 14-12-26 Time: 下午5:28
 * @version \$Id$
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ListenerFutureChain</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ListeningExecutorService</span> <span class="n">executorService</span> <span class="o">=</span> <span class="n">MoreExecutors</span><span class="o">.</span><span class="na">listeningDecorator</span><span class="o">(</span><span class="n">executor</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">executeChain</span><span class="o">()</span> <span class="o">{</span>

        <span class="n">AsyncFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">asyncFunction</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AsyncFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="n">ListenableFuture</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">apply</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
                <span class="n">ListenableFuture</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="n">String</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
                        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"STEP1 &gt;&gt;&gt;"</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
                        <span class="k">return</span> <span class="n">input</span> <span class="o">+</span> <span class="s">"|||step 1 ===--===||| "</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">});</span>

                <span class="k">return</span> <span class="n">future</span><span class="o">;</span>

            <span class="o">}</span>
        <span class="o">};</span>

        <span class="n">AsyncFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">asyncFunction2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AsyncFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="n">ListenableFuture</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">apply</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
                <span class="n">ListenableFuture</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="n">String</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
                        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"STEP2 &gt;&gt;&gt;"</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
                        <span class="k">return</span> <span class="n">input</span> <span class="o">+</span> <span class="s">"|||step 2 ===--===---||| "</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">});</span>

                <span class="k">return</span> <span class="n">future</span><span class="o">;</span>

            <span class="o">}</span>
        <span class="o">};</span>

        <span class="n">ListenableFuture</span> <span class="n">startFuture</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">Callable</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="n">Object</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"BEGIN &gt;&gt;&gt;"</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
                <span class="k">return</span> <span class="s">"BEGIN---&gt;"</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">ListenableFuture</span> <span class="n">future</span> <span class="o">=</span> <span class="n">Futures</span><span class="o">.</span><span class="na">transform</span><span class="o">(</span><span class="n">startFuture</span><span class="o">,</span> <span class="n">asyncFunction</span><span class="o">,</span> <span class="n">executor</span><span class="o">);</span>
        <span class="n">ListenableFuture</span> <span class="n">endFuture</span> <span class="o">=</span> <span class="n">Futures</span><span class="o">.</span><span class="na">transform</span><span class="o">(</span><span class="n">future</span><span class="o">,</span> <span class="n">asyncFunction2</span><span class="o">,</span> <span class="n">executor</span><span class="o">);</span>

        <span class="n">Futures</span><span class="o">.</span><span class="na">addCallback</span><span class="o">(</span><span class="n">endFuture</span><span class="o">,</span> <span class="k">new</span> <span class="n">FutureCallback</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">Object</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"=======OK======="</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFailure</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">t</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>

            <span class="o">}</span>
        <span class="o">});</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"========START======="</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MAIN &gt;&gt;&gt;"</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="n">ListenerFutureChain</span> <span class="n">chain</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListenerFutureChain</span><span class="o">();</span>
        <span class="n">chain</span><span class="o">.</span><span class="na">executeChain</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"========END======="</span><span class="o">);</span>

        <span class="n">executor</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
        <span class="c1">// System.exit(0);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>输出：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>========START=======
MAIN &gt;&gt;&gt;main
BEGIN &gt;&gt;&gt;pool-2-thread-1
========END=======
STEP1 &gt;&gt;&gt;pool-2-thread-2
STEP2 &gt;&gt;&gt;pool-2-thread-1
BEGIN---&gt;|||step 1 ===--===||| |||step 2 ===--===---||| 
=======OK=======
</code></pre></div></div>

<p>从输出可以看出，代码是异步完成字符串操作的。</p>

<h2 id="cachebuilder实现"><a id="CacheBuilder">CacheBuilder实现</a></h2>

<p>写过Cache的，或者其他一些工具类的同学知道，为了让工具类更灵活，我们需要对外提供大量的参数配置给使用者设置，虽然这带有一些好处，但是由于参数太多，使用者开发构造对象的时候过于繁杂。</p>

<p>上面提到过参数配置过多，可以使用Builder模式。Guava Cache也一样，它为我们提供了CacheBuilder工具类来构造不同配置的Cache实例。但是，和本文上面提到的构造器实现有点不一样，它构造器返回的是另外一个对象，因此，这意味着在实现的时候，对象构造函数需要有Builder参数提供配置属性。</p>

<h3 id="41-cachebuilder构造localcache实现">4.1 CacheBuilder构造LocalCache实现</h3>

<p>首先，我们先看看Cache的构造函数：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/**
 * 从builder中获取相应的配置参数。 
 */</span>

<span class="n">LocalCache</span><span class="o">(</span><span class="n">CacheBuilder</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">builder</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="n">CacheLoader</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">loader</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">concurrencyLevel</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">getConcurrencyLevel</span><span class="o">(),</span> <span class="n">MAX_SEGMENTS</span><span class="o">);</span>

    <span class="n">keyStrength</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">getKeyStrength</span><span class="o">();</span>
    <span class="n">valueStrength</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">getValueStrength</span><span class="o">();</span>

    <span class="n">keyEquivalence</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">getKeyEquivalence</span><span class="o">();</span>
    <span class="n">valueEquivalence</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">getValueEquivalence</span><span class="o">();</span>

    <span class="n">maxWeight</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">getMaximumWeight</span><span class="o">();</span>
    <span class="n">weigher</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">getWeigher</span><span class="o">();</span>
    <span class="n">expireAfterAccessNanos</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">getExpireAfterAccessNanos</span><span class="o">();</span>
    <span class="n">expireAfterWriteNanos</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">getExpireAfterWriteNanos</span><span class="o">();</span>
    <span class="n">refreshNanos</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">getRefreshNanos</span><span class="o">();</span>

    <span class="n">removalListener</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">getRemovalListener</span><span class="o">();</span>
    <span class="n">removalNotificationQueue</span> <span class="o">=</span> <span class="o">(</span><span class="n">removalListener</span> <span class="o">==</span> <span class="n">NullListener</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">)</span> <span class="o">?</span> <span class="n">LocalCache</span>
                <span class="o">.&lt;</span><span class="n">RemovalNotification</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="nf">discardingQueue</span><span class="o">()</span> <span class="o">:</span> <span class="k">new</span> <span class="n">ConcurrentLinkedQueue</span><span class="o">&lt;</span><span class="n">RemovalNotification</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;&gt;();</span>

    <span class="n">ticker</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">getTicker</span><span class="o">(</span><span class="n">recordsTime</span><span class="o">());</span>
    <span class="n">entryFactory</span> <span class="o">=</span> <span class="n">EntryFactory</span><span class="o">.</span><span class="na">getFactory</span><span class="o">(</span><span class="n">keyStrength</span><span class="o">,</span> <span class="n">usesAccessEntries</span><span class="o">(),</span> <span class="n">usesWriteEntries</span><span class="o">());</span>
    <span class="n">globalStatsCounter</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">getStatsCounterSupplier</span><span class="o">().</span><span class="na">get</span><span class="o">();</span>
    <span class="n">defaultLoader</span> <span class="o">=</span> <span class="n">loader</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">getInitialCapacity</span><span class="o">(),</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">evictsBySize</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">customWeigher</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">maxWeight</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//.......</span>
<span class="o">}</span>

</code></pre></div></div>

<p>从构造函数可以看到，Cache的所有参数配置都是从Builder对象中获取的，Builder完成了作为该模式最典型的应用，多配置参数构建对象。</p>

<p>在Cache中只提供一个构造函数，但是在上面代码示例中，我们演示了两种构建缓存的方式：自动加载；手动加载。那么，一般会存在一个完成两者之间的过渡<code class="highlighter-rouge">adapter</code>组件，接下来看看Builder在内部是如何完成创建缓存对象过程的。</p>

<p>OK，你猜到了。在<code class="highlighter-rouge">LocalCache</code>中确实提供了两种过渡类，一个是支持自动加载value的<code class="highlighter-rouge">LocalLoadingCache</code> 和只能在键值找不到的时候手动调用获取值方法的<code class="highlighter-rouge">LocalManualCache</code>。</p>

<p><em>LocalManualCache实现</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">LocalManualCache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Cache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;,</span> <span class="n">Serializable</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">LocalCache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">localCache</span><span class="o">;</span>

        <span class="n">LocalManualCache</span><span class="o">(</span><span class="n">CacheBuilder</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">(</span><span class="k">new</span> <span class="n">LocalCache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;(</span><span class="n">builder</span><span class="o">,</span> <span class="kc">null</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="kd">private</span> <span class="nf">LocalManualCache</span><span class="o">(</span><span class="n">LocalCache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">localCache</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">localCache</span> <span class="o">=</span> <span class="n">localCache</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Cache methods</span>

        <span class="nd">@Override</span>
        <span class="nd">@Nullable</span>
        <span class="kd">public</span> <span class="n">V</span> <span class="nf">getIfPresent</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">localCache</span><span class="o">.</span><span class="na">getIfPresent</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">V</span> <span class="nf">get</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="kd">final</span> <span class="n">Callable</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">valueLoader</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ExecutionException</span> <span class="o">{</span>
            <span class="n">checkNotNull</span><span class="o">(</span><span class="n">valueLoader</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">localCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="k">new</span> <span class="n">CacheLoader</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="n">V</span> <span class="nf">load</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="n">valueLoader</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">});</span>
        <span class="o">}</span>

        <span class="c1">//......</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">CacheStats</span> <span class="nf">stats</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">SimpleStatsCounter</span> <span class="n">aggregator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleStatsCounter</span><span class="o">();</span>
            <span class="n">aggregator</span><span class="o">.</span><span class="na">incrementBy</span><span class="o">(</span><span class="n">localCache</span><span class="o">.</span><span class="na">globalStatsCounter</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">segment</span> <span class="o">:</span> <span class="n">localCache</span><span class="o">.</span><span class="na">segments</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">aggregator</span><span class="o">.</span><span class="na">incrementBy</span><span class="o">(</span><span class="n">segment</span><span class="o">.</span><span class="na">statsCounter</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">aggregator</span><span class="o">.</span><span class="na">snapshot</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// Serialization Support</span>

        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="n">Object</span> <span class="nf">writeReplace</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">ManualSerializationProxy</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;(</span><span class="n">localCache</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

</code></pre></div></div>

<p>从代码实现看出实际上是一个adapter组件，并且绝大部分实现都是直接调用LocalCache的方法，或者加一些参数判断和聚合。在它核心的构造函数中，就是直接调用LocalCache构造函数，对于loader对象直接设null值。</p>

<p><em>LocalLoadingCache实现</em></p>

<p><code class="highlighter-rouge">LocalLoadingCache</code>实现继承了``类，其主要对get相关方法做了重写。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">static</span> <span class="kd">class</span> <span class="nc">LocalLoadingCache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">LocalManualCache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">LoadingCache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>

        <span class="n">LocalLoadingCache</span><span class="o">(</span><span class="n">CacheBuilder</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">builder</span><span class="o">,</span> <span class="n">CacheLoader</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">loader</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="k">new</span> <span class="n">LocalCache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;(</span><span class="n">builder</span><span class="o">,</span> <span class="n">checkNotNull</span><span class="o">(</span><span class="n">loader</span><span class="o">)));</span>
        <span class="o">}</span>

        <span class="c1">// LoadingCache methods</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">V</span> <span class="nf">get</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ExecutionException</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">localCache</span><span class="o">.</span><span class="na">getOrLoad</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">V</span> <span class="nf">getUnchecked</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExecutionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">UncheckedExecutionException</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCause</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">ImmutableMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">getAll</span><span class="o">(</span><span class="n">Iterable</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">keys</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ExecutionException</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">localCache</span><span class="o">.</span><span class="na">getAll</span><span class="o">(</span><span class="n">keys</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">refresh</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">localCache</span><span class="o">.</span><span class="na">refresh</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kd">final</span> <span class="n">V</span> <span class="nf">apply</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">getUnchecked</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Serialization Support</span>

        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="nd">@Override</span>
        <span class="n">Object</span> <span class="nf">writeReplace</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">LoadingSerializationProxy</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;(</span><span class="n">localCache</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>提供了这些adapter类之后，builder类就可以创建<code class="highlighter-rouge">LocalCache</code>，如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
    <span class="c1">// 获取value可以通过key计算出</span>
   <span class="kd">public</span> <span class="o">&lt;</span><span class="n">K1</span> <span class="kd">extends</span> <span class="n">K</span><span class="o">,</span> <span class="n">V1</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">LoadingCache</span><span class="o">&lt;</span><span class="n">K1</span><span class="o">,</span> <span class="n">V1</span><span class="o">&gt;</span> <span class="nf">build</span><span class="o">(</span><span class="n">CacheLoader</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">K1</span><span class="o">,</span> <span class="n">V1</span><span class="o">&gt;</span> <span class="n">loader</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">checkWeightWithWeigher</span><span class="o">();</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">LocalCache</span><span class="o">.</span><span class="na">LocalLoadingCache</span><span class="o">&lt;</span><span class="n">K1</span><span class="o">,</span> <span class="n">V1</span><span class="o">&gt;(</span><span class="k">this</span><span class="o">,</span> <span class="n">loader</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 手动加载</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">K1</span> <span class="kd">extends</span> <span class="n">K</span><span class="o">,</span> <span class="n">V1</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Cache</span><span class="o">&lt;</span><span class="n">K1</span><span class="o">,</span> <span class="n">V1</span><span class="o">&gt;</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">checkWeightWithWeigher</span><span class="o">();</span>
        <span class="n">checkNonLoadingCache</span><span class="o">();</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">LocalCache</span><span class="o">.</span><span class="na">LocalManualCache</span><span class="o">&lt;</span><span class="n">K1</span><span class="o">,</span> <span class="n">V1</span><span class="o">&gt;(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>

</code></pre></div></div>

<h3 id="42-cachebuilder参数设置">4.2 CacheBuilder参数设置</h3>

<p><code class="highlighter-rouge">CacheBuilder</code>在为我们提供了构造一个Cache对象时，会构造各个成员对象的初始值（默认值）。了解这些默认值，对于我们分析Cache源码实现时，一些判断条件的设置原因，还是很有用的。</p>

<p><em>初始参数值设置</em></p>

<p>在<code class="highlighter-rouge">ConcurrentHashMap</code>中，我们知道有个并发水平（CONCURRENCY_LEVEL），这个参数决定了其允许多少个线程并发操作修改该数据结构。这是因为这个参数是最后map使用的segment个数，而每个segment对应一个锁，因此，对于一个map来说，并发环境下，理论上最大可以有segment个数的线程同时安全地操作修改数据结构。那么是不是segment的值可以设置很大呢？显然不是，要记住维护一个锁的成本还是挺高的，此外如果涉及全表操作，那么性能就会非常不好了。</p>

<p>其他一些初始参数值的设置如下所示：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span> <span class="c1">// 默认的初始化Map大小</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_CONCURRENCY_LEVEL</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span> <span class="c1">// 默认并发水平</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_EXPIRATION_NANOS</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 默认超时</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_REFRESH_NANOS</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 默认刷新时间</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">UNSET_INT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">strictParsing</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">UNSET_INT</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">concurrencyLevel</span> <span class="o">=</span> <span class="n">UNSET_INT</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">maximumSize</span> <span class="o">=</span> <span class="n">UNSET_INT</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">maximumWeight</span> <span class="o">=</span> <span class="n">UNSET_INT</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">expireAfterWriteNanos</span> <span class="o">=</span> <span class="n">UNSET_INT</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">expireAfterAccessNanos</span> <span class="o">=</span> <span class="n">UNSET_INT</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">refreshNanos</span> <span class="o">=</span> <span class="n">UNSET_INT</span><span class="o">;</span>


</code></pre></div></div>

<p><em>初始对象引用设置</em></p>

<p>在Cache中，我们除了超时时间，键值引用属性等设置外，还关注命中统计情况，这就需要统计对象来工作。CacheBuilder提供了初始的null 统计对象和空统计对象。</p>

<p>此外，还会设置到默认的引用类型等设置，代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
     * 默认空的缓存命中统计类
     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Supplier</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">StatsCounter</span><span class="o">&gt;</span> <span class="n">NULL_STATS_COUNTER</span> <span class="o">=</span> <span class="n">Suppliers</span><span class="o">.</span><span class="na">ofInstance</span><span class="o">(</span><span class="k">new</span> <span class="n">StatsCounter</span><span class="o">()</span> <span class="o">{</span>
        
        <span class="c1">//......省略空override</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">CacheStats</span> <span class="nf">snapshot</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">EMPTY_STATS</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">});</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">CacheStats</span> <span class="n">EMPTY_STATS</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CacheStats</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span><span class="c1">// 初始状态的统计对象</span>

    <span class="cm">/**
     * 系统实现的简单的缓存状态统计类
     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">StatsCounter</span><span class="o">&gt;</span> <span class="n">CACHE_STATS_COUNTER</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">StatsCounter</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">StatsCounter</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">SimpleStatsCounter</span><span class="o">();</span><span class="c1">//这里构造简单地统计类实现</span>
        <span class="o">}</span>
    <span class="o">};</span>

    <span class="cm">/**
     * 自定义的空RemovalListener，监听到移除通知，默认空处理。
     */</span>
    <span class="kd">enum</span> <span class="n">NullListener</span> <span class="kd">implements</span> <span class="n">RemovalListener</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="n">INSTANCE</span><span class="o">;</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onRemoval</span><span class="o">(</span><span class="n">RemovalNotification</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">notification</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 默认权重类，任何对象的权重均为1
     */</span>
    <span class="kd">enum</span> <span class="n">OneWeigher</span> <span class="kd">implements</span> <span class="n">Weigher</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="n">INSTANCE</span><span class="o">;</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">weigh</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Ticker</span> <span class="n">NULL_TICKER</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Ticker</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">long</span> <span class="nf">read</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">};</span>

    <span class="cm">/**
     * 默认的key等同判断
     * @return
     */</span>
    <span class="n">Equivalence</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="nf">getKeyEquivalence</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">firstNonNull</span><span class="o">(</span><span class="n">keyEquivalence</span><span class="o">,</span> <span class="n">getKeyStrength</span><span class="o">().</span><span class="na">defaultEquivalence</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 默认value的等同判断
     * @return
     */</span>
    <span class="n">Equivalence</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="nf">getValueEquivalence</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">firstNonNull</span><span class="o">(</span><span class="n">valueEquivalence</span><span class="o">,</span> <span class="n">getValueStrength</span><span class="o">().</span><span class="na">defaultEquivalence</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 默认的key引用
     * @return
     */</span>
    <span class="n">Strength</span> <span class="nf">getKeyStrength</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">firstNonNull</span><span class="o">(</span><span class="n">keyStrength</span><span class="o">,</span> <span class="n">Strength</span><span class="o">.</span><span class="na">STRONG</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 默认为Strong 属性的引用
     * @return
     */</span>
    <span class="n">Strength</span> <span class="nf">getValueStrength</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">firstNonNull</span><span class="o">(</span><span class="n">valueStrength</span><span class="o">,</span> <span class="n">Strength</span><span class="o">.</span><span class="na">STRONG</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="o">&lt;</span><span class="n">K1</span> <span class="kd">extends</span> <span class="n">K</span><span class="o">,</span> <span class="n">V1</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Weigher</span><span class="o">&lt;</span><span class="n">K1</span><span class="o">,</span> <span class="n">V1</span><span class="o">&gt;</span> <span class="nf">getWeigher</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">Weigher</span><span class="o">&lt;</span><span class="n">K1</span><span class="o">,</span> <span class="n">V1</span><span class="o">&gt;)</span> <span class="n">Objects</span><span class="o">.</span><span class="na">firstNonNull</span><span class="o">(</span><span class="n">weigher</span><span class="o">,</span> <span class="n">OneWeigher</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>
    <span class="o">}</span>

</code></pre></div></div>

<p>其中，在我们不设置缓存中键值引用的情况下，默认都是采用强引用及相对应的属性策略来初始化的。此外，在上面代码中还可以看到，统计类<code class="highlighter-rouge">SimpleStatsCounter</code>是一个简单的实现。里面主要是简单地缓存累加，此外由于多线程下Long类型的线程非安全性，所以也进行了一下封装，下面给出命中率的实现：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">SimpleStatsCounter</span> <span class="kd">implements</span> <span class="n">StatsCounter</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">LongAddable</span> <span class="n">hitCount</span> <span class="o">=</span> <span class="n">LongAddables</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">LongAddable</span> <span class="n">missCount</span> <span class="o">=</span> <span class="n">LongAddables</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">LongAddable</span> <span class="n">loadSuccessCount</span> <span class="o">=</span> <span class="n">LongAddables</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">LongAddable</span> <span class="n">loadExceptionCount</span> <span class="o">=</span> <span class="n">LongAddables</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">LongAddable</span> <span class="n">totalLoadTime</span> <span class="o">=</span> <span class="n">LongAddables</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">LongAddable</span> <span class="n">evictionCount</span> <span class="o">=</span> <span class="n">LongAddables</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>

    <span class="kd">public</span> <span class="nf">SimpleStatsCounter</span><span class="o">()</span> <span class="o">{}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">recordHits</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">hitCount</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">CacheStats</span> <span class="nf">snapshot</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">CacheStats</span><span class="o">(</span>
          <span class="n">hitCount</span><span class="o">.</span><span class="na">sum</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Increments all counters by the values in {@code other}.
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">incrementBy</span><span class="o">(</span><span class="n">StatsCounter</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">CacheStats</span> <span class="n">otherStats</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="na">snapshot</span><span class="o">();</span>
      <span class="n">hitCount</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">otherStats</span><span class="o">.</span><span class="na">hitCount</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>因此，CacheBuilder的一些参数对象等得初始化就完成了。可以看到这些默认的初始化，有两套引用：Null对象和Empty对象，显然Null会更省空间，但我们在创建的时候将决定不使用某特性的时候，就会使用Null来创建，否则使用Empty来完成初始化工作。在分析Cache的时候，写后超时队列和读后超时队列也存在两个版本。</p>

<h2 id="localcache实现"><a id="LocalCache">LocalCache实现</a></h2>

<p>在设计实现上，<code class="highlighter-rouge">LocalCache</code>的并发策略和<code class="highlighter-rouge">concurrentHashMap</code>的并发策略是一致的，也是根据分段锁来提高并发能力,分段锁可以很好的保证 并发读写的效率。因此，该map支持非阻塞读和不同段之间并发写。</p>

<p>如果最大的大小指定了，那么基于段来执行操作是最好的。使用页面替换算法来决定当map大小超过指定值时，哪些entries需要被驱赶出去。页面替换算法的数据结构保证Map临时一致性：对一个segment写排序是一致的；但是对map进行更新和读不能直接立刻 反应在数据结构上。 虽然这些数据结构被lock锁保护，但是其结构决定了批量操作可以避免锁竞争出现。在线程之间传播的批量操作导致分摊成本比不强制大小限制的操作要稍微高一点。</p>

<p>此外，<code class="highlighter-rouge">LoacalCache</code>使用LRU页面替换算法，是因为该算法简单，并且有很高的命中率，以及O(1)的时间复杂度。需要说明的是， LRU算法是基于页面而不是全局实现的，所以可能在命中率上不如全局LRU算法，但是应该基本相似。</p>

<p>最后，要说明一点，在代码实现上，页面其实就是一个段segment。之所以说page页，是因为在计算机专业课程上，CPU，操作系统，算法上，基本上都介绍过分页导致优化效果的提升。</p>

<h3 id="51-总体数据结构">5.1 总体数据结构</h3>

<p><code class="highlighter-rouge">LocalCache</code>的数据结构和<code class="highlighter-rouge">ConcurrentHashMap</code>一样，都是采用分segment来细化管理HashMap中的节点Entry。借用<code class="highlighter-rouge">ConcurrentHashMap</code>的数据结构图来说明Cache的实现：</p>

<p><img src="/images/2014/12/segement.jpg" height="300" width="600" /></p>

<p>从图中可以直观看到cache是以segment粒度来控制并发get和put等操作的，接下来首先看我们的<code class="highlighter-rouge">LocalCache</code>是如何构造这些segment段的，继续上面初始化localCache构造函数的代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="c1">// 找到大于并发水平的最小2的次方的值，作为segment数量</span>
        <span class="kt">int</span> <span class="n">segmentShift</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">segmentCount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">segmentCount</span> <span class="o">&lt;</span> <span class="n">concurrencyLevel</span> <span class="o">&amp;&amp;</span> <span class="o">(!</span><span class="n">evictsBySize</span><span class="o">()</span> <span class="o">||</span> <span class="n">segmentCount</span> <span class="o">*</span> <span class="mi">20</span> <span class="o">&lt;=</span> <span class="n">maxWeight</span><span class="o">))</span> <span class="o">{</span>
            <span class="o">++</span><span class="n">segmentShift</span><span class="o">;</span>
            <span class="n">segmentCount</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">segmentShift</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">segmentShift</span><span class="o">;</span><span class="c1">//位 偏移数</span>
        <span class="n">segmentMask</span> <span class="o">=</span> <span class="n">segmentCount</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span><span class="c1">//mask码</span>

        <span class="k">this</span><span class="o">.</span><span class="na">segments</span> <span class="o">=</span> <span class="n">newSegmentArray</span><span class="o">(</span><span class="n">segmentCount</span><span class="o">);</span><span class="c1">// 构造数据数组，如上图所示</span>
        <span class="c1">//获取每个segment初始化容量，并且保证大于等于map初始容量</span>
        <span class="kt">int</span> <span class="n">segmentCapacity</span> <span class="o">=</span> <span class="n">initialCapacity</span> <span class="o">/</span> <span class="n">segmentCount</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">segmentCapacity</span> <span class="o">*</span> <span class="n">segmentCount</span> <span class="o">&lt;</span> <span class="n">initialCapacity</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">++</span><span class="n">segmentCapacity</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//段Size 必须为2的次数，并且刚刚大于段初始容量</span>
        <span class="kt">int</span> <span class="n">segmentSize</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">segmentSize</span> <span class="o">&lt;</span> <span class="n">segmentCapacity</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">segmentSize</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 权重设置，确保权重和==map权重</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">evictsBySize</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Ensure sum of segment max weights = overall max weights</span>
            <span class="kt">long</span> <span class="n">maxSegmentWeight</span> <span class="o">=</span> <span class="n">maxWeight</span> <span class="o">/</span> <span class="n">segmentCount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="kt">long</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">maxWeight</span> <span class="o">%</span> <span class="n">segmentCount</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">segments</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">remainder</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">maxSegmentWeight</span><span class="o">--;</span>
                <span class="o">}</span>
                <span class="c1">//构造每个段结构</span>
                <span class="k">this</span><span class="o">.</span><span class="na">segments</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">createSegment</span><span class="o">(</span><span class="n">segmentSize</span><span class="o">,</span> <span class="n">maxSegmentWeight</span><span class="o">,</span> <span class="n">builder</span><span class="o">.</span><span class="na">getStatsCounterSupplier</span><span class="o">().</span><span class="na">get</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">segments</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//构造每个段结构</span>
                <span class="k">this</span><span class="o">.</span><span class="na">segments</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">createSegment</span><span class="o">(</span><span class="n">segmentSize</span><span class="o">,</span> <span class="n">UNSET_INT</span><span class="o">,</span> <span class="n">builder</span><span class="o">.</span><span class="na">getStatsCounterSupplier</span><span class="o">().</span><span class="na">get</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>Notes：基本上都是基于2的次数来设置大小的，显然基于移位操作比普通计算操作速度要快。此外，对于最大权重分配到段权重的设计上，很特殊。为什么呢？为了保证两者能够相等（maxWeight==sumAll(maxSegmentWeight)）,对于remainder前面的segment maxSegmentWeight的值比remainder后面的权重值大1，这样保证最后值相等。</p>

  </blockquote>
</blockquote>

<p><em>map get 方法</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="nd">@Override</span>
    <span class="nd">@Nullable</span>
    <span class="kd">public</span> <span class="n">V</span> <span class="nf">get</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">segmentFor</span><span class="o">(</span><span class="n">hash</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
    <span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>Notes：代码很简单，首先check key是否为null，然后计算hash值，定位到对应的segment，执行segment实例拥有的get方法获取对应的value值</p>

  </blockquote>
</blockquote>

<p><em>map put 方法</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">V</span> <span class="nf">put</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">checkNotNull</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="n">checkNotNull</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">segmentFor</span><span class="o">(</span><span class="n">hash</span><span class="o">).</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>Notes：和get方法一样，也是先check值，然后计算key的hash值，然后定位到对应的segment段，执行段实例的put方法，将键值存入map中。</p>

  </blockquote>
</blockquote>

<p><em>map isEmpty 方法</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0L</span><span class="o">;</span>
        <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;[]</span> <span class="n">segments</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">segments</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">segments</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">segments</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">segments</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">modCount</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">!=</span> <span class="mi">0L</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// recheck unless no modifications</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">segments</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">segments</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">sum</span> <span class="o">-=</span> <span class="n">segments</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">modCount</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">!=</span> <span class="mi">0L</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>Notes：判断Cache是否为空，就是分别判断每个段segment是否都为空，但是由于整体是在并发环境下进行的，也就是说存在对一个segment并发的增加和移除元素的时候，而我们此时正在check其他segment段。</p>

    <p>上面这种情况，决定了我们不能够获得任何一个时间点真实段状态的情况。因此，上面的代码引入了sum变量来计算段modCount变更情况。modCount表示改变segment大小size的更新次数，这个在批量读取方法期间保证它们可以看到一致性的快照。<code class="highlighter-rouge">需要注意，这里先获取count，该值是volatile，因此modCount通常都可以在不需要一致性控制下，获得当前segment最新的值.</code></p>

    <p>在判断如果在第一次check的时候，发现segment发生了数据结构级别变更，则会进行recheck，就是在每个modCount下，段仍然是空的，则判断该map为空。如果发现这期间数据结构发生变化，则返回非空判断。</p>

  </blockquote>
</blockquote>

<p><em>map 其他方法</em></p>

<p>在Cache数据结构中，还有很多方法，和上面列出来的方法一样，其底层核心实现都是依赖segment类实例中实现的对应方法。</p>

<p>此外，在总的数据结构中，还提供了一些根据builder配制制定相应地缓存策略方法。比如：</p>

<ul>
  <li>expiresAfterAccess：是否执行访问后超时过期策略；</li>
  <li>expiresAfterWrite：是否执行写后超时过期策略；</li>
  <li>usesAccessQueue：根据上面的配置决定是否需要new一个访问队列；</li>
  <li>usesWriteQueue：根据上面的配置决定是否需要new一个写队列；</li>
  <li>usesKeyReferences/usesValueReferences：是否需要使用特别的引用策略(非Strong引用).</li>
  <li>等等……</li>
</ul>

<h3 id="52-引用数据结构">5.2 引用数据结构</h3>

<p>在介绍Segment数据结构之前，先讲讲Cache中引用的设计。</p>

<p>关于Reference引用的一些说明，在博文的上面已经介绍了，这里就不赘述。在Guava Cache 中，主要使用三种引用类型，分别是：<code class="highlighter-rouge">STRONG引用</code>，<code class="highlighter-rouge">SOFT引用</code> ，<code class="highlighter-rouge">WEAK引用</code>。和Map不同，在Cache中，使用<code class="highlighter-rouge">ReferenceEntry</code>来封装键值对，并且对于值来说，还额外实现了<code class="highlighter-rouge">ValueReference</code>引用对象来封装对应Value对象。</p>

<p><em>ReferenceEntry节点结构</em></p>

<p>为了支持各种不同类型的引用，以及不同过期策略，这里构造了一个ReferenceEntry节点结构。通过下面的节点数据结构，可以清晰的看到缓存大致操作流程。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/**
     * 引用map中一个entry节点。
     *
     * 在map中得entries节点有下面几种状态：
     * valid：-live：设置了有效的key/value;-loading：加载正在处理中....
     * invalid：-expired：时间过期(但是key/value可能仍然设置了)；Collected：key/value部分被垃圾收集了，但是还没有被清除；
     * -unset：标记为unset，表示等待清除或者重新使用。
     *
     */</span>
    <span class="kd">interface</span> <span class="nc">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="cm">/**
         * 从entry中返回value引用
         */</span>
        <span class="n">ValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">getValueReference</span><span class="o">();</span>

        <span class="cm">/**
         * 为entry设置value引用
         */</span>
        <span class="kt">void</span> <span class="nf">setValueReference</span><span class="o">(</span><span class="n">ValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">valueReference</span><span class="o">);</span>

        <span class="cm">/**
         * 返回链中下一个entry（解决hash碰撞存在链表）
         */</span>
        <span class="nd">@Nullable</span>
        <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">getNext</span><span class="o">();</span>

        <span class="cm">/**
         * 返回entry的hash
         */</span>
        <span class="kt">int</span> <span class="nf">getHash</span><span class="o">();</span>

        <span class="cm">/**
         * 返回entry的key
         */</span>
        <span class="nd">@Nullable</span>
        <span class="n">K</span> <span class="nf">getKey</span><span class="o">();</span>

        <span class="cm">/*
         * Used by entries that use access order. Access entries are maintained in a doubly-linked list. New entries are
         * added at the tail of the list at write time; stale entries are expired from the head of the list.
         */</span>

        <span class="cm">/**
         * 返回该entry最近一次被访问的时间ns
         */</span>
        <span class="kt">long</span> <span class="nf">getAccessTime</span><span class="o">();</span>

        <span class="cm">/**
         * 设置entry访问时间ns.
         */</span>
        <span class="kt">void</span> <span class="nf">setAccessTime</span><span class="o">(</span><span class="kt">long</span> <span class="n">time</span><span class="o">);</span>

        <span class="cm">/**
         * 返回访问队列中下一个entry
         */</span>
        <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">getNextInAccessQueue</span><span class="o">();</span>

        <span class="cm">/**
         * Sets the next entry in the access queue.
         */</span>
        <span class="kt">void</span> <span class="nf">setNextInAccessQueue</span><span class="o">(</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">);</span>

        <span class="cm">/**
         * Returns the previous entry in the access queue.
         */</span>
        <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">getPreviousInAccessQueue</span><span class="o">();</span>

        <span class="cm">/**
         * Sets the previous entry in the access queue.
         */</span>
        <span class="kt">void</span> <span class="nf">setPreviousInAccessQueue</span><span class="o">(</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">previous</span><span class="o">);</span>

        <span class="c1">// ...... 省略write队列相关方法，和access一样</span>
    <span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>Notes：从上面代码可以看到除了和Map一样，有key、value、hash和next四个属性之外，还有访问和写更新两个双向链表队列，以及entry的最近访问时间和最近更新时间。显然，多出来的属性就是为了支持缓存必须要有的过期机制。</p>

    <p>此外，从上面的代码可以看出<em>cache支持的LRU机制实际上是建立在segment上的，也就是基于页的替换机制。</em></p>

    <p>关于访问队列数据结构，其实质就是一个双向的链表。当节点被访问的时候，这个节点将会移除，然后把这个节点添加到链表的结尾。关于具体实现，将在segment中介绍。</p>

    <p>创建不同类型的ReferenceEntry由其枚举工厂类EntryFactory来实现，它根据key的Strength类型、是否使用accessQueue、是否使用writeQueue来决定不同的EntryFactry实例，并通过它创建相应的ReferenceEntry实例</p>
  </blockquote>
</blockquote>

<p><em>ValueReference结构</em></p>

<p>同样为了支持Cache中各个不同类型的引用，其对Value类型进行再封装，支持引用。看看其内部数据属性：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="cm">/**
     * A reference to a value.
     */</span>
    <span class="kd">interface</span> <span class="nc">ValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="cm">/**
         * Returns the value. Does not block or throw exceptions.
         */</span>
        <span class="nd">@Nullable</span>
        <span class="n">V</span> <span class="nf">get</span><span class="o">();</span>

        <span class="cm">/**
         * Waits for a value that may still be loading. Unlike get(), this method can block (in the case of
         * FutureValueReference).
         * 
         * @throws ExecutionException if the loading thread throws an exception
         * @throws ExecutionError if the loading thread throws an error
         */</span>
        <span class="n">V</span> <span class="nf">waitForValue</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ExecutionException</span><span class="o">;</span>

        <span class="cm">/**
         * Returns the weight of this entry. This is assumed to be static between calls to setValue.
         */</span>
        <span class="kt">int</span> <span class="nf">getWeight</span><span class="o">();</span>

        <span class="cm">/**
         * Returns the entry associated with this value reference, or {@code null} if this value reference is
         * independent of any entry.
         */</span>
        <span class="nd">@Nullable</span>
        <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">getEntry</span><span class="o">();</span>

        <span class="cm">/**
         * 为一个指定的entry创建一个该引用的副本
         * &lt;p&gt;
         * {@code value} may be null only for a loading reference.
         */</span>
        <span class="n">ValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">copyFor</span><span class="o">(</span><span class="n">ReferenceQueue</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">entry</span><span class="o">);</span>

        <span class="cm">/**
         * 告知一个新的值正在加载中。这个只会关联到加载值引用。
         */</span>
        <span class="kt">void</span> <span class="nf">notifyNewValue</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="n">V</span> <span class="n">newValue</span><span class="o">);</span>

        <span class="cm">/**
         * 当一个新的value正在被加载的时候，返回true。不管是否已经有存在的值。这里加锁方法返回的值对于给定的ValueReference实例来说是常量。
         * 
         */</span>
        <span class="kt">boolean</span> <span class="nf">isLoading</span><span class="o">();</span>

        <span class="cm">/**
         * 返回true，如果该reference包含一个活跃的值,意味着在cache里仍然有一个值存在。活跃的值包含：cache查找返回的，等待被移除的要被驱赶的值； 非激活的包含：正在加载的值，
         */</span>
        <span class="kt">boolean</span> <span class="nf">isActive</span><span class="o">();</span>
    <span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>Notes：value引用接口对象中包含了不同状态的标记，以及一些加载方法和获取具体value值对象。</p>

    <p>为了减少不必须的load加载，在value引用中增加了loading标识和wait方法等待加载获取值。这样，就可以等待上一个调用loader方法获取值，而不是重复去调用loader方法加重系统负担，而且可以更快的获取对应的值。</p>

    <p>此外，介绍下<code class="highlighter-rouge">ReferenceQueue</code>引用队列，这个队列是JDK提供的，在检测到适当的可到达性更改后，垃圾回收器将已注册的引用对象添加到该队列中。因为Cache使用了各种引用，而通过ReferenceQueue这个“监听器”就可以优雅的实现自动删除那些引用不可达的key了，是不是很吊，哈哈。</p>

    <p>在Cache分别实现了基于Strong,Soft，Weak三种形式的ValueReference实现。</p>

    <p>这里ValueReference之所以要有对ReferenceEntry的引用是因为在Value因为WeakReference、SoftReference被回收时，需要使用其key将对应的项从Segment段中移除；
copyFor()函数的存在是因为在expand(rehash)重新创建节点时，对WeakReference、SoftReference需要重新创建实例（C++中的深度复制思想，就是为了保持对象状态不会相互影响），而对强引用来说，直接使用原来的值即可，这里很好的展示了对彼变化的封装思想；
notifiyNewValue只用于LoadingValueReference，它的存在是为了对LoadingValueReference来说能更加及时的得到CacheLoader加载的值。</p>
  </blockquote>
</blockquote>

<h3 id="53-segment-数据结构">5.3 Segment 数据结构</h3>

<p><code class="highlighter-rouge">Segment</code>数据结构，是ConcurrentHashMap的核心实现，也是该结构保证了其算法的高效性。在<code class="highlighter-rouge">Guava Cache</code> 中也一样，<code class="highlighter-rouge">segment</code>数据结构保证了缓存在线程安全的前提下可以高效地更新，插入，获取对应value。</p>

<p>实际上，segment就是一个特殊版本的hash table实现。其内部也是对应一个锁，不同的是，对于get和put操作做了一些优化处理。因此，在代码实现的时候，为了快速开发和利用已有锁特性，直接<code class="highlighter-rouge">extends ReentrantLock</code>。</p>

<p>在segment中，其主要的类属性就是一个<code class="highlighter-rouge">LoacalCache</code>类型的map变量。关于segment实现说明，如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
        <span class="cm">/**
         * segments 维护一个entry列表的table，确保一致性状态。所以可以不加锁去读。节点的next field是不可修改的final，因为所有list的增加操作
         * 是执行在每个容器的头部。因此，这样子很容易去检查变化，也可以快速遍历。此外，当节点被改变的时候，新的节点将被创建然后替换它们。 由于容器的list一般都比较短（平均长度小于2），所以对于hash
         * tables来说，可以工作的很好。虽然说读操作因此可以不需要锁进行，但是是依赖
         * 使用volatile确保其他线程完成写操作。对于绝大多数目的而言，count变量，跟踪元素的数量，其作为一个volatile变量确保可见性（其内部原理可以参考其他相关博文）。
         * 这样一下子变得方便的很多，因为这个变量在很多读操作的时候都会被获取：所有非同步的（unsynchronized）读操作必须首先读取这个count值，并且如果count为0则不会 查找table
         * 的entries元素；所有的同步（synchronized）操作必须在结构性的改变任务bin容器之后，才会写操作这个count值。
         * 这些操作必须在并发读操作看到不一致的数据的时候，不采取任务动作。在map中读操作性质可以更容易实现这个限制。例如：没有操作可以显示出 当table
         * 增长了，但是threshold值没有更新，所以考虑读的时候不要求原子性。作为一个原则，所有危险的volatile读和写count变量都必须在代码中标记。
         */</span>

        <span class="kd">final</span> <span class="n">LocalCache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">;</span>

        <span class="cm">/**
         * 该segment区域内所有存活的元素个数
         */</span>
        <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>

        <span class="cm">/**
         * 改变table大小size的更新次数。这个在批量读取方法期间保证它们可以看到一致性的快照：
         * 如果modCount在我们遍历段加载大小或者核对containsValue期间被改变了，然后我们会看到一个不一致的状态视图，以至于必须去重试。
         * count+modCount 保证内存一致性
         * 
         * 感觉这里有点像是版本控制，比如数据库里的version字段来控制数据一致性
         */</span>
        <span class="kt">int</span> <span class="n">modCount</span><span class="o">;</span>

        <span class="cm">/**
         * 每个段表，使用乐观锁的Array来保存entry The per-segment table.
         */</span>
        <span class="kd">volatile</span> <span class="n">AtomicReferenceArray</span><span class="o">&lt;</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">table</span><span class="o">;</span> <span class="c1">// 这里和concurrentHashMap不一致，原因是这边元素是引用，直接使用不会线程安全</span>
        <span class="cm">/**
         * A queue of elements currently in the map, ordered by write time. Elements are added to the tail of the queue
         * on write.
         */</span>
        <span class="nd">@GuardedBy</span><span class="o">(</span><span class="s">"Segment.this"</span><span class="o">)</span>
        <span class="kd">final</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">writeQueue</span><span class="o">;</span>

        <span class="cm">/**
         * A queue of elements currently in the map, ordered by access time. Elements are added to the tail of the queue
         * on access (note that writes count as accesses).
         */</span>
        <span class="nd">@GuardedBy</span><span class="o">(</span><span class="s">"Segment.this"</span><span class="o">)</span>
        <span class="kd">final</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">accessQueue</span><span class="o">;</span>
</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>Notes：</p>

    <p>在segment实现中，很多地方使用count变量和modCount变量来保持线程安全，从而省掉lock开销。</p>

    <p>在本文上面的图中说明了每个segment就是一个节点table，和jdk实现不一致，这里为了GC，内部维护的是一个<code class="highlighter-rouge">AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt;</code>类型的列表，可以保证安全性。</p>

    <p>最后，<code class="highlighter-rouge">LocalCache</code>作为一个缓存，其必须具有访问和写超时特性，因为其内部维护了访问队列和写队列，队列中的元素按照访问或者写时间排序，新的元素会被添加到队列尾部。如果，在队列中已经存在了该元素，则会先delete掉，然后再尾部add该节点，新的时间。这也就是为什么，对于<code class="highlighter-rouge">LocalCache</code>而言，其LRU是针对segment的，而不是全Cache范围的。</p>

  </blockquote>
</blockquote>

<p>在本文的 5.2节中知道，cache会根据初始化实例时配置来创建多个segment（<code class="highlighter-rouge">createSegment</code>），然后该方法最终调用segment类的构造函数创建一个段。对于参数set，就不展示，看看构造方法中其主要操作：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 构造函数</span>
    <span class="n">Segment</span><span class="o">(</span><span class="n">LocalCache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">,</span> <span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span> <span class="kt">long</span> <span class="n">maxSegmentWeight</span><span class="o">,</span> <span class="n">StatsCounter</span> <span class="n">statsCounter</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">initTable</span><span class="o">(</span><span class="n">newEntryArray</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="n">AtomicReferenceArray</span><span class="o">&lt;</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="nf">newEntryArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">AtomicReferenceArray</span><span class="o">&lt;</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;&gt;(</span><span class="n">size</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">initTable</span><span class="o">(</span><span class="n">AtomicReferenceArray</span><span class="o">&lt;</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">newTable</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">threshold</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span><span class="o">;</span> <span class="c1">// 0.75</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">customWeigher</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">threshold</span> <span class="o">==</span> <span class="n">maxSegmentWeight</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// prevent spurious expansion before eviction</span>
            <span class="k">this</span><span class="o">.</span><span class="na">threshold</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">table</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>OK，这里我们已经构造好了整个localCache对象了，包括其内部每个segment中对应的节点表。这些节点table，决定了最后所有核心操作的具体实现和操作结果。</p>

<p>接下来，需要看看最核心的几个方法。</p>

<blockquote>
  <blockquote>
    <p>Tips：本文把这几个方法单独作为几节来说明，这也表示这几个方法的重要性。</p>
  </blockquote>
</blockquote>

<h3 id="54-get方法实现">5.4 GET方法实现</h3>

<p>首先，如果我们从一个列表中查找对象，怎么做？</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 列表元素个数是否为0；

2. 如果非0，则依次查询列表中元素是否是我们的对象。
</code></pre></div></div>

<p>然后，如果是考虑超时策略的缓存呢？</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 缓存列表元素个数是否为0；

2. 如果非0，则依次查询列表中元素是否是我们的对象；

3. 查看队列中该对象是否已过期，如果过期则考虑其他方式获取。

4. 此外，为了线程安全，必须在获取的时候，锁住表不让更新缓存操作。
</code></pre></div></div>

<p>接下来是，<code class="highlighter-rouge">LocalCache</code>的缓存应该怎么做？</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 缓存中元素个数volatile count是否为0；

2. 如果非0，则获取我们需要的对象引用【getEntry(key, hash)】；

3. 如果对象引用不为null,则获取对应的value值；

4. 如果value已经过期或者无效，则判断是否在Loading【scheduleRefresh(e, key, hash, value, now, loader)】,否则，判断是否到了refresh时间;

5. 如果设置refresh，则异步刷新查询value，然后等待返回最新value【scheduleRefresh(e, key, hash, value, now, loader)】;

6. ok，这里如果value还没有拿到，则查询loader方法获取对应的值(存在加锁)【lockedGetOrLoad(key, hash, loader)】。
</code></pre></div></div>

<p>上面就是get方法的主要流程，对于其中一些核心的方法进行分析解析：</p>

<p><em>getEntry方法</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
        <span class="nd">@Nullable</span>
        <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">getEntry</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// hash链表</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">getFirst</span><span class="o">(</span><span class="n">hash</span><span class="o">);</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getNext</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getHash</span><span class="o">()</span> <span class="o">!=</span> <span class="n">hash</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// hash值相同的，接下来找key值也相同的ReferenceEntry</span>
                <span class="n">K</span> <span class="n">entryKey</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">entryKey</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">tryDrainReferenceQueues</span><span class="o">();</span><span class="c1">//线程安全的清除搜集到的entries，使用lock机制。</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">keyEquivalence</span><span class="o">.</span><span class="na">equivalent</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">entryKey</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * AtomicReferenceArray 可以确保原子的更新引用的元素。
         * 
         * 为给定的hash值返回第一个entry节点.
         */</span>
        <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">getFirst</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">)</span> <span class="o">{</span>

            <span class="c1">// 复制到线程安全的数组中，形成一个快照，确保读的时候，数据一致性。只会读取这个域一次。</span>
            <span class="c1">// 此外，这样子可以提供读对于整个table的影响，因为全局的table并不会锁住。（猜测）</span>
            <span class="n">AtomicReferenceArray</span><span class="o">&lt;</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">table</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">table</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>Notes：上面从缓存中直接获取key对应value，是完全没有加锁来完成的。</p>
  </blockquote>
</blockquote>

<p><em>scheduleRefresh方法</em></p>

<p>如果配置refresh特性，到了配置的刷新间隔时间，而且节点也没有正在加载，则应该进行refresh操作。refresh操作比较复杂。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
         * 刷新和key关联的value值，除非另一个线程正在做这个。如果在内部刷新了，则返回和key关联的value，否则如果另一个线程正在
         * 刷新或者出现error则返回null
         */</span>
        <span class="nd">@Nullable</span>
        <span class="n">V</span> <span class="nf">refresh</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">CacheLoader</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">loader</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">checkTime</span><span class="o">)</span> <span class="o">{</span>
            
            <span class="c1">// loadingValueReference表明当前线程开始加载，获取key对于的value引用。</span>
            <span class="kd">final</span> <span class="n">LoadingValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">loadingValueReference</span> <span class="o">=</span> <span class="n">insertLoadingValueReference</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">checkTime</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">loadingValueReference</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 如果说本线程启动加载，则开始异步调用，等待future返回get获取一个监听listenableFuture（见本文准备知识部分介绍），然后等待返回value值。loader相关方法随后介绍</span>
            <span class="n">ListenableFuture</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">loadAsync</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">loadingValueReference</span><span class="o">,</span> <span class="n">loader</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">isDone</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="n">Uninterruptibles</span><span class="o">.</span><span class="na">getUninterruptibly</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// don't let refresh exceptions propagate; error was already logged</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 返回一个本线程新插入的LoadingValueReference对象，或者如果一个活跃的value引用已经被加载了，则返回null
         */</span>
        <span class="nd">@Nullable</span>
        <span class="n">LoadingValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">insertLoadingValueReference</span><span class="o">(</span><span class="kd">final</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">checkTime</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="c1">// 加锁，保证只有一个线程对segment refresh操作</span>
            <span class="n">lock</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">ticker</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
                <span class="n">preWriteCleanup</span><span class="o">(</span><span class="n">now</span><span class="o">);</span>

                <span class="c1">// 快照保证</span>
                <span class="n">AtomicReferenceArray</span><span class="o">&lt;</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">table</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>

                <span class="c1">// 查找一个存在的entry节点，和上面的getEntry方法基本一致。</span>
                <span class="k">for</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getNext</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">K</span> <span class="n">entryKey</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getHash</span><span class="o">()</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="n">entryKey</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">.</span><span class="na">keyEquivalence</span><span class="o">.</span><span class="na">equivalent</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">entryKey</span><span class="o">))</span> <span class="o">{</span>
                        <span class="c1">// 如果存在我们想要的节点</span>
                        <span class="n">ValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">valueReference</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getValueReference</span><span class="o">();</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">valueReference</span><span class="o">.</span><span class="na">isLoading</span><span class="o">()</span> <span class="o">||</span> <span class="o">(</span><span class="n">checkTime</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">e</span><span class="o">.</span><span class="na">getWriteTime</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">map</span><span class="o">.</span><span class="na">refreshNanos</span><span class="o">)))</span> <span class="o">{</span>
                            <span class="c1">// 如果loading正在处理，并且发现该节点引用的写时间未超期刷新周期，则返回null</span>
                            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="o">}</span>

                        <span class="c1">// continue returning old value while loading</span>
                        <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
                        <span class="n">LoadingValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">loadingValueReference</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LoadingValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;(</span>
                                <span class="n">valueReference</span><span class="o">);</span><span class="c1">//使用老的值引用</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">setValueReference</span><span class="o">(</span><span class="n">loadingValueReference</span><span class="o">);</span>
                        <span class="k">return</span> <span class="n">loadingValueReference</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
                <span class="n">LoadingValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">loadingValueReference</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LoadingValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;();</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">newEntry</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">first</span><span class="o">);</span><span class="c1">//一个新的节点，存放的hash链头部</span>
                <span class="n">e</span><span class="o">.</span><span class="na">setValueReference</span><span class="o">(</span><span class="n">loadingValueReference</span><span class="o">);</span>
                <span class="n">table</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">index</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span><span class="c1">// 插入到列表中</span>
                <span class="k">return</span> <span class="n">loadingValueReference</span><span class="o">;</span><span class="c1">//返回新的值引用</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">unlock</span><span class="o">();</span>
                <span class="n">postWriteCleanup</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></div></div>

<p><em>lockedGetOrLoad方法</em></p>

<p>如方法名所见，该方法是加锁加载key对应的值引用。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
 <span class="cm">/**
         * 这里开始从我们实现cacheLoader继承类中的load方法获取 key对应的值。
         * 
         * 加锁get或者load
         */</span>
        <span class="n">V</span> <span class="nf">lockedGetOrLoad</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">CacheLoader</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">loader</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ExecutionException</span> <span class="o">{</span>
            <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
            <span class="n">ValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">valueReference</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">LoadingValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">loadingValueReference</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="kt">boolean</span> <span class="n">createNewEntry</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

            <span class="c1">// 确保线程安全，使用加锁来确保加载。当然这个也是针对segment粒度来加的</span>
            <span class="n">lock</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">// re-read ticker once inside the lock</span>
                <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">ticker</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
                <span class="n">preWriteCleanup</span><span class="o">(</span><span class="n">now</span><span class="o">);</span><span class="c1">// 加锁清GC遗留引用数据和超时数据</span>

                <span class="kt">int</span> <span class="n">newCount</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">AtomicReferenceArray</span><span class="o">&lt;</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">table</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span><span class="c1">// 根据hash和table长度来确定index索引</span>
                <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>

                <span class="k">for</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getNext</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">K</span> <span class="n">entryKey</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getHash</span><span class="o">()</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="n">entryKey</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">.</span><span class="na">keyEquivalence</span><span class="o">.</span><span class="na">equivalent</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">entryKey</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">valueReference</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getValueReference</span><span class="o">();</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">valueReference</span><span class="o">.</span><span class="na">isLoading</span><span class="o">())</span> <span class="o">{</span>
                            <span class="n">createNewEntry</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span><span class="c1">// 如果正在加载，则返回false，表示不需要新建entry</span>
                        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                            <span class="c1">// 对value进行判断处理，</span>
                            <span class="n">V</span> <span class="n">value</span> <span class="o">=</span> <span class="n">valueReference</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="c1">// 相关通知操作，GC原因回收了</span>
                                <span class="n">enqueueNotification</span><span class="o">(</span><span class="n">entryKey</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">valueReference</span><span class="o">,</span> <span class="n">RemovalCause</span><span class="o">.</span><span class="na">COLLECTED</span><span class="o">);</span>
                            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">isExpired</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">now</span><span class="o">))</span> <span class="o">{</span>
                                <span class="c1">// This is a duplicate check, as preWriteCleanup already purged expired</span>
                                <span class="c1">// entries, but let's accomodate an incorrect expiration queue.</span>
                                <span class="n">enqueueNotification</span><span class="o">(</span><span class="n">entryKey</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">valueReference</span><span class="o">,</span> <span class="n">RemovalCause</span><span class="o">.</span><span class="na">EXPIRED</span><span class="o">);</span>
                            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                                <span class="c1">// cache存在value，命中缓存</span>
                                <span class="n">recordLockedRead</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">now</span><span class="o">);</span>
                                <span class="n">statsCounter</span><span class="o">.</span><span class="na">recordHits</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
                                <span class="c1">// we were concurrent with loading; don't consider refresh</span>
                                <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
                            <span class="o">}</span>

                            <span class="c1">// 最后写count，保证前面的变量操作，对内存立刻可见</span>
                            <span class="n">writeQueue</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
                            <span class="n">accessQueue</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
                            <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">newCount</span><span class="o">;</span> <span class="c1">// write-volatile</span>
                        <span class="o">}</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="c1">// 处理需要新增entry，从load方法获取的逻辑</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">createNewEntry</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">loadingValueReference</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LoadingValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;();</span>

                    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">newEntry</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">first</span><span class="o">);</span><span class="c1">// segment神马都没有的时候，新建一个</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">setValueReference</span><span class="o">(</span><span class="n">loadingValueReference</span><span class="o">);</span>
                        <span class="n">table</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">index</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">setValueReference</span><span class="o">(</span><span class="n">loadingValueReference</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">unlock</span><span class="o">();</span>
                <span class="n">postWriteCleanup</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="c1">// ok,上面加锁部分建完了新的entry，设置完valueReference</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">createNewEntry</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>

                    <span class="c1">// 在entry同步，但检测到递归load则会快速失败。当entry被copy时候可能绕行，但是绝大部分时间会快速失败</span>
                    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">return</span> <span class="nf">loadSync</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">loadingValueReference</span><span class="o">,</span> <span class="n">loader</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    <span class="n">statsCounter</span><span class="o">.</span><span class="na">recordMisses</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span><span class="c1">// 处理命中率</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// 如果正在加载，则等待加载完成</span>
                <span class="c1">// The entry already exists. Wait for loading.</span>
                <span class="k">return</span> <span class="nf">waitForLoadingValue</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">valueReference</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>Tips：不管是lockget还是refresh，最后都会调用不同的load方法，只不过refresh使用<code class="highlighter-rouge">loadingFuture.addListener</code>方式来异步加载值而已。其最后都会调用<code class="highlighter-rouge">getAndRecordStats</code>方法。</p>

  </blockquote>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">V</span> <span class="nf">getAndRecordStats</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">LoadingValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">loadingValueReference</span><span class="o">,</span>
                <span class="n">ListenableFuture</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">newValue</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ExecutionException</span> <span class="o">{</span>
            <span class="n">V</span> <span class="n">value</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">getUninterruptibly</span><span class="o">(</span><span class="n">newValue</span><span class="o">);</span><span class="c1">// 非中断方式调用future.get方法获取值</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidCacheLoadException</span><span class="o">(</span><span class="s">"CacheLoader returned null for key "</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s">"."</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">statsCounter</span><span class="o">.</span><span class="na">recordLoadSuccess</span><span class="o">(</span><span class="n">loadingValueReference</span><span class="o">.</span><span class="na">elapsedNanos</span><span class="o">());</span>
                <span class="c1">//线程安全地把key和value存放到cache中。</span>
                <span class="n">storeLoadedValue</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">loadingValueReference</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
                <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">statsCounter</span><span class="o">.</span><span class="na">recordLoadException</span><span class="o">(</span><span class="n">loadingValueReference</span><span class="o">.</span><span class="na">elapsedNanos</span><span class="o">());</span>
                    <span class="n">removeLoadingValue</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">loadingValueReference</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>Notes：上面代码会调用storeLoadedValue方法,这个方法和后面的put方法实现很相似.如下:</p>

  </blockquote>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="cm">/**
         * 首先，这里是线程安全的。把key和value存放到cache中。
         */</span>
        <span class="kt">boolean</span> <span class="nf">storeLoadedValue</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">LoadingValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">oldValueReference</span><span class="o">,</span> <span class="n">V</span> <span class="n">newValue</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">ticker</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
                <span class="n">preWriteCleanup</span><span class="o">(</span><span class="n">now</span><span class="o">);</span><span class="c1">// clean工作</span>

                <span class="kt">int</span> <span class="n">newCount</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">newCount</span> <span class="o">&gt;</span> <span class="k">this</span><span class="o">.</span><span class="na">threshold</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 保证大小够用ensure capacity</span>
                    <span class="n">expand</span><span class="o">();</span>
                    <span class="n">newCount</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span><span class="c1">// 扩容之后，count可能会变化</span>
                <span class="o">}</span>

                <span class="n">AtomicReferenceArray</span><span class="o">&lt;</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">table</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>

                <span class="c1">// 如果当前segment中已经存在了该key元素</span>
                <span class="k">for</span> <span class="o">(</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getNext</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">K</span> <span class="n">entryKey</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
                    <span class="c1">// 找到hash链中对应的相等节点,则add操作;但是如果value是活跃的,则先移除</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getHash</span><span class="o">()</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="n">entryKey</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">.</span><span class="na">keyEquivalence</span><span class="o">.</span><span class="na">equivalent</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">entryKey</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">ValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">valueReference</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getValueReference</span><span class="o">();</span>
                        <span class="n">V</span> <span class="n">entryValue</span> <span class="o">=</span> <span class="n">valueReference</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>

                        <span class="c1">// 实现就有value引用的情况下</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">oldValueReference</span> <span class="o">==</span> <span class="n">valueReference</span> <span class="o">||</span> <span class="o">(</span><span class="n">entryValue</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">valueReference</span> <span class="o">!=</span> <span class="n">UNSET</span><span class="o">))</span> <span class="o">{</span>
                            <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
                            <span class="c1">// 首先如果value引用活跃,则让放入等待GC回收队列中,等待被回收.</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">oldValueReference</span><span class="o">.</span><span class="na">isActive</span><span class="o">())</span> <span class="o">{</span>
                                <span class="n">RemovalCause</span> <span class="n">cause</span> <span class="o">=</span> <span class="o">(</span><span class="n">entryValue</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">RemovalCause</span><span class="o">.</span><span class="na">COLLECTED</span>
                                        <span class="o">:</span> <span class="n">RemovalCause</span><span class="o">.</span><span class="na">REPLACED</span><span class="o">;</span>
                                <span class="c1">// 如果监听类配置了,则这里会触发监听方法响应</span>
                                <span class="n">enqueueNotification</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">oldValueReference</span><span class="o">,</span> <span class="n">cause</span><span class="o">);</span>
                                <span class="n">newCount</span><span class="o">--;</span>
                            <span class="o">}</span>
                            <span class="c1">// 更新新的值引用,如上所述,如果有老值,不直接删除,让GC回收.</span>
                            <span class="c1">// 这里会操作访问队列和写队列,还有其他对外的抽象监听方法调用等</span>
                            <span class="n">setValue</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">newValue</span><span class="o">,</span> <span class="n">now</span><span class="o">);</span>
                            <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">newCount</span><span class="o">;</span> <span class="c1">// write-volatile,确保modCount能及时写入共享内存中</span>
                            <span class="n">evictEntries</span><span class="o">();</span><span class="c1">// 移除操作,put方法也调用.</span>
                            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="o">}</span>

                        <span class="c1">//那如果value引用已经没有了呢?!也就是value引用已经被回收了,而不只是value值为null</span>
                        <span class="c1">// 新建一个value引用就好了呀?为什么返回false呢???</span>
                        <span class="n">valueReference</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WeightedStrongValueReference</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;(</span><span class="n">newValue</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
                        <span class="n">enqueueNotification</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">valueReference</span><span class="o">,</span> <span class="n">RemovalCause</span><span class="o">.</span><span class="na">REPLACED</span><span class="o">);</span>
                        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="c1">// 如果事先segment数组中没有该key,则新建一个节点entry</span>
                <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
                <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">newEntry</span> <span class="o">=</span> <span class="n">newEntry</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">first</span><span class="o">);</span>
                <span class="n">setValue</span><span class="o">(</span><span class="n">newEntry</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">newValue</span><span class="o">,</span> <span class="n">now</span><span class="o">);</span>
                <span class="n">table</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">index</span><span class="o">,</span> <span class="n">newEntry</span><span class="o">);</span>
                <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">newCount</span><span class="o">;</span> <span class="c1">// write-volatile</span>
                <span class="n">evictEntries</span><span class="o">();</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">unlock</span><span class="o">();</span>
                <span class="n">postWriteCleanup</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></div></div>

<h3 id="55-put方法实现">5.5 PUT方法实现</h3>

<p>和 get方法相比，put方法则相对而言，简单了很多，直接上<code class="highlighter-rouge">Guava LocalCache</code>的实现。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 加锁，对于更新操作，是需要加锁来确保线程安全的。

2. put操作，所以需要确保当前的空间，足够存放；否则需要扩容【expand】

3. 查看当前cache中是否已经存在该对象对应的key；
3.1. 如果存在，则更新相关的value，并且更新相关的时间参数；
3.2. 如果不存在，则创建一个新entry，然后放入table数组中。

4. 在上面的一些步骤中，还涉及到移除一些参数。【evictEntries】.当我们put操作的时候, 对于map的segment容量就可能会有变更,这样子就需要调用evict方法,决定是否需要采取移除多余的元素.
</code></pre></div></div>

<p><em>expand方法</em></p>

<p>扩展table的大小空间。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
        <span class="cm">/**
         * 如果需要并且没到限制大小，则扩展表table。
         *
         */</span>
        <span class="nd">@GuardedBy</span><span class="o">(</span><span class="s">"Segment.this"</span><span class="o">)</span>
        <span class="kt">void</span> <span class="nf">expand</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">AtomicReferenceArray</span><span class="o">&lt;</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">oldTable</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span><span class="c1">// 原子引用</span>
            <span class="kt">int</span> <span class="n">oldCapacity</span> <span class="o">=</span> <span class="n">oldTable</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">oldCapacity</span> <span class="o">&gt;=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">{</span><span class="c1">// 无法扩容</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="cm">/**
             * 把每个list的nodes分类到新的map中。 因为我们这里使用的是2的指数次扩容，所以在每个bin的元素，要么还是同样的index中待着，
             * 要么移到2的指数个偏移。我们排除了不必要的节点创建（可以优化场景：因为老的节点们下一个fields不会被改变，所以老的节点可以被重复使用）。
             *
             * 以默认域设置来统计，当我们双倍扩展table时，仅仅只有六分之一的节点需要clone。这些节点将会被GC掉， 在他们不在被任务reader线程（这些线程可能正遍历在table的中间部分）引用的时候。
             *
             */</span>

            <span class="kt">int</span> <span class="n">newCount</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
            <span class="n">AtomicReferenceArray</span><span class="o">&lt;</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">newTable</span> <span class="o">=</span> <span class="n">newEntryArray</span><span class="o">(</span><span class="n">oldCapacity</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">newMask</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">oldIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">oldIndex</span> <span class="o">&lt;</span> <span class="n">oldCapacity</span><span class="o">;</span> <span class="o">++</span><span class="n">oldIndex</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 我们必须保证任务对老Map的正在进行的读操作可以处理，所以我们不能每个bin设置null</span>
                <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">head</span> <span class="o">=</span> <span class="n">oldTable</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">oldIndex</span><span class="o">);</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">getNext</span><span class="o">();</span>
                    <span class="kt">int</span> <span class="n">headIndex</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">getHash</span><span class="o">()</span> <span class="o">&amp;</span> <span class="n">newMask</span><span class="o">;</span>

                    <span class="c1">// hash链只有一个节点的情况</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">newTable</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">headIndex</span><span class="o">,</span> <span class="n">head</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        
                        <span class="c1">// 这里可以重复使用链表，如注释所述，2的倍数扩展，很多引用hash值还是一样，所以把链表头直接set过去就可以了</span>
                        <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
                        <span class="kt">int</span> <span class="n">tailIndex</span> <span class="o">=</span> <span class="n">headIndex</span><span class="o">;</span>
                        <span class="k">for</span> <span class="o">(</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getNext</span><span class="o">())</span> <span class="o">{</span>
                            <span class="kt">int</span> <span class="n">newIndex</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getHash</span><span class="o">()</span> <span class="o">&amp;</span> <span class="n">newMask</span><span class="o">;</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">newIndex</span> <span class="o">!=</span> <span class="n">tailIndex</span><span class="o">)</span> <span class="o">{</span>
                                <span class="c1">// 如果hash更变了，则引用改变。将需要复制前面的节点</span>
                                <span class="n">tailIndex</span> <span class="o">=</span> <span class="n">newIndex</span><span class="o">;</span>
                                <span class="n">tail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                        <span class="n">newTable</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">tailIndex</span><span class="o">,</span> <span class="n">tail</span><span class="o">);</span>

                        <span class="c1">// Clone nodes leading up to the tail.</span>
                        <span class="k">for</span> <span class="o">(</span><span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">tail</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getNext</span><span class="o">())</span> <span class="o">{</span>
                            <span class="kt">int</span> <span class="n">newIndex</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getHash</span><span class="o">()</span> <span class="o">&amp;</span> <span class="n">newMask</span><span class="o">;</span>
                            <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">newNext</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">newIndex</span><span class="o">);</span>
                            <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">newFirst</span> <span class="o">=</span> <span class="n">copyEntry</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">newNext</span><span class="o">);</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">newFirst</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="c1">// 设置新位置的节点链表</span>
                                <span class="n">newTable</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">newIndex</span><span class="o">,</span> <span class="n">newFirst</span><span class="o">);</span>
                            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                                <span class="c1">// 移除节点相关操作</span>
                                <span class="n">removeCollectedEntry</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
                                <span class="n">newCount</span><span class="o">--;</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">newCount</span><span class="o">;</span>
        <span class="o">}</span>

</code></pre></div></div>

<p><em>evictEntries方法</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="cm">/**
         * 如果segment满了，则执行evict操作。这个调用仅仅发生在增加一个新的entry并且增加了count的时候。
         */</span>
        <span class="nd">@GuardedBy</span><span class="o">(</span><span class="s">"Segment.this"</span><span class="o">)</span>
        <span class="kt">void</span> <span class="nf">evictEntries</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">evictsBySize</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// 如果没有设置cache的权重，则不执行evict操作</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">//清除recencyQueue队列，按照指定的相关顺序来读取entries并且更新驱赶的元数据。</span>
            <span class="c1">// 把他们加到相关的evict列表 （这表明他们可以被移除出map中，由于被加到了recencyQueue队列中。）</span>
            <span class="n">drainRecencyQueue</span><span class="o">();</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">totalWeight</span> <span class="o">&gt;</span> <span class="n">maxSegmentWeight</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 当总的权重大于设置的最大段权重，才会执行remove操作</span>
                <span class="n">ReferenceEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">getNextEvictable</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">removeEntry</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getHash</span><span class="o">(),</span> <span class="n">RemovalCause</span><span class="o">.</span><span class="na">SIZE</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">AssertionError</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></div></div>

<h2 id="guava-cache扩展"><a id="CacheOverWrite">Guava Cache扩展</a></h2>

<p>Guava的CacheBuilder是一个final对象，不允许继承。但是，其提供看专门用来扩展的接口供重写部分方法。分别为<code class="highlighter-rouge">ForwardingCache</code>和<code class="highlighter-rouge">ForwardingLoadingCache</code>，对应着Cache类和LoadingCache类。</p>

<p>两个扩展类，采用委托模式和/或装饰模式，提供抽象实现。</p>

<p>委派模式（Delegate）是面向对象设计模式中常用的一种模式。这种模式的原理为类B和类A是两个互相没有任何关系的类，B具有和A一模一样的方法和属性；并且调用B中的方法，属性就是调用A中同名的方法和属性。B好像就是一个受A授权委托的中介。第三方的代码不需要知道A的存在，也不需要和A发生直接的联系，通过B就可以直接使用A的功能，这样既能够使用到A的各种公能，又能够很好的将A保护起来了。</p>

<p>Decorator装饰模式是一种结构型模式，它主要是解决：“过度地使用了继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀（多继承）。继承为类型引入的静态特质的意思是说以继承的方式使某一类型要获得功能是在编译时。所谓静态，是指在编译时；动态，是指在运行时。</p>

<p>GoF《设计模式》中说道：动态的给一个对象添加一些额外的职责。就增加功能而言，Decorator模式比生成子类更为灵活。</p>

<p>两种模式其实很相近。委派模式的最终结果就是达到装饰模式的目的。</p>

<p>简单地来看看ForwardingCache抽象类的实现：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 一个缓存将所有他的方法调用转到其他cache上。子类需要重写一个或者多个方法来改变背后cache的行为。
 * 因此，在该类里面会有一个delegate的成员，负责调用具体的cache类对象方法。
 */</span>
<span class="nd">@Beta</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ForwardingCache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">ForwardingObject</span> <span class="kd">implements</span> <span class="n">Cache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>

  <span class="cm">/** Constructor for use by subclasses. */</span>
  <span class="kd">protected</span> <span class="nf">ForwardingCache</span><span class="o">()</span> <span class="o">{}</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kd">abstract</span> <span class="n">Cache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">delegate</span><span class="o">();</span>

  <span class="cm">/**
   * @since 11.0
   */</span>
  <span class="nd">@Override</span>
  <span class="nd">@Nullable</span>
  <span class="kd">public</span> <span class="n">V</span> <span class="nf">getIfPresent</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">delegate</span><span class="o">().</span><span class="na">getIfPresent</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="cm">/**
   * @since 11.0
   */</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">V</span> <span class="nf">get</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">Callable</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">valueLoader</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ExecutionException</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">delegate</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">valueLoader</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="cm">/**
   * @since 11.0
   */</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">ImmutableMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">getAllPresent</span><span class="o">(</span><span class="n">Iterable</span><span class="o">&lt;?&gt;</span> <span class="n">keys</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">delegate</span><span class="o">().</span><span class="na">getAllPresent</span><span class="o">(</span><span class="n">keys</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="cm">/**
   * @since 11.0
   */</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">delegate</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="cm">/**
   * @since 12.0
   */</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">putAll</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">K</span><span class="o">,?</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">delegate</span><span class="o">().</span><span class="na">putAll</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">invalidate</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">delegate</span><span class="o">().</span><span class="na">invalidate</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="cm">/**
   * @since 11.0
   */</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">invalidateAll</span><span class="o">(</span><span class="n">Iterable</span><span class="o">&lt;?&gt;</span> <span class="n">keys</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">delegate</span><span class="o">().</span><span class="na">invalidateAll</span><span class="o">(</span><span class="n">keys</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">invalidateAll</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">delegate</span><span class="o">().</span><span class="na">invalidateAll</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">long</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">delegate</span><span class="o">().</span><span class="na">size</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">CacheStats</span> <span class="nf">stats</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">delegate</span><span class="o">().</span><span class="na">stats</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">ConcurrentMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">asMap</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">delegate</span><span class="o">().</span><span class="na">asMap</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cleanUp</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">delegate</span><span class="o">().</span><span class="na">cleanUp</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="cm">/**
   * A simplified version of {@link ForwardingCache} where subclasses can pass in an already
   * constructed {@link Cache} as the delegete.
   *
   * @since 10.0
   */</span>
  <span class="nd">@Beta</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SimpleForwardingCache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">ForwardingCache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Cache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">delegate</span><span class="o">;</span>

    <span class="kd">protected</span> <span class="nf">SimpleForwardingCache</span><span class="o">(</span><span class="n">Cache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">delegate</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">delegate</span> <span class="o">=</span> <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">delegate</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kd">final</span> <span class="n">Cache</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">delegate</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">delegate</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h2 id="guava-cache-总结"><a id="End">Guava Cache 总结</a></h2>

<p>Guava Cache的实现,核心数据结构和算法都是和JDK 1.6版本的<code class="highlighter-rouge">ConcurrentHashMap</code>一致.因此,如果你熟悉ConcurrentHashMap实现原理,对Cache是很容易明白的.</p>

<p>此外,Guava 还提供了相当多的优秀的工具类给开发者快速开发业务. 在后续的博客中, 会进一步介绍.</p>

<p>关于Guava 的源码学习, 博主都将一些注解和思考, 放在了源码解读中. 关于源码的地址, 请参考github: <a href="https://github.com/ketao1989/cnGuava.git">https://github.com/ketao1989/cnGuava.git</a></p>

<blockquote>
  <blockquote>
    <p>源码被裁剪过, 删掉了一些不太关注的GWT相关源码等, 所以是无法编译的.</p>
  </blockquote>
</blockquote>

                </div>
                <div class="read-all">
                    <a  href="/2014/12/19/Guava-Cache-Guide-And-Implement-Analyse/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2014/11/29/Redis-Cookbook-Analytics-Time-Based-Data/">Redis Cookbook 之 使用Redis存储基于时间序列的数据和进行分析</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2014-11-29
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Redis" title="Category: Redis" rel="category">Redis</a>&nbsp;
    
        <a href="/category/#Redis Cookbook" title="Category: Redis Cookbook" rel="category">Redis Cookbook</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <h2 id="问题"><a id="Problem">问题</a></h2>

<p>存储分析或者其他基于时间序列的数据，对于传统的存储系统（比如RDBMS）来说，是有一点挑战的。可能你想要对输入流量的速率进行限制（要求快速和高并发更新）或者简单地追踪网站访问者（或者其他更复杂的度量指标），然后以图表的形式画出来。</p>

<p>虽然当前在其他系统中，有很多的方式存储这类数据；但是，Redis是一个非常优秀的候选者，由于它强大的数据结构。</p>

<h2 id="解决方法"><a id="Solution">解决方法</a></h2>

<p>Redis 理念上非常适合存储这类数据，以及跟踪某种特定的事件。具有原子性的，并且非常快的（O(1)时间复杂度）<code class="highlighter-rouge">HINCR</code>和<code class="highlighter-rouge">HINCRBY</code>命令，结合快速数据查找，使得它非常适合这类场景。</p>

<p>在Redis中一种好的高效内存存储这类数据的方式是使用hash来存储统计值，使用<code class="highlighter-rouge">HINCRBY</code>增加它们，然后使用<code class="highlighter-rouge">HGET</code>和<code class="highlighter-rouge">HMGET</code>来获取这些数据。查找位于top位置的元素通过<code class="highlighter-rouge">SORT</code>命令也是很容易做到的。</p>

<!-- more -->

<h2 id="讨论"><a id="Discussion">讨论</a></h2>

<p>为了简单起见，在这个实例中，我们将只追踪网页点击率数据。这也可以很简单地扩展到其他任务类型的事件。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nb">require</span> <span class="s1">'rubygems'</span>
<span class="nb">require</span> <span class="s1">'active_support/time'</span>

<span class="c1"># 增加访问者的点击数，id表，date键，field数值</span>
<span class="k">def</span> <span class="nf">add_hit</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="vg">$redis</span><span class="p">.</span><span class="nf">sadd</span><span class="p">(</span><span class="s2">"clients"</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
    <span class="vg">$redis</span><span class="p">.</span><span class="nf">hincrby</span><span class="p">(</span><span class="s2">"stats/client:</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"total"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="vg">$redis</span><span class="p">.</span><span class="nf">hincrby</span><span class="p">(</span><span class="s2">"stats/client:</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="no">Date</span><span class="p">.</span><span class="nf">today</span><span class="p">.</span><span class="nf">to_s</span><span class="p">(</span><span class="ss">:number</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">end</span>

</code></pre></div></div>

<p>我们在这里把用户（如果我们追踪网站的访问者，那么可以只简单地根据IP地址来区分用户）的ID添加到访问者列表中，然后记录在两个不同时间空挡中的点击数：”total”总数和日常的数。因此，这就允许我们追踪每天的网页点击数和一段时间内的全局总数。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># 获取某id的key对应的值</span>
<span class="k">def</span> <span class="nf">hits</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">day</span> <span class="o">=</span> <span class="no">Date</span><span class="p">.</span><span class="nf">today</span><span class="p">)</span> 
    <span class="vg">$redis</span><span class="p">.</span><span class="nf">hget</span><span class="p">(</span><span class="s2">"stats/client:</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="n">day</span><span class="p">.</span><span class="nf">to_s</span><span class="p">(</span><span class="ss">:number</span><span class="p">)).</span><span class="nf">to_i</span>
<span class="k">end</span>

<span class="c1"># 判断是否超过阈值</span>
<span class="k">def</span> <span class="nf">over_limit?</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span> 
    <span class="n">hits</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limit</span>
<span class="k">end</span>

</code></pre></div></div>

<p>这允许我们通过简单地检查访问者访问，是否超过了我们设置的在一段时间区间内的阈值，来执行速率限制功能。</p>

<p>获取一个给定时间区间内的数据，也是一项琐碎但是高效的操作，我们可以用来画图表或者以其他方式展示这些数据：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># 计算给定开始时间和结束时间对应的key值</span>
<span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="n">beg_p</span><span class="p">,</span> <span class="n">end_p</span><span class="p">)</span> 
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">beg_p</span> <span class="o">&lt;=</span> <span class="n">end_p</span>
        <span class="n">keys</span> <span class="o">&lt;&lt;</span> <span class="k">if</span> <span class="nb">block_given?</span> 
            <span class="k">yield</span><span class="p">(</span><span class="n">beg_p</span><span class="p">.</span><span class="nf">to_s</span><span class="p">(</span><span class="ss">:number</span><span class="p">))</span>
        <span class="k">else</span> 
            <span class="n">beg_p</span><span class="p">.</span><span class="nf">to_s</span><span class="p">(</span><span class="ss">:number</span><span class="p">)</span>
        <span class="k">end</span>
        <span class="n">beg_p</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span> 
    <span class="k">end</span>
    <span class="n">keys</span> 
<span class="k">end</span>

<span class="k">def</span> <span class="nf">stats_for_period</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">beginning_of_period</span><span class="p">,</span> <span class="n">end_of_period</span><span class="p">)</span> 
    <span class="n">beg_p</span> <span class="o">=</span> <span class="no">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">beginning_of_period</span><span class="p">)</span>
    <span class="n">end_p</span> <span class="o">=</span> <span class="no">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">end_of_period</span><span class="p">)</span>

    <span class="c1"># 获取id表中key对应的数据集</span>
    <span class="vg">$redis</span><span class="p">.</span><span class="nf">hmget</span> <span class="s2">"stats/client:</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">(</span><span class="n">beg_p</span><span class="p">,</span> <span class="n">end_p</span><span class="p">)</span> 
<span class="k">end</span>

</code></pre></div></div>

<p>我们也可以获取我们存储数据中在任何时间空挡的位于top的用户，可以使用<code class="highlighter-rouge">SORT</code>命令完成。SORT允许我们排序一个集合set，有序的集合sorted set,，或者本例中得列表list，访问者可以选择使用外键-我们时间片，然后指定order，offset，limit等参数：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 按照key为period进行排序，默认DESC，前0-limit个元素</span>
<span class="k">def</span> <span class="nf">top_clients</span><span class="p">(</span><span class="n">period</span> <span class="o">=</span> <span class="s2">"total"</span><span class="p">,</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
<span class="vg">$redis</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="s2">"clients"</span><span class="p">,</span> <span class="ss">:by</span> <span class="o">=&gt;</span> <span class="s2">"stats/client:*-&gt;</span><span class="si">#{</span><span class="n">period</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="ss">:order</span> <span class="o">=&gt;</span> <span class="s2">"DESC"</span><span class="p">,</span><span class="ss">:get</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"#"</span><span class="p">,</span> <span class="s2">"stats/client:*-&gt;</span><span class="si">#{</span><span class="n">period</span><span class="si">}</span><span class="s2">"</span><span class="p">],</span> <span class="ss">:limit</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="p">])</span>
<span class="k">end</span>

</code></pre></div></div>

<p>使用hash的实现方式，对于存储，检索和更新都是高度优化的（所有都是O(1)操作），但是对于计算top用户而言则不是（尤其是一个时间区间内）。你需要要求这些操作-比如当你显示一个高分值表格，你可以重新使用有序集合sorted set来完成排序，这样可以保证你拿到的数据是有序的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">add_hit</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="vg">$redis</span><span class="p">.</span><span class="nf">zincrby</span><span class="p">(</span><span class="s2">"stats/total"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span> 
    <span class="vg">$redis</span><span class="p">.</span><span class="nf">zincrby</span><span class="p">(</span><span class="s2">"stats/</span><span class="si">#{</span><span class="no">Date</span><span class="p">.</span><span class="nf">today</span><span class="p">.</span><span class="nf">to_s</span><span class="p">(</span><span class="ss">:number</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">hits</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">day</span> <span class="o">=</span> <span class="no">Date</span><span class="p">.</span><span class="nf">today</span><span class="p">)</span> 
    <span class="vg">$redis</span><span class="p">.</span><span class="nf">zrank</span><span class="p">(</span><span class="s2">"stats/</span><span class="si">#{</span><span class="n">day</span><span class="p">.</span><span class="nf">to_s</span><span class="p">(</span><span class="ss">:number</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">over_limit?</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span> 
    <span class="n">hits</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limit</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">stats_for_period</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">beginning_of_period</span><span class="p">,</span> <span class="n">end_of_period</span><span class="p">)</span> 
    <span class="n">beg_p</span> <span class="o">=</span> <span class="no">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">beginning_of_period</span><span class="p">)</span>
    <span class="n">end_p</span> <span class="o">=</span> <span class="no">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">end_of_period</span><span class="p">)</span>

    <span class="n">keys</span><span class="p">(</span><span class="n">beg_p</span><span class="p">,</span> <span class="n">end_p</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">k</span><span class="o">|</span> <span class="vg">$redis</span><span class="p">.</span><span class="nf">zrank</span><span class="p">(</span><span class="s2">"stats/</span><span class="si">#{</span><span class="n">k</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span> <span class="p">}</span> 
<span class="k">end</span>

<span class="k">def</span> <span class="nf">top_clients</span><span class="p">(</span><span class="n">period</span> <span class="o">=</span> <span class="s2">"total"</span><span class="p">,</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> 
    <span class="vg">$redis</span><span class="p">.</span><span class="nf">zrevrange</span><span class="p">(</span><span class="s2">"stats/</span><span class="si">#{</span><span class="n">period</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="ss">:withscores</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">top_for_period</span><span class="p">(</span><span class="n">beginning_of_period</span><span class="p">,</span> <span class="n">end_of_period</span><span class="p">,</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> 
    <span class="n">beg_p</span> <span class="o">=</span> <span class="no">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">beginning_of_period</span><span class="p">)</span>
    <span class="n">end_p</span> <span class="o">=</span> <span class="no">Date</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">end_of_period</span><span class="p">)</span>

    <span class="n">result_key</span> <span class="o">=</span> <span class="s2">"top/</span><span class="si">#{</span><span class="n">beg_p</span><span class="p">.</span><span class="nf">to_s</span><span class="p">(</span><span class="ss">:number</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">#{</span><span class="n">end_p</span><span class="p">.</span><span class="nf">to_s</span><span class="p">(</span><span class="ss">:number</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">return</span> <span class="vg">$redis</span><span class="p">.</span><span class="nf">zrevrange</span><span class="p">(</span><span class="n">result_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="ss">:withscores</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span> <span class="k">if</span> <span class="vg">$redis</span><span class="p">.</span><span class="nf">exists</span> <span class="n">result_key</span>

    <span class="vg">$redis</span><span class="p">.</span><span class="nf">multi</span> <span class="k">do</span>
        <span class="vg">$redis</span><span class="p">.</span><span class="nf">zunionstore</span> <span class="n">result_key</span><span class="p">,</span> <span class="n">keys</span><span class="p">(</span><span class="n">beg_p</span><span class="p">,</span> <span class="n">end_p</span><span class="p">){</span><span class="o">|</span><span class="n">k</span><span class="o">|</span> <span class="s2">"stats/</span><span class="si">#{</span><span class="n">k</span><span class="si">}</span><span class="s2">"</span><span class="p">}</span> <span class="vg">$redis</span><span class="p">.</span><span class="nf">expire</span> <span class="n">result_key</span><span class="p">,</span> <span class="mi">10</span><span class="p">.</span><span class="nf">minutes</span>
        <span class="vg">$redis</span><span class="p">.</span><span class="nf">zrevrange</span> <span class="n">result_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="ss">:withscores</span> <span class="o">=&gt;</span> <span class="kp">true</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">last</span> 
<span class="k">end</span>

</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>Notes：我们保持了<code class="highlighter-rouge">ZUNIONSTORE</code>的结果，然后在它上面设置一个超时时间戳。这是一个通用的Redis模式：缓存一个计算昂贵的操作结果，然后每次有请求过来，都会在重新操作之前先检查缓存情况。
在上面的例子中，我们使用hash的地方，我们也可以存储SORT操作的结果，然后使用和EXISTS相似的方式检查它的缓存对象的存在性。</p>

  </blockquote>
</blockquote>

<p>当我们使用有序集合sorted sets时，这些top操作会更高效率的多（因为数据已经是排好序了），但是我们的内存使用率也会更高。</p>

<blockquote>
  <blockquote>
    <p>Warns：这个特定的例子有一个竞争条件：如果缓存不存在，我们可能在结束之前会进行多次<code class="highlighter-rouge">ZUNIONSTORE</code>操作。因为我们最后期待的输出显然是相同或者更新的数值结果，因此存在竞争条件比使用<code class="highlighter-rouge">WATCH</code>，然后在我们在做客户端的计算时锁定其他访问者，效果可能会更好。</p>
  </blockquote>
</blockquote>

<p>-</p>

<blockquote>
  <blockquote>
    <p><em>Redis 命令</em>:</p>

    <ul>
      <li>
        <p><code class="highlighter-rouge">HINCRBY hash-name field increment-value</code></p>

        <p>按照给定的increment-value值增加hash表中存储的对应整数。这个命令和INCRBY很相似，但是和增加字符串不一样，这个使用在hash表中。而且increment-value的值也允许为负数。</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">HMGET hash-name field1 [field2 ...]</code></p>

        <p>从给定的hash表中获取一些field值。这个命令和HGET很相似，但是这个允许你在一个单操作中获取一些field值。</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">SORT key [BY pattern] [LIMIT offset count] [GET pattern1 [GET pattern2 ...]] [ASC| DESC] [ALPHA] [STORE destination]</code></p>

        <p>允许你排序一个list,set,或者sorted set，比较他们的值。排序也可以是使用外键完成，使用来自字符串或者hashes的模式匹配查询，就像我们在上面的例子中那样：<code class="highlighter-rouge">SORT clients BY stats/client:*-&gt;20110407</code>。其中，通配符*可以被set中成员所替换，所以在这些hash表中排序是基于匹配field 为20110407的值来完成的。如果我们把分析数据存储在strings中而不是hash表，则我们可以提交命令：<code class="highlighter-rouge">SORT clients BY stats/client:*/20110407</code>。
   使用相同的模式，你除了排好序的list也可以获取更多地数据（比如你用来排序的值）.可选择地，在list里SORT的输出也可以被排序。</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">ZRANK set-name member</code></p>

        <p>返回在给定的有序集合中给定成员的排名。</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">ZUNIONSTORE destination number-of-keys sorted-set1 [sorted-set2 ...] [WEIGHTS weight1 [weight2 ...]] [AGGREGATE SUM|MIN|MAX]</code></p>

        <p>聚合sorted sets集合，然后作为一个新的sorted set存储。可选择地，你可以为每一个set指定 weight，并且只需聚合函数：sum（默认）,maximum scores, 或者 minimum scores。</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">EXISTS key</code></p>

        <p>检查key是否存在。如果key存在则返回1；否则返回0.</p>
      </li>
    </ul>

  </blockquote>
</blockquote>


                </div>
                <div class="read-all">
                    <a  href="/2014/11/29/Redis-Cookbook-Analytics-Time-Based-Data/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2014/11/26/Java-Implement-One-Algorithm-by-Day/">一天一算法之java实现</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2014-11-26
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Java" title="Category: Java" rel="category">Java</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <p>说明：算法背景和解法来自<a href="https://github.com/ketao1989/The-Art-Of-Programming-By-July.git">https://github.com/ketao1989/The-Art-Of-Programming-By-July.git</a>,如有版权问题，请留言告知！</p>

<h2 id="前言"><a id="Intro">前言</a></h2>

<p>最近看博客，发现一些有趣的算法，很久没接触，都不清楚了。这里，把上述的github中一些算法用java实现。</p>

<h2 id="旋转字符串"><a id="RotateString">旋转字符串</a></h2>

<h3 id="背景">背景</h3>

<p>给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcddg”前面的2个字符’a’和’b’移动到字符串的尾部，使得原字符串变成字符串“cdcgab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。</p>

<h3 id="java-代码">Java 代码</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/*************************************************************************
	&gt; File Name: RotateString.java
	&gt; Author: ketao
	&gt; Mail: ketao1989@gmail.com
	&gt; Created Time: 2014年11月26日 星期三 16时33分28秒
 ************************************************************************/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RotateString</span><span class="o">{</span>
    
    <span class="cm">/**
     * 把一个字符数组，按照指定位置移动
     */</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">rotateString</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">str</span><span class="o">,</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span><span class="kt">int</span> <span class="n">len</span><span class="o">){</span>
        <span class="n">reverseString</span><span class="o">(</span><span class="n">str</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">reverseString</span><span class="o">(</span><span class="n">str</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">reverseString</span><span class="o">(</span><span class="n">str</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="cm">/**
     *反转指定区间的字符数组
     *
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">reverseString</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">str</span><span class="o">,</span><span class="kt">int</span> <span class="n">from</span><span class="o">,</span><span class="kt">int</span> <span class="n">to</span><span class="o">){</span>
        
        <span class="k">while</span><span class="o">(</span><span class="n">from</span> <span class="o">&lt;</span> <span class="n">to</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">str</span><span class="o">[</span><span class="n">from</span><span class="o">];</span>
            <span class="n">str</span><span class="o">[</span><span class="n">from</span><span class="o">++]</span> <span class="o">=</span> <span class="n">str</span><span class="o">[</span><span class="n">to</span><span class="o">];</span>
            <span class="n">str</span><span class="o">[</span><span class="n">to</span><span class="o">--]</span> <span class="o">=</span> <span class="n">ch</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     *测试代码
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">str</span> <span class="o">=</span> <span class="o">{</span><span class="sc">'a'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'c'</span><span class="o">,</span><span class="sc">'d'</span><span class="o">,</span><span class="sc">'c'</span><span class="o">,</span><span class="sc">'g'</span><span class="o">};</span>
        <span class="n">rotateString</span><span class="o">(</span><span class="n">str</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">6</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<!-- more -->

<h2 id="字符包含"><a id="StringContain">字符包含</a></h2>

<h3 id="背景-1">背景</h3>

<p>给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？简单起见，暂不考虑非字符符号。</p>

<h3 id="java-代码-1">Java 代码</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/*************************************************************************
	&gt; File Name: StringContain.java
	&gt; Author: ketao
	&gt; Mail: ketao1989@gmail.com
	&gt; Created Time: 2014年11月26日 星期三 21时16分42秒
 ************************************************************************/</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringContain</span><span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isContainString</span><span class="o">(</span><span class="n">String</span> <span class="n">longger</span><span class="o">,</span><span class="n">String</span> <span class="n">shortter</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">{</span>
        
        <span class="c1">//26*2个字符，使用long就可以了</span>
        <span class="kt">long</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">0L</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">longger</span><span class="o">.</span><span class="na">length</span><span class="o">();</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">hash</span> <span class="o">|=</span> <span class="o">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">computeLetterBit</span><span class="o">(</span><span class="n">longger</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)));</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">shortter</span><span class="o">.</span><span class="na">length</span><span class="o">();</span><span class="n">i</span><span class="o">++){</span>

            <span class="c1">//如果&amp;操作为0，表示该位对应的字符，longger没有包含</span>
            <span class="k">if</span><span class="o">((</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">computeLetterBit</span><span class="o">(</span><span class="n">shortter</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))))</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">return</span> <span class="kc">false</span> <span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">computeLetterBit</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">ch</span> <span class="o">&gt;=</span> <span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="o">){</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">ch</span><span class="o">-</span><span class="sc">'A'</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span><span class="o">(</span><span class="n">ch</span> <span class="o">&gt;=</span><span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="o">){</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">ch</span><span class="o">-</span><span class="sc">'a'</span><span class="o">+</span><span class="mi">26</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"参数错误！非法字符！"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">{</span>
        <span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"AcBbDg"</span><span class="o">;</span>
        <span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"AcD"</span><span class="o">;</span>
        <span class="n">String</span> <span class="n">c</span> <span class="o">=</span> <span class="s">"DdD"</span><span class="o">;</span>
        <span class="n">String</span> <span class="n">d</span> <span class="o">=</span><span class="s">"*AcN"</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">isContainString</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a 包含b所有的字符！！"</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a 不包含b所有的字符！！！"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span><span class="o">(</span><span class="n">isContainString</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">c</span><span class="o">)){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a 包含c所有的字符！！"</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a 不包含c所有的字符！！"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span><span class="o">(</span><span class="n">isContainString</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">d</span><span class="o">)){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a 包含d所有的字符！"</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>

<h2 id="回文判断"><a id="PalindromeString">回文判断</a></h2>

<h3 id="背景-2">背景</h3>

<p>回文，英文palindrome，指一个顺着读和反过来读都一样的字符串，比如madam、我爱我，这样的短句在智力性、趣味性和艺术性上都颇有特色，中国历史上还有很多有趣的回文诗。</p>

<p>那么，我们的第一个问题就是：判断一个字串是否是回文？</p>

<h3 id="java代码">Java代码</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="cm">/*************************************************************************
    &gt; File Name: PalindromeString.java
    &gt; Author: ketao
    &gt; Mail: ketao1989@gmail.com
    &gt; Created Time: 2014年11月27日 星期四 17时03分52秒
 ************************************************************************/</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PalindromeString</span><span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="kd">final</span> <span class="kt">char</span><span class="o">[]</span> <span class="n">palindromeString</span><span class="o">,</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">len</span><span class="o">){</span>

        <span class="k">if</span><span class="o">(</span> <span class="kc">null</span>  <span class="o">==</span> <span class="n">palindromeString</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span><span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">middlePos</span><span class="o">(</span><span class="n">len</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">before</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">behind</span> <span class="o">=</span> <span class="o">(</span><span class="n">len</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">middle</span> <span class="o">:</span> <span class="o">(</span><span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

        <span class="k">while</span><span class="o">(</span><span class="n">before</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">palindromeString</span><span class="o">[</span><span class="n">before</span><span class="o">]+</span><span class="s">"----"</span><span class="o">+</span><span class="n">palindromeString</span><span class="o">[</span><span class="n">behind</span><span class="o">]);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">palindromeString</span><span class="o">[</span><span class="n">before</span><span class="o">--]</span> <span class="o">!=</span> <span class="n">palindromeString</span><span class="o">[</span><span class="n">behind</span><span class="o">++]){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>


    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">middlePos</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">num</span> <span class="o">){</span>
        
        <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="o">(</span><span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">middle</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">middle</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span><span class="n">P</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">palindromeString1</span> <span class="o">=</span> <span class="o">{</span><span class="sc">'a'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'c'</span><span class="o">,</span><span class="sc">'c'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'a'</span><span class="o">};</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">palindromeString2</span> <span class="o">=</span> <span class="o">{</span><span class="sc">'a'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'c'</span><span class="o">,</span><span class="sc">'b'</span><span class="o">,</span><span class="sc">'d'</span><span class="o">};</span>

        <span class="k">if</span><span class="o">(</span><span class="n">isPalindrome</span><span class="o">(</span><span class="n">palindromeString1</span><span class="o">,</span><span class="mi">6</span><span class="o">)){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"palindromeString1 is PalindromeString"</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"palindromeString1 is not PalindromeString"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span><span class="o">(</span><span class="n">isPalindrome</span><span class="o">(</span><span class="n">palindromeString2</span><span class="o">,</span><span class="mi">5</span><span class="o">)){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"palindromeString2 is PalindromeString"</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"palindromeString2 is not PalindromeString"</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="最长回文子串"><a id="LongestPalindromeSubString">最长回文子串</a></h2>

<h3 id="背景-3">背景</h3>

<p>上一小节已经介绍了回文字符串，不再做介绍。最长回文子串，就是：给定一个字符串，求它的最长回文串的长度，并且把这个回文子串打印出来。</p>

<h3 id="算法分析">算法分析</h3>

<p>由于查找最长回文子串问题的解决方法有很多种，而最快捷高效的算法，理解起来比较复杂，这里介绍一下，所谓的时间空间复杂度都是O(N)的<code class="highlighter-rouge">Manacher</code>算法.</p>

<ul>
  <li><code class="highlighter-rouge">Manacher</code>算法，首先会初始化处理字符串。在上一节的时候我们会需要针对奇数偶数不同情况来不同处理，但是如果按照<code class="highlighter-rouge">Manacher</code>算法的初始化规则，就可以统一为奇数一种情况来处理，方便快捷。</li>
</ul>

<p>初始化规则就是：在字符串中每个字符前后都是用<code class="highlighter-rouge">#</code>来分隔，包括开头和结尾；然后再新字符串的前后分别添加<code class="highlighter-rouge">$</code>和<code class="highlighter-rouge">^</code>符号标识字符串开始和结束。例如给定一个字符串<code class="highlighter-rouge">abcdcda</code>，初始化处理之后为<code class="highlighter-rouge">$#a#b#c#d#c#d#a#^</code></p>

<ul>
  <li>接下来，就需要对每一个字符分别计算它对应的最大回文子串长度(包括字符本身)，例如，</li>
</ul>
<table>
    <tr>
        <td>S[i]</td>
        <td>`$#a#b#c#d#c#d#a#^`</td>
    </tr>
    <tr>
        <td>P[i]</td>
        <td>`01212121414121210`</td>
    </tr>
</table>

<p>这样子计算的P[i]对应的值和初始化前字符的回文长度关系是：<code class="highlighter-rouge">old[i] = P[i]-1</code>.</p>

<p>*重点来了，如果分别计算每一个长度，那么其实效率并不高，那么有没有什么特征能快速计算每个字符对应的最长回文长度呢？<code class="highlighter-rouge">Manacher</code>算法告诉我们是有的。</p>

<p>假设：id是当前求得的最长回文子串中心的位置，mx为当前最长回文子串的右边界（回文子串不包括该右边界），即mx = id + P[id]。记j = id - (i-id) = 2*id – i ，即 j 是 i 关于 id 的对称点。</p>

<ol>
  <li>当i <code class="highlighter-rouge">&lt;</code> mx 时；存在一个非常神奇的结论P[i] &gt;= min(P[2*id - i], mx - i)，证明略。</li>
  <li>当i &gt;= mx, 无法对P[i]做更多的假设，只能P[i] = 1,然后按照原始方法再去匹配计算长度。</li>
</ol>


                </div>
                <div class="read-all">
                    <a  href="/2014/11/26/Java-Implement-One-Algorithm-by-Day/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2014/11/24/java-some-tips/">Java一些小Tips</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2014-11-24
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Java" title="Category: Java" rel="category">Java</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <p>插播广告：ubuntu系统的sublime text 3 中文无法输入，需要修复一些so库。参考：<a href="http://jingyan.baidu.com/article/f3ad7d0ff8731609c3345b3b.html">http://jingyan.baidu.com/article/f3ad7d0ff8731609c3345b3b.html</a></p>

<h2 id="前言"><a id="Intro">前言</a></h2>

<p>虽然java开发已经快两年了，但是对于java内部一些小的技巧和坑还是会有些不了解。这里记录下。</p>

<h2 id="java-integer并发问题"><a id="Integer">java Integer并发问题</a></h2>

<p>前段时间看书，顺带提到说<code class="highlighter-rouge">Integer.valueOf( )会导致死锁问题</code>很是惊讶。于是，查看了JDK源码，果然如此。</p>

<p>JDK代码对把-128 到127 之间的整数转换成<code class="highlighter-rouge">Integer</code>的时候，并不会new一个新的Integer对象，而是从 内部的<code class="highlighter-rouge">IntegerCache</code>中直接获取已经创建好的对象（第一次调用时会创建这个<code class="highlighter-rouge">IntegerCache</code>）。</p>

<blockquote>
  <blockquote>
    <p>由于内部<code class="highlighter-rouge">IntegerCache</code>共用，所以在不同的地方对同一个数值调用<code class="highlighter-rouge">valueOf</code>获取cache中同一个对象，这样很可能会导致死锁。此外，关于整数范围可以使用VM初始设置（-XX:AutoBoxCacheMax=<size>，但是不能比127小）</size></p>
  </blockquote>
</blockquote>

<h3 id="valueof方法实现代码">valueOf方法实现代码</h3>

<p><code class="highlighter-rouge">valueOf</code>方法实际上就是调用<code class="highlighter-rouge">IntegerCache</code>获取对应下标的对象，而<code class="highlighter-rouge">IntegerCache</code>实际上就是一个Integer对象数组。关于<code class="highlighter-rouge">IntegerCache</code>实现如下所示：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">IntegerCache</span> <span class="o">{</span>
        <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span><span class="o">;</span>
        <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">high</span><span class="o">;</span>
        <span class="kd">static</span> <span class="kd">final</span> <span class="n">Integer</span> <span class="n">cache</span><span class="o">[];</span>

        <span class="kd">static</span> <span class="o">{</span>
            <span class="c1">// high value may be configured by property</span>
            <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">127</span><span class="o">;</span>
            <span class="n">String</span> <span class="n">integerCacheHighPropValue</span> <span class="o">=</span>
                <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">VM</span><span class="o">.</span><span class="na">getSavedProperty</span><span class="o">(</span><span class="s">"java.lang.Integer.IntegerCache.high"</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">integerCacheHighPropValue</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">parseInt</span><span class="o">(</span><span class="n">integerCacheHighPropValue</span><span class="o">);</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">127</span><span class="o">);</span>
                <span class="c1">// Maximum array size is Integer.MAX_VALUE</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">-</span> <span class="o">(-</span><span class="n">low</span><span class="o">)</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span> 
            <span class="o">}</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>

            <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">[(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span><span class="c1">//大小为正负两边总的数量</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">low</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">cache</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
                <span class="n">cache</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="n">j</span><span class="o">++);</span>
        <span class="o">}</span>

        <span class="kd">private</span> <span class="nf">IntegerCache</span><span class="o">()</span> <span class="o">{}</span>
    <span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>之所以会导致死锁，主要原因是因为当两个线程不断的调用valueOf时，比如一个为 <code class="highlighter-rouge">Integer a=Integer.valueOf(10) + Integer.valueOf(20)</code>，另外一个线程调用<code class="highlighter-rouge">Integer b= Integer.valueOf(20) +Integer.valueOf(10)</code>，while中不停的调用，就可能出现死锁异常。</p>

  </blockquote>
</blockquote>

<!-- more -->

<h2 id="string-可变性方法"><a id="StringChange">String 可变性方法</a></h2>

<h3 id="string属性">String属性</h3>

<p>在一般的代码逻辑中，String 显然是不可以改变的，其实际上是一个final属性的值类型。也就是说，我们申明一个变量为String 常量，只要不替换变量的String引用，其具体字符串内容是不会改变的。但是，一个有趣的方法可以改变这些。</p>

<p>###改变String 值</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/*************************************************************************
    &gt; File Name: StringChange.java
    &gt; Author: ketao1989
    &gt; Mail: ketao1989@gmail.com
    &gt; Created Time: 2014年12月10日 星期三 20时48分37秒
 ************************************************************************/</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Field</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringChange</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Field</span> <span class="n">valueField</span><span class="o">;</span>
    
    <span class="kd">static</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">valueField</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"value"</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">valueField</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">valueField</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>                                                            
            <span class="o">}</span>
            <span class="c1">// (1)</span>
            <span class="n">valueField</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">"Immutable String"</span><span class="o">,</span> <span class="s">"Change Now！"</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">());</span> 
                                                
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                                    
        <span class="o">}</span>
                
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Immutable String"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>Note: 其实就是一个反射特性的有趣应用。其内部运行流程为：当运行(1)的时候，应用会去String池中寻找该字符串常量对应的引用，如果没有则新建一个，并且会把引用对应的值更改为新设置的值<code class="highlighter-rouge">Change Now！</code>。</p>

    <p>然后在程序运行main的时候，会去String池中寻找<code class="highlighter-rouge">Immutable String</code>对应的引用，但是这个引用内部的值以及被更改为<code class="highlighter-rouge">Change Now！</code>，所以打印的时候就会输出<code class="highlighter-rouge">Change Now！</code>.</p>

  </blockquote>
</blockquote>

<h2 id="volatile-非线程安全性"><a id="VolatileUnsafe">volatile 非线程安全性</a></h2>

<h3 id="volatile-属性">volatile 属性</h3>

<p><code class="highlighter-rouge">volatile</code> 在java中是一种力度比较轻的synchronized，使用简单，相应编码也比较少；显然，其对应的同步功能也会比synchronized少一部分。</p>

<p>在一般地代码使用过程中，经常会存在一些错误的使用方法，由于涉及多线程的方面的使用，有时候测试不严谨，就会存在一些线上不易发现的错误数据。</p>

<p><code class="highlighter-rouge">volatile</code>变量保证的是，定义属性字段在java内存模型中数据一致性，也就是说，当其他线程操作更新了该属性字段，所有读取该属性字段的线程都会去全局内存上去获取最新值。关于内存模型一致性参考下面这张图就可以明白了，文章可以看看改图对应的博文：<a href="http://www.infoq.com/cn/articles/java-memory-model-1">深入理解Java内存模型</a></p>

<p><img src="/images/2014/11/jmm.png" /></p>

<h3 id="volatile-非线程安全">volatile 非线程安全</h3>

<p>虽然，<code class="highlighter-rouge">volatile</code>虽然保证内存一致性，但是并不是线程安全的，这两个特性是不对应的。下面给出一个代码说明：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/**
 * @author: ketao Date: 14/12/14 Time: 下午8:21
 * @version: \$Id$
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">VolatileUnsafe</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">COUNT</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>

                    <span class="n">stopSecond</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
                    <span class="n">COUNT</span> <span class="o">+=</span> <span class="mi">100</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}).</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">stopSecond</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"100 times increase sum is :"</span> <span class="o">+</span> <span class="n">COUNT</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">stopSecond</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">a</span> <span class="o">*</span> <span class="mi">10</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>代码写的很简单，但是足以说明 <code class="highlighter-rouge">volatile</code>确实是无法保证线程安全性的。</p>

<p><code class="highlighter-rouge">volatile</code>确实可以保证线程变量内存一致性，但是对于上述这种多线程对变量更新操作的问题是无法保证的。在代码执行的时候，每个线程启动有先后，但是在sleep的时候，很多线程都取得了最新的值，这些值计算完了之后会写入内存，但是这个时候如果变量值改变了，线程并不知道，因为<code class="highlighter-rouge">volatile</code>只能保证读变量时是内存中最新的值，写的时候写入共享内存中；但是无法保证写入的时候去判断先前获取的值是否还是计算完之后还是最新的，因此也就无法保证线程安全性。</p>

<p>综上所述，<code class="highlighter-rouge">volatile</code>是无法保证线程安全性的；如果有这种需求，请使用<code class="highlighter-rouge">AtomicXxx</code>或者<code class="highlighter-rouge">synchronized</code>属性来实现。</p>

<p>此外，关于<code class="highlighter-rouge">volatile</code>变量一些优点和使用技巧，请参考IBM计数博客：<a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html">Java 理论与实践: 正确使用 Volatile 变量</a></p>

<h2 id="mathabs-可能返回负数"><a id="MathAbs">Math.abs 可能返回负数</a></h2>

<p>在有些应用场景下，我们需要对数值进行绝对值操作，保证是正数返回，一般我们都是使用<code class="highlighter-rouge">Math.abs()</code>函数来完成。但是，在使用kafka进行分区自定义的时候，我们实现是对key进行hash操作，然后对当前分区取mod，由于要求返回的分区必须是整数，所以hash后特别进行了abs操作，结果竟然发现还有负值出现。</p>

<p>然后，Google发现，abs在某种情况下，竟然会返回负值。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/**
     * Returns the absolute value of an {@code int} value.
     * If the argument is not negative, the argument is returned.
     * If the argument is negative, the negation of the argument is returned.
     *
     * &lt;p&gt;Note that if the argument is equal to the value of
     * {@link Integer#MIN_VALUE}, the most negative representable
     * {@code int} value, the result is that same value, which is
     * negative.
     *
     * @param   a   the argument whose absolute value is to be determined
     * @return  the absolute value of the argument.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">abs</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">a</span> <span class="o">:</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>

</code></pre></div></div>

<p>从上面的jdk源码注释中，可以看出，当 a的值为<code class="highlighter-rouge">Integer#MIN_VALUE</code>时，返回原值。原因是因为 int 值的范围是 <code class="highlighter-rouge">-2^31 ~ 2^31-1</code>，也就是说最小的负数，没有对应的正整数，所以jdk实现中只有原样返回了。</p>

<p>实现中，由于 <code class="highlighter-rouge">Integer#MIN_VALUE</code> 二进制表示为 <code class="highlighter-rouge">10000000000000000000000000000000</code>，取负数之后，还是<code class="highlighter-rouge">10000000000000000000000000000000</code>,所以，原值返回了。</p>

<p>如果有兴趣，你可以写个小代码测试下。^_^</p>

<h2 id="java-向上取证"><a id="IntMath">java 向上取证</a></h2>

<p>在开发的时候，经常有<code class="highlighter-rouge">对两个整数向上取整</code>，一般我们都会把问题收缩到两个正整数取整，下来来看下<code class="highlighter-rouge">Guava</code>的时候吧：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">divide</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">,</span> <span class="n">RoundingMode</span> <span class="n">mode</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">checkNotNull</span><span class="o">(</span><span class="n">mode</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArithmeticException</span><span class="o">(</span><span class="s">"/ by zero"</span><span class="o">);</span> <span class="c1">// for GWT</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">div</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="n">q</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">rem</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">q</span> <span class="o">*</span> <span class="n">div</span><span class="o">;</span> <span class="c1">// equal to p % q</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">rem</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">div</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/*
     * signum 如果p,q都是整数或者负数的时候，这个值为1, and -1 otherwise.
     */</span>
    <span class="kt">int</span> <span class="n">signum</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">|</span> <span class="o">((</span><span class="n">p</span> <span class="o">^</span> <span class="n">q</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span><span class="c1">// 根据pq来看两个正负属性</span>
    <span class="kt">boolean</span> <span class="n">increment</span><span class="o">;</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">mode</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nl">UNNECESSARY:</span>
        <span class="n">checkRoundingUnnecessary</span><span class="o">(</span><span class="n">rem</span> <span class="o">==</span> <span class="mi">0</span><span class="o">);</span>
        <span class="c1">// fall through</span>
      <span class="k">case</span> <span class="nl">DOWN:</span>
        <span class="n">increment</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="k">case</span> <span class="nl">UP:</span>
        <span class="n">increment</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="k">case</span> <span class="nl">CEILING:</span>
        <span class="n">increment</span> <span class="o">=</span> <span class="n">signum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="k">case</span> <span class="nl">FLOOR:</span>
        <span class="n">increment</span> <span class="o">=</span> <span class="n">signum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="k">case</span> <span class="nl">HALF_EVEN:</span>
      <span class="k">case</span> <span class="nl">HALF_DOWN:</span>
      <span class="k">case</span> <span class="nl">HALF_UP:</span>
        <span class="kt">int</span> <span class="n">absRem</span> <span class="o">=</span> <span class="n">abs</span><span class="o">(</span><span class="n">rem</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">cmpRemToHalfDivisor</span> <span class="o">=</span> <span class="n">absRem</span> <span class="o">-</span> <span class="o">(</span><span class="n">abs</span><span class="o">(</span><span class="n">q</span><span class="o">)</span> <span class="o">-</span> <span class="n">absRem</span><span class="o">);</span>
        <span class="c1">// subtracting two nonnegative ints can't overflow</span>
        <span class="c1">// cmpRemToHalfDivisor has the same sign as compare(abs(rem), abs(q) / 2).</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cmpRemToHalfDivisor</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// exactly on the half mark</span>
          <span class="n">increment</span> <span class="o">=</span> <span class="o">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">HALF_UP</span> <span class="o">||</span> <span class="o">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">HALF_EVEN</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">div</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="n">increment</span> <span class="o">=</span> <span class="n">cmpRemToHalfDivisor</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// closer to the UP value</span>
        <span class="o">}</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="k">default</span><span class="o">:</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">AssertionError</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">increment</span> <span class="o">?</span> <span class="n">div</span> <span class="o">+</span> <span class="n">signum</span> <span class="o">:</span> <span class="n">div</span><span class="o">;</span>
  <span class="o">}</span>


<span class="c1">// 具体实现参考guava的这个类</span>
  <span class="kd">public</span> <span class="kd">enum</span> <span class="n">RoundingMode</span> <span class="o">{</span>
    <span class="n">UP</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_UP</span><span class="o">),</span>
    <span class="n">DOWN</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_DOWN</span><span class="o">),</span>
    <span class="n">CEILING</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_CEILING</span><span class="o">),</span>
    <span class="n">FLOOR</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_FLOOR</span><span class="o">),</span>
    <span class="n">HALF_UP</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_HALF_UP</span><span class="o">),</span>
    <span class="n">HALF_DOWN</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_HALF_DOWN</span><span class="o">),</span>
    <span class="n">HALF_EVEN</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_HALF_EVEN</span><span class="o">),</span>
    <span class="n">UNNECESSARY</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_UNNECESSARY</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

                </div>
                <div class="read-all">
                    <a  href="/2014/11/24/java-some-tips/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2014/10/22/Dubbo-Provider-Groups-Bug-Analyse/">Dubbo provider 多组名注册问题分析</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2014-10-22
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Java" title="Category: Java" rel="category">Java</a>&nbsp;
    
        <a href="/category/#Dubbo" title="Category: Dubbo" rel="category">Dubbo</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <h2 id="前言"><a id="Intro">前言</a></h2>

<p>最近线上遇到一个很奇怪的现象，就是一个dubbo 服务被注册到了好几个<code class="highlighter-rouge">group</code>下面，并且这些<code class="highlighter-rouge">group</code>都是我们应用中，通过<code class="highlighter-rouge">dubbo:registry</code>来配置的。但是，显然这不是我们应用所期待的结果，因此，首先，我们需要修复这个问题；其次，我们需要找出原因。</p>

<h3 id="11-问题定位">1.1 问题定位</h3>

<p>首先看配置：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="na">xmlns:dubbo=</span><span class="s">"http://code.alibabatech.com/schema/dubbo"</span>
       <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
       <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
        http://code.alibabatech.com/schema/dubbo
        http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;dubbo:registry</span> <span class="na">id=</span><span class="s">"crm-message-registry"</span> <span class="na">group=</span><span class="s">"crm-message"</span>
                    <span class="na">address=</span><span class="s">"${qunar-public.zookeeper.address}"</span> <span class="na">protocol=</span><span class="s">"zookeeper"</span><span class="nt">/&gt;</span>

    <span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"dubbo"</span> <span class="na">port=</span><span class="s">"${dubbo.protocol} "</span><span class="nt">/&gt;</span>

    <span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"com.qxx.scm.message.api.IPushMessageBiz"</span>
                   <span class="na">ref=</span><span class="s">"pushMessageBiz"</span> <span class="na">timeout=</span><span class="s">"6000"</span> <span class="na">version=</span><span class="s">"1.0.1"</span> <span class="nt">/&gt;</span>
                   
    <span class="nt">&lt;/beans&gt;</span>
    
</code></pre></div></div>

<p>从上面的配置可以看到，我们实际上是有<code class="highlighter-rouge">dubbo:registry</code>，并且在其中也设置了<code class="highlighter-rouge">group</code>属性。</p>

<!-- more -->

<p>接下来，拿该xml配置和以前的 <code class="highlighter-rouge">dubbo provider</code>的配置进行比较，发现在<code class="highlighter-rouge">dubbo:service</code>的属性配置里面，缺少了指定<code class="highlighter-rouge">registry</code>的配置，猜想应该是该配置的缺失，导致应用把该<code class="highlighter-rouge">service</code>对应的服务，注册到了多个group下面。因此，为了正式推测，更改配置如下：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="na">xmlns:dubbo=</span><span class="s">"http://code.alibabatech.com/schema/dubbo"</span>
       <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
       <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
        http://code.alibabatech.com/schema/dubbo
        http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;dubbo:registry</span> <span class="na">id=</span><span class="s">"crm-message-registry"</span> <span class="na">group=</span><span class="s">"crm-message"</span>
                    <span class="na">address=</span><span class="s">"${qxx-public.zookeeper.address}"</span> <span class="na">protocol=</span><span class="s">"zookeeper"</span><span class="nt">/&gt;</span>

    <span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"dubbo"</span> <span class="na">port=</span><span class="s">"${dubbo.protocol} "</span><span class="nt">/&gt;</span>
    
    <span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"com.qxx.scm.message.api.IPushMessageBiz"</span>
                   <span class="na">ref=</span><span class="s">"pushMessageBiz"</span> <span class="na">timeout=</span><span class="s">"6000"</span> <span class="na">version=</span><span class="s">"1.0.1"</span> <span class="na">registry=</span><span class="s">"crm-message-registry"</span><span class="nt">/&gt;</span>
 
    <span class="nt">&lt;/beans&gt;</span>
    
</code></pre></div></div>

<p>启动应用，发现果然问题解决了。</p>

<h3 id="12-问题产生原因">1.2 问题产生原因</h3>

<p>在<code class="highlighter-rouge">dubbo:service</code>没有明确设置<code class="highlighter-rouge">registry</code>，不会导致启动失败，或者注册不上，而是会在应用配置中声明的所有组名下面注册对应服务。于是，去dubbo的github：<a href="http://alibaba.github.io/dubbo-doc-static/Developer+Guide-zh.htm">http://alibaba.github.io/dubbo-doc-static/Developer+Guide-zh.htm</a>  上去看看wiki有木有说明。关于注册说明，如：<a href="http://alibaba.github.io/dubbo-doc-static/RegistryFactory+SPI-zh.htm">http://alibaba.github.io/dubbo-doc-static/RegistryFactory+SPI-zh.htm</a>.</p>

<p>其中，文档关于配置说明如下：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nt">&lt;dubbo:registry</span> <span class="na">id=</span><span class="s">"xxx1"</span> <span class="na">address=</span><span class="s">"xxx://ip:port"</span> <span class="nt">/&gt;</span> <span class="c">&lt;!-- 定义注册中心 --&gt;</span>
<span class="nt">&lt;dubbo:service</span> <span class="na">registry=</span><span class="s">"xxx1"</span> <span class="nt">/&gt;</span> <span class="c">&lt;!-- 引用注册中心，如果没有配置registry属性，将在ApplicationContext中自动扫描registry配置 --&gt;</span>
<span class="nt">&lt;dubbo:provider</span> <span class="na">registry=</span><span class="s">"xxx1"</span> <span class="nt">/&gt;</span> <span class="c">&lt;!-- 引用注册中心缺省值，当&lt;dubbo:service&gt;没有配置registry属性时，使用此配置 --&gt;</span>

</code></pre></div></div>

<p>ok，到这里就明白了，<code class="highlighter-rouge">dubbo</code>在我们配置<code class="highlighter-rouge">&lt;dubbo:service&gt;</code>中没有指定registry时，会看看对应的<code class="highlighter-rouge">&lt;dubbo:provider&gt;</code>有木有配置<code class="highlighter-rouge">registry</code>,如果没有，则<em>在ApplicationContext中自动扫描registry配置</em>获取注册中心列表，然后进行注册。</p>

<h2 id="dubbo注册分析"><a id="Registry">dubbo注册分析</a></h2>

<p><code class="highlighter-rouge">dubbo</code>是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。当然，作为一个优秀的RPC框架，其涉及到服务注册和服务事件的订阅及发布。</p>

<h3 id="21-dubbo配置解析">2.1 dubbo配置解析</h3>

<p>在Spring 中使用dubbo，会采用xml方式对dubbo相关属性进行配置，其加入了自己的命名空间，如<code class="highlighter-rouge">xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"</code>，因此，你会知道必然存在一个继承实现<code class="highlighter-rouge">org.springframework.beans.factory.xml.NamespaceHandlerSupport</code>来完成自定义配置的解析工作，部分代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DubboNamespaceHandler</span> <span class="kd">extends</span> <span class="n">NamespaceHandlerSupport</span> <span class="o">{</span>

	<span class="kd">static</span> <span class="o">{</span>
		<span class="n">Version</span><span class="o">.</span><span class="na">checkDuplicate</span><span class="o">(</span><span class="n">DubboNamespaceHandler</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
	    <span class="n">registerBeanDefinitionParser</span><span class="o">(</span><span class="s">"application"</span><span class="o">,</span> <span class="k">new</span> <span class="n">DubboBeanDefinitionParser</span><span class="o">(</span><span class="n">ApplicationConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>
        <span class="n">registerBeanDefinitionParser</span><span class="o">(</span><span class="s">"registry"</span><span class="o">,</span> <span class="k">new</span> <span class="n">DubboBeanDefinitionParser</span><span class="o">(</span><span class="n">RegistryConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>
        <span class="n">registerBeanDefinitionParser</span><span class="o">(</span><span class="s">"provider"</span><span class="o">,</span> <span class="k">new</span> <span class="n">DubboBeanDefinitionParser</span><span class="o">(</span><span class="n">ProviderConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>
        <span class="n">registerBeanDefinitionParser</span><span class="o">(</span><span class="s">"consumer"</span><span class="o">,</span> <span class="k">new</span> <span class="n">DubboBeanDefinitionParser</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>
        <span class="n">registerBeanDefinitionParser</span><span class="o">(</span><span class="s">"protocol"</span><span class="o">,</span> <span class="k">new</span> <span class="n">DubboBeanDefinitionParser</span><span class="o">(</span><span class="n">ProtocolConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>
        <span class="n">registerBeanDefinitionParser</span><span class="o">(</span><span class="s">"service"</span><span class="o">,</span> <span class="k">new</span> <span class="n">DubboBeanDefinitionParser</span><span class="o">(</span><span class="n">ServiceBean</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>
        <span class="n">registerBeanDefinitionParser</span><span class="o">(</span><span class="s">"reference"</span><span class="o">,</span> <span class="k">new</span> <span class="n">DubboBeanDefinitionParser</span><span class="o">(</span><span class="n">ReferenceBean</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">false</span><span class="o">));</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>

<p>可以看到<code class="highlighter-rouge">RegistryConfig.class</code>类，包含关于<code class="highlighter-rouge">注册中心</code>相关的属性变量配置；<code class="highlighter-rouge">ServiceBean.class</code>类，包含关于<code class="highlighter-rouge">对外服务</code>相关的属性变量配置。也就是说，通过<code class="highlighter-rouge">DubboBeanDefinitionParser</code>解析器会把对应xml节点解析成对应的对象实例。</p>

<p>Spring的自定义标签代码实现和内部原理，可以google一下。</p>

<blockquote>
  <blockquote>
    <p>说明：<code class="highlighter-rouge">DubboNamespaceHandler</code>在初始化的时候，会把所有，针对不同xml节点的对应解析其注册到Spring <code class="highlighter-rouge">NamespaceHandlerSupport</code>的 <code class="highlighter-rouge">BeanDefinitionParser</code> Map上来。这样，在Spring 初始化解析xml配置时，就可以完成对自定义标签的兼容和实例化了。</p>
  </blockquote>
</blockquote>

<p>对于Dubbo 自定义解析器<code class="highlighter-rouge">DubboBeanDefinitionParser</code>的说明，如<a href="#End">附录</a>所示。</p>

<h3 id="22-dubbo注册解析">2.2 dubbo注册解析</h3>

<p>阿里的dubbo提供了多种注册机制，比如：<code class="highlighter-rouge">Redis</code>注册中心，<code class="highlighter-rouge">ZooKeeper</code>注册中心，或者使用<code class="highlighter-rouge">广播</code>的方式等。而目前使用的比较多的是使用<code class="highlighter-rouge">ZookeeperRegistry</code>方式。</p>

<p>从代码结构可以看出，对于不同的注册机制，其主要流程还是一样的，只是在注册url的具体操作中，需要根据不同的部署实体来采用不同的注册操作。比如，对于<code class="highlighter-rouge">zookeeper</code>，则使用<code class="highlighter-rouge">zkclient</code>去连接zk注册中心；而对于<code class="highlighter-rouge">redis</code>，则直接使用<code class="highlighter-rouge">redis.clients.jedis.Jedis</code>在数据库上注册保持对应url。</p>

<p>在抽象类的<code class="highlighter-rouge">AbstractRegistryFactory</code>中，提供了连接注册中心的一些方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="c1">// 注册中心集合 Map&lt;RegistryAddress, Registry&gt;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Registry</span><span class="o">&gt;</span> <span class="n">REGISTRIES</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Registry</span><span class="o">&gt;();</span>

    <span class="cm">/**
     * 获取所有注册中心
     * 
     * @return 所有注册中心
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">Registry</span><span class="o">&gt;</span> <span class="nf">getRegistries</span><span class="o">()</span> <span class="o">{</span>

        <span class="c1">// 这里获取应用中配置的所有注册中心，如果dubbo:service里面没有配置registry属性时，应该会调用这个方法</span>
        <span class="k">return</span> <span class="n">Collections</span><span class="o">.</span><span class="na">unmodifiableCollection</span><span class="o">(</span><span class="n">REGISTRIES</span><span class="o">.</span><span class="na">values</span><span class="o">());</span>
    <span class="o">}</span>
    
     <span class="cm">/**
     * 连接注册中心
     * @param url 注册中心地址，不允许为空
     * @return
     */</span>
    <span class="kd">public</span> <span class="n">Registry</span> <span class="nf">getRegistry</span><span class="o">(</span><span class="n">URL</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
    	<span class="n">url</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="na">setPath</span><span class="o">(</span><span class="n">RegistryService</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">())</span>
    			<span class="o">.</span><span class="na">addParameter</span><span class="o">(</span><span class="n">Constants</span><span class="o">.</span><span class="na">INTERFACE_KEY</span><span class="o">,</span> <span class="n">RegistryService</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">())</span>
    			<span class="o">.</span><span class="na">removeParameters</span><span class="o">(</span><span class="n">Constants</span><span class="o">.</span><span class="na">EXPORT_KEY</span><span class="o">,</span> <span class="n">Constants</span><span class="o">.</span><span class="na">REFER_KEY</span><span class="o">);</span>
    	<span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="na">toServiceString</span><span class="o">();</span>
        <span class="c1">// 锁定注册中心获取过程，保证注册中心单一实例</span>
        <span class="n">LOCK</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Registry</span> <span class="n">registry</span> <span class="o">=</span> <span class="n">REGISTRIES</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">registry</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">registry</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">registry</span> <span class="o">=</span> <span class="n">createRegistry</span><span class="o">(</span><span class="n">url</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">registry</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"Can not create registry "</span> <span class="o">+</span> <span class="n">url</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// 这里会把本应用所有不同的成功连接的注册配置放在全局concurrentMap中</span>
            <span class="n">REGISTRIES</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">registry</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">registry</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="c1">// 释放锁</span>
            <span class="n">LOCK</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="n">Registry</span> <span class="nf">createRegistry</span><span class="o">(</span><span class="n">URL</span> <span class="n">url</span><span class="o">);</span>

</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>Note：在Factory中会创建Registery对象，该对象中，会实现注册，取消注册，订阅，取消订阅等方法来提供给<code class="highlighter-rouge">service</code>和<code class="highlighter-rouge">reference</code>完成需要的注册和订阅服务。</p>
  </blockquote>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">RegistryService</span> <span class="o">{</span>

    <span class="cm">/**
     * 注册数据，比如：提供者地址，消费者地址，路由规则，覆盖规则，等数据。
     * 
     * 注册需处理契约：&lt;br&gt;
     * 1. 当URL设置了check=false时，注册失败后不报错，在后台定时重试，否则抛出异常。&lt;br&gt;
     * 2. 当URL设置了dynamic=false参数，则需持久存储，否则，当注册者出现断电等情况异常退出时，需自动删除。&lt;br&gt;
     * 3. 当URL设置了category=routers时，表示分类存储，缺省类别为providers，可按分类部分通知数据。&lt;br&gt;
     * 4. 当注册中心重启，网络抖动，不能丢失数据，包括断线自动删除数据。&lt;br&gt;
     * 5. 允许URI相同但参数不同的URL并存，不能覆盖。&lt;br&gt;
     * 
     * @param url 注册信息，不允许为空，如：dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin
     */</span>
    <span class="kt">void</span> <span class="nf">register</span><span class="o">(</span><span class="n">URL</span> <span class="n">url</span><span class="o">);</span>

    <span class="cm">/**
     * 取消注册.
     * 
     * 取消注册需处理契约：&lt;br&gt;
     * 1. 如果是dynamic=false的持久存储数据，找不到注册数据，则抛IllegalStateException，否则忽略。&lt;br&gt;
     * 2. 按全URL匹配取消注册。&lt;br&gt;
     * 
     * @param url 注册信息，不允许为空，如：dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin
     */</span>
    <span class="kt">void</span> <span class="nf">unregister</span><span class="o">(</span><span class="n">URL</span> <span class="n">url</span><span class="o">);</span>

    <span class="cm">/**
     * 订阅符合条件的已注册数据，当有注册数据变更时自动推送.
     * 
     * 订阅需处理契约：&lt;br&gt;
     * 1. 当URL设置了check=false时，订阅失败后不报错，在后台定时重试。&lt;br&gt;
     * 2. 当URL设置了category=routers，只通知指定分类的数据，多个分类用逗号分隔，并允许星号通配，表示订阅所有分类数据。&lt;br&gt;
     * 3. 允许以interface,group,version,classifier作为条件查询，如：interface=com.alibaba.foo.BarService&amp;version=1.0.0&lt;br&gt;
     * 4. 并且查询条件允许星号通配，订阅所有接口的所有分组的所有版本，或：interface=*&amp;group=*&amp;version=*&amp;classifier=*&lt;br&gt;
     * 5. 当注册中心重启，网络抖动，需自动恢复订阅请求。&lt;br&gt;
     * 6. 允许URI相同但参数不同的URL并存，不能覆盖。&lt;br&gt;
     * 7. 必须阻塞订阅过程，等第一次通知完后再返回。&lt;br&gt;
     * 
     * @param url 订阅条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin
     * @param listener 变更事件监听器，不允许为空
     */</span>
    <span class="kt">void</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">URL</span> <span class="n">url</span><span class="o">,</span> <span class="n">NotifyListener</span> <span class="n">listener</span><span class="o">);</span>

    <span class="cm">/**
     * 取消订阅.
     * 
     * 取消订阅需处理契约：&lt;br&gt;
     * 1. 如果没有订阅，直接忽略。&lt;br&gt;
     * 2. 按全URL匹配取消订阅。&lt;br&gt;
     * 
     * @param url 订阅条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin
     * @param listener 变更事件监听器，不允许为空
     */</span>
    <span class="kt">void</span> <span class="nf">unsubscribe</span><span class="o">(</span><span class="n">URL</span> <span class="n">url</span><span class="o">,</span> <span class="n">NotifyListener</span> <span class="n">listener</span><span class="o">);</span>

    <span class="cm">/**
     * 查询符合条件的已注册数据，与订阅的推模式相对应，这里为拉模式，只返回一次结果。
     * 
     * @see com.alibaba.dubbo.registry.NotifyListener#notify(List)
     * @param url 查询条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin
     * @return 已注册信息列表，可能为空，含义同{@link com.alibaba.dubbo.registry.NotifyListener#notify(List&lt;URL&gt;)}的参数。
     */</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">URL</span><span class="o">&gt;</span> <span class="nf">lookup</span><span class="o">(</span><span class="n">URL</span> <span class="n">url</span><span class="o">);</span>

<span class="o">}</span>

</code></pre></div></div>

<h2 id="dubbo服务分析"><a id="Service">dubbo服务分析</a></h2>

<p>从上面的解析配置文件，可以看到对于<code class="highlighter-rouge">&lt;dubbo:service&gt;</code>的解析，是使用<code class="highlighter-rouge">serviceBean</code>类来实现的。在<code class="highlighter-rouge">serviceConfig</code>（serviceBean的父类）类中对于service需要的一些属性进行说明，但是对于一些必须的属性没有设置会怎么样呢？！dubbo，首先会去上下文中，通过查找构造出对应的属性；当然如果构造不了，则返回null，这样在后期的时候就会抛出异常。</p>

<h3 id="31-dubbo服务配置处理分析">3.1 dubbo服务配置处理分析</h3>

<p>对于一些容错处理，也就是未配置的自动完善的方法，在<code class="highlighter-rouge">serviceBean</code>中完成。部分代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/**
     * 应用事件监听器ApplicationListener的接口方法，用来对监听到的事件进行处理。
     *
     * 显然的观察者设计模式。事件驱动。
     *
     * @param event
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onApplicationEvent</span><span class="o">(</span><span class="n">ApplicationEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ContextRefreshedEvent</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isDelay</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isExported</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isUnexported</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isInfoEnabled</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"The service ready on spring started. service: "</span> <span class="o">+</span> <span class="n">getInterface</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="n">export</span><span class="o">();</span><span class="c1">// 暴露服务</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
     <span class="cm">/**
     * 这个方法很重要！
     *
     * 这里会构造 服务提供方相关的服务设置
     *
     * @throws Exception
     */</span>
    <span class="nd">@SuppressWarnings</span><span class="o">({</span> <span class="s">"unchecked"</span><span class="o">,</span> <span class="s">"deprecation"</span> <span class="o">})</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterPropertiesSet</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

        <span class="c1">// 在dubbo:service中没有配置Provider属性</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">getProvider</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>

            <span class="c1">// 从applicationContext中构造ProviderConfig类对象</span>
            <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ProviderConfig</span><span class="o">&gt;</span> <span class="n">providerConfigMap</span> <span class="o">=</span> <span class="n">applicationContext</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">BeanFactoryUtils</span>
                    <span class="o">.</span><span class="na">beansOfTypeIncludingAncestors</span><span class="o">(</span><span class="n">applicationContext</span><span class="o">,</span> <span class="n">ProviderConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">providerConfigMap</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">providerConfigMap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 从applicationContext中构造ProtocolConfig类对象</span>
                <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ProtocolConfig</span><span class="o">&gt;</span> <span class="n">protocolConfigMap</span> <span class="o">=</span> <span class="n">applicationContext</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">BeanFactoryUtils</span>
                        <span class="o">.</span><span class="na">beansOfTypeIncludingAncestors</span><span class="o">(</span><span class="n">applicationContext</span><span class="o">,</span> <span class="n">ProtocolConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>

                <span class="c1">// 获取应用上下文中的所有providerConfig，然后保存到对应的service服务的protocol中</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">protocolConfigMap</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">protocolConfigMap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">providerConfigMap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 兼容旧版本</span>
                    <span class="n">List</span><span class="o">&lt;</span><span class="n">ProviderConfig</span><span class="o">&gt;</span> <span class="n">providerConfigs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">ProviderConfig</span><span class="o">&gt;();</span>
                    <span class="k">for</span> <span class="o">(</span><span class="n">ProviderConfig</span> <span class="n">config</span> <span class="o">:</span> <span class="n">providerConfigMap</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">isDefault</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">config</span><span class="o">.</span><span class="na">isDefault</span><span class="o">().</span><span class="na">booleanValue</span><span class="o">())</span> <span class="o">{</span>
                            <span class="n">providerConfigs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">config</span><span class="o">);</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">providerConfigs</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">setProviders</span><span class="o">(</span><span class="n">providerConfigs</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">ProviderConfig</span> <span class="n">providerConfig</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

                    <span class="c1">// 难以详细这个逻辑，for多次竟然只set一个变量，多个则又抛异常</span>
                    <span class="k">for</span> <span class="o">(</span><span class="n">ProviderConfig</span> <span class="n">config</span> <span class="o">:</span> <span class="n">providerConfigMap</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">isDefault</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">config</span><span class="o">.</span><span class="na">isDefault</span><span class="o">().</span><span class="na">booleanValue</span><span class="o">())</span> <span class="o">{</span><span class="c1">// 缺省状态，多次设置，则抛异常？？</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">providerConfig</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"Duplicate provider configs: "</span> <span class="o">+</span> <span class="n">providerConfig</span>
                                        <span class="o">+</span> <span class="s">" and "</span> <span class="o">+</span> <span class="n">config</span><span class="o">);</span>
                            <span class="o">}</span>
                            <span class="n">providerConfig</span> <span class="o">=</span> <span class="n">config</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">providerConfig</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">setProvider</span><span class="o">(</span><span class="n">providerConfig</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 对Application为空进行判断，并且只有provider为空或者provider的application为空，才会从应用的上下文去构造</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">getApplication</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">getProvider</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getProvider</span><span class="o">().</span><span class="na">getApplication</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ApplicationConfig</span><span class="o">&gt;</span> <span class="n">applicationConfigMap</span> <span class="o">=</span> <span class="n">applicationContext</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">BeanFactoryUtils</span>
                    <span class="o">.</span><span class="na">beansOfTypeIncludingAncestors</span><span class="o">(</span><span class="n">applicationContext</span><span class="o">,</span> <span class="n">ApplicationConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">applicationConfigMap</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">applicationConfigMap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ApplicationConfig</span> <span class="n">applicationConfig</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="n">ApplicationConfig</span> <span class="n">config</span> <span class="o">:</span> <span class="n">applicationConfigMap</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">isDefault</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">config</span><span class="o">.</span><span class="na">isDefault</span><span class="o">().</span><span class="na">booleanValue</span><span class="o">())</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">applicationConfig</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"Duplicate application configs: "</span> <span class="o">+</span> <span class="n">applicationConfig</span>
                                    <span class="o">+</span> <span class="s">" and "</span> <span class="o">+</span> <span class="n">config</span><span class="o">);</span>
                        <span class="o">}</span>
                        <span class="n">applicationConfig</span> <span class="o">=</span> <span class="n">config</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">applicationConfig</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">setApplication</span><span class="o">(</span><span class="n">applicationConfig</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">getModule</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">getProvider</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getProvider</span><span class="o">().</span><span class="na">getModule</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ModuleConfig</span><span class="o">&gt;</span> <span class="n">moduleConfigMap</span> <span class="o">=</span> <span class="n">applicationContext</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">BeanFactoryUtils</span>
                    <span class="o">.</span><span class="na">beansOfTypeIncludingAncestors</span><span class="o">(</span><span class="n">applicationContext</span><span class="o">,</span> <span class="n">ModuleConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">moduleConfigMap</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">moduleConfigMap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ModuleConfig</span> <span class="n">moduleConfig</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="n">ModuleConfig</span> <span class="n">config</span> <span class="o">:</span> <span class="n">moduleConfigMap</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">isDefault</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">config</span><span class="o">.</span><span class="na">isDefault</span><span class="o">().</span><span class="na">booleanValue</span><span class="o">())</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">moduleConfig</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"Duplicate module configs: "</span> <span class="o">+</span> <span class="n">moduleConfig</span> <span class="o">+</span> <span class="s">" and "</span>
                                    <span class="o">+</span> <span class="n">config</span><span class="o">);</span>
                        <span class="o">}</span>
                        <span class="n">moduleConfig</span> <span class="o">=</span> <span class="n">config</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">moduleConfig</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">setModule</span><span class="o">(</span><span class="n">moduleConfig</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// ok,这里就是注册中心的配置处理，对于service中没有配置registry属性的，dubbo会自己来完善</span>
        <span class="c1">// 还记得上面的dubbo wiki文档的说明吗？会查看provider是否配置了registry，如果没有才会调用全局应用上下文的配置。</span>
        <span class="c1">// 所以这里，会首先判断service是否配置registry，然后判断provider是否配置，然后在判断application是否配置registry，</span>
        <span class="c1">// 然后才会从applicationContext中获取已经在spring 中注册了的registry列表，作为本service的配置。</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">getRegistries</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getRegistries</span><span class="o">().</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">getProvider</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getProvider</span><span class="o">().</span><span class="na">getRegistries</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getProvider</span><span class="o">().</span><span class="na">getRegistries</span><span class="o">()</span>
                        <span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">getApplication</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getApplication</span><span class="o">().</span><span class="na">getRegistries</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getApplication</span><span class="o">()</span>
                        <span class="o">.</span><span class="na">getRegistries</span><span class="o">().</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">RegistryConfig</span><span class="o">&gt;</span> <span class="n">registryConfigMap</span> <span class="o">=</span> <span class="n">applicationContext</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">BeanFactoryUtils</span>
                    <span class="o">.</span><span class="na">beansOfTypeIncludingAncestors</span><span class="o">(</span><span class="n">applicationContext</span><span class="o">,</span> <span class="n">RegistryConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">registryConfigMap</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">registryConfigMap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">List</span><span class="o">&lt;</span><span class="n">RegistryConfig</span><span class="o">&gt;</span> <span class="n">registryConfigs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">RegistryConfig</span><span class="o">&gt;();</span>
                <span class="k">for</span> <span class="o">(</span><span class="n">RegistryConfig</span> <span class="n">config</span> <span class="o">:</span> <span class="n">registryConfigMap</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">isDefault</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">config</span><span class="o">.</span><span class="na">isDefault</span><span class="o">().</span><span class="na">booleanValue</span><span class="o">())</span> <span class="o">{</span>
                        <span class="n">registryConfigs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">config</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="c1">// 这里设置到了注册中心配置中，list哦。</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">registryConfigs</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">registryConfigs</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kd">super</span><span class="o">.</span><span class="na">setRegistries</span><span class="o">(</span><span class="n">registryConfigs</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="c1">// ....................</span>
        
         <span class="k">if</span> <span class="o">(!</span><span class="n">isDelay</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 不延迟，可以开始暴露服务了</span>
            <span class="n">export</span><span class="o">();</span>
        <span class="o">}</span>
  <span class="o">}</span>

</code></pre></div></div>

<p>具体，dubbo怎么把服务暴露出去，消费者怎样通过dubbo rpc调用服务等，不在本文所描述之内。后续会单独进行分析说明。</p>

<h3 id="32-问题原因解析">3.2 问题原因解析</h3>

<p>从上面的代码逻辑，可以明白之所以出现多组注册的问题原因了。</p>

<p>回到代码中，在配置的dubbo xml文件里面，有三个不同的节点，<code class="highlighter-rouge">&lt;dubbo:registry&gt;</code>，<code class="highlighter-rouge">&lt;dubbo:protocol&gt;</code>和<code class="highlighter-rouge">&lt;dubbo:service&gt;</code>。由于<code class="highlighter-rouge">&lt;dubbo:service&gt;</code>中没有配置<code class="highlighter-rouge">registry</code>属性，所以按照dubbo的逻辑，会先查找<code class="highlighter-rouge">&lt;dubbo:provider&gt;</code>节点配置，但是因为配置文件中没有配置，所以接下来会查找<code class="highlighter-rouge">&lt;dubbo:application&gt;</code>节点，看看该节点下面是否有配置<code class="highlighter-rouge">registry</code>属性，依然没有配置该节点。</p>

<p>这样，就走进了dubbo来配置相关registry属性的代码内部。</p>

<p>代码会从spring的<code class="highlighter-rouge">applicationContext</code>中构造出<code class="highlighter-rouge">Map&lt;String, RegistryConfig&gt; </code>类型变量，然后获取<code class="highlighter-rouge">map.values()</code>从而拿到所有在spring中已经存在上下文中的注册信息了。这样，把结果（所有注册的registry信息）放到service配置中。</p>

<blockquote>
  <blockquote>
    <p>Note：那么，为什么可以获取应用上下文环境中所有的<code class="highlighter-rouge">RegistryConfig</code>呢？还记得解析顺序吗！？最开始就是解析注册节点的数据哦！<code class="highlighter-rouge">registerBeanDefinitionParser("registry", new DubboBeanDefinitionParser(RegistryConfig.class, true));</code>早于<code class="highlighter-rouge">registerBeanDefinitionParser("service", new DubboBeanDefinitionParser(ServiceBean.class, true));</code>，此外，判断逻辑里面，其他节点数据解析，也是早于serviceBean的。</p>
  </blockquote>
</blockquote>

<h2 id="附录"><a id="End">附录</a></h2>

<p>dubbo 关于<code class="highlighter-rouge">DubboBeanDefinitionParser</code> 部分核心代码的注释说明：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DubboBeanDefinitionParser</span> <span class="kd">implements</span> <span class="n">BeanDefinitionParser</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">DubboBeanDefinitionParser</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">beanClass</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">required</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">DubboBeanDefinitionParser</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">beanClass</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">required</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">beanClass</span> <span class="o">=</span> <span class="n">beanClass</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">required</span> <span class="o">=</span> <span class="n">required</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">BeanDefinition</span> <span class="nf">parse</span><span class="o">(</span><span class="n">Element</span> <span class="n">element</span><span class="o">,</span> <span class="n">ParserContext</span> <span class="n">parserContext</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">parse</span><span class="o">(</span><span class="n">element</span><span class="o">,</span> <span class="n">parserContext</span><span class="o">,</span> <span class="n">beanClass</span><span class="o">,</span> <span class="n">required</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">BeanDefinition</span> <span class="nf">parse</span><span class="o">(</span><span class="n">Element</span> <span class="n">element</span><span class="o">,</span> <span class="n">ParserContext</span> <span class="n">parserContext</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">beanClass</span><span class="o">,</span>
            <span class="kt">boolean</span> <span class="n">required</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">RootBeanDefinition</span> <span class="n">beanDefinition</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RootBeanDefinition</span><span class="o">();</span>
        <span class="n">beanDefinition</span><span class="o">.</span><span class="na">setBeanClass</span><span class="o">(</span><span class="n">beanClass</span><span class="o">);</span>
        <span class="n">beanDefinition</span><span class="o">.</span><span class="na">setLazyInit</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
        <span class="c1">// 解析 id标识</span>
        <span class="n">String</span> <span class="n">id</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"id"</span><span class="o">);</span>

        <span class="c1">// 如果id标识为空，则获取name标识</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">id</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">id</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">required</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">String</span> <span class="n">generatedBeanName</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"name"</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">generatedBeanName</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">generatedBeanName</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>

                <span class="c1">// 如果使用ProtocolConfig 为bean ，则为dubbo，配置为dubbo:protocol</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">ProtocolConfig</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">beanClass</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">generatedBeanName</span> <span class="o">=</span> <span class="s">"dubbo"</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>

                    <span class="c1">// ok，这里是没有id和name标识，并且正常config bean，则使用interface的标识value值</span>
                    <span class="c1">// 比如，一般我们写dubbo:service 可能会走到这个配置上。</span>
                    <span class="n">generatedBeanName</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"interface"</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">generatedBeanName</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">generatedBeanName</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">generatedBeanName</span> <span class="o">=</span> <span class="n">beanClass</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">id</span> <span class="o">=</span> <span class="n">generatedBeanName</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
            <span class="c1">// 如果存在该BeanDefinition，则重置id</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">parserContext</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">().</span><span class="na">containsBeanDefinition</span><span class="o">(</span><span class="n">id</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">id</span> <span class="o">=</span> <span class="n">generatedBeanName</span> <span class="o">+</span> <span class="o">(</span><span class="n">counter</span><span class="o">++);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// ok，这里再次判断，检查是否重复id在bean里面</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">id</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">id</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">parserContext</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">().</span><span class="na">containsBeanDefinition</span><span class="o">(</span><span class="n">id</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"Duplicate spring bean id "</span> <span class="o">+</span> <span class="n">id</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// 注册到spring 的bean Map中去，其中id为key</span>
            <span class="n">parserContext</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">().</span><span class="na">registerBeanDefinition</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">beanDefinition</span><span class="o">);</span>
            <span class="c1">// 然后把id和对应value 作为Property放入bean里面</span>
            <span class="n">beanDefinition</span><span class="o">.</span><span class="na">getPropertyValues</span><span class="o">().</span><span class="na">addPropertyValue</span><span class="o">(</span><span class="s">"id"</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 如果使用ProtocolConfig的配置类，dubbo:protocol</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ProtocolConfig</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">beanClass</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// 拿到注册在parser环境里所有getBeanDefinitionNames，他实际上是bean map的key部分</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">parserContext</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">().</span><span class="na">getBeanDefinitionNames</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">BeanDefinition</span> <span class="n">definition</span> <span class="o">=</span> <span class="n">parserContext</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">().</span><span class="na">getBeanDefinition</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
                <span class="n">PropertyValue</span> <span class="n">property</span> <span class="o">=</span> <span class="n">definition</span><span class="o">.</span><span class="na">getPropertyValues</span><span class="o">().</span><span class="na">getPropertyValue</span><span class="o">(</span><span class="s">"protocol"</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">property</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">property</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
                    <span class="c1">// 如果id 为protocol</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="k">instanceof</span> <span class="n">ProtocolConfig</span> <span class="o">&amp;&amp;</span> <span class="n">id</span><span class="o">.</span><span class="na">equals</span><span class="o">(((</span><span class="n">ProtocolConfig</span><span class="o">)</span> <span class="n">value</span><span class="o">).</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
                        <span class="n">definition</span><span class="o">.</span><span class="na">getPropertyValues</span><span class="o">().</span><span class="na">addPropertyValue</span><span class="o">(</span><span class="s">"protocol"</span><span class="o">,</span> <span class="k">new</span> <span class="n">RuntimeBeanReference</span><span class="o">(</span><span class="n">id</span><span class="o">));</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// dubbo:service 对应的配置解析</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ServiceBean</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">beanClass</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">String</span> <span class="n">className</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"class"</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">className</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">className</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">RootBeanDefinition</span> <span class="n">classDefinition</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RootBeanDefinition</span><span class="o">();</span>
                <span class="n">classDefinition</span><span class="o">.</span><span class="na">setBeanClass</span><span class="o">(</span><span class="n">ReflectUtils</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">className</span><span class="o">));</span>
                <span class="n">classDefinition</span><span class="o">.</span><span class="na">setLazyInit</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
                <span class="n">parseProperties</span><span class="o">(</span><span class="n">element</span><span class="o">.</span><span class="na">getChildNodes</span><span class="o">(),</span> <span class="n">classDefinition</span><span class="o">);</span>
                <span class="n">beanDefinition</span><span class="o">.</span><span class="na">getPropertyValues</span><span class="o">().</span><span class="na">addPropertyValue</span><span class="o">(</span><span class="s">"ref"</span><span class="o">,</span>
                        <span class="k">new</span> <span class="nf">BeanDefinitionHolder</span><span class="o">(</span><span class="n">classDefinition</span><span class="o">,</span> <span class="n">id</span> <span class="o">+</span> <span class="s">"Impl"</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// provider配置</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ProviderConfig</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">beanClass</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// tag:service ;property:provider;ref:id</span>
            <span class="c1">// parserContext</span>
            <span class="n">parseNested</span><span class="o">(</span><span class="n">element</span><span class="o">,</span> <span class="n">parserContext</span><span class="o">,</span> <span class="n">ServiceBean</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="s">"service"</span><span class="o">,</span> <span class="s">"provider"</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span> <span class="n">beanDefinition</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// consumer配置，对于consumer，找到对应的reference 标识</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">beanClass</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">parseNested</span><span class="o">(</span><span class="n">element</span><span class="o">,</span> <span class="n">parserContext</span><span class="o">,</span> <span class="n">ReferenceBean</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="s">"reference"</span><span class="o">,</span> <span class="s">"consumer"</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span> <span class="n">beanDefinition</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// ok，以上都没有，接下来，正常解析了</span>
        <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
        <span class="n">ManagedMap</span> <span class="n">parameters</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Method</span> <span class="n">setter</span> <span class="o">:</span> <span class="n">beanClass</span><span class="o">.</span><span class="na">getMethods</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">setter</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>

            <span class="c1">// 找到set方法来设置beanclass对象的值</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">name</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"set"</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">Modifier</span><span class="o">.</span><span class="na">isPublic</span><span class="o">(</span><span class="n">setter</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">())</span>
                    <span class="o">&amp;&amp;</span> <span class="n">setter</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">().</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 判断set方法</span>
                <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">type</span> <span class="o">=</span> <span class="n">setter</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">()[</span><span class="mi">0</span><span class="o">];</span>

                <span class="c1">// 获取属性的名称，并且把名称第一个大写字母 --&gt; 小写，并且各个驼峰使用‘_’连接</span>
                <span class="n">String</span> <span class="n">property</span> <span class="o">=</span> <span class="n">StringUtils</span><span class="o">.</span><span class="na">camelToSplitName</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">).</span><span class="na">toLowerCase</span><span class="o">()</span> <span class="o">+</span> <span class="n">name</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">4</span><span class="o">),</span>
                        <span class="s">"-"</span><span class="o">);</span>
                <span class="n">props</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">property</span><span class="o">);</span>
                <span class="n">Method</span> <span class="n">getter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

                <span class="c1">// 获取get或者is等取值方法</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">getter</span> <span class="o">=</span> <span class="n">beanClass</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"get"</span> <span class="o">+</span> <span class="n">name</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span> <span class="k">new</span> <span class="n">Class</span><span class="o">&lt;?&gt;[</span><span class="mi">0</span><span class="o">]);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NoSuchMethodException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">getter</span> <span class="o">=</span> <span class="n">beanClass</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"is"</span> <span class="o">+</span> <span class="n">name</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span> <span class="k">new</span> <span class="n">Class</span><span class="o">&lt;?&gt;[</span><span class="mi">0</span><span class="o">]);</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NoSuchMethodException</span> <span class="n">e2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="c1">// 如果没有get等取值方法，则不放到结果中，对于处理registry的bean，需要解析各个属性参数，比如address，port，timeout等</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">getter</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">Modifier</span><span class="o">.</span><span class="na">isPublic</span><span class="o">(</span><span class="n">getter</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">())</span> <span class="o">||</span> <span class="o">!</span><span class="n">type</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">getter</span><span class="o">.</span><span class="na">getReturnType</span><span class="o">()))</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="s">"parameters"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">parameters</span> <span class="o">=</span> <span class="n">parseParameters</span><span class="o">(</span><span class="n">element</span><span class="o">.</span><span class="na">getChildNodes</span><span class="o">(),</span> <span class="n">beanDefinition</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="s">"methods"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">parseMethods</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">element</span><span class="o">.</span><span class="na">getChildNodes</span><span class="o">(),</span> <span class="n">beanDefinition</span><span class="o">,</span> <span class="n">parserContext</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="s">"arguments"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">parseArguments</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">element</span><span class="o">.</span><span class="na">getChildNodes</span><span class="o">(),</span> <span class="n">beanDefinition</span><span class="o">,</span> <span class="n">parserContext</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>

                    <span class="c1">// ok，来解析每个属性参数了</span>
                    <span class="n">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="n">property</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">trim</span><span class="o">();</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                            <span class="c1">// N/A配置，则采用new 新配置对象</span>
                            <span class="k">if</span> <span class="o">(</span><span class="s">"registry"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">RegistryConfig</span><span class="o">.</span><span class="na">NO_AVAILABLE</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">value</span><span class="o">))</span> <span class="o">{</span>
                                <span class="n">RegistryConfig</span> <span class="n">registryConfig</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RegistryConfig</span><span class="o">();</span>
                                <span class="n">registryConfig</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">RegistryConfig</span><span class="o">.</span><span class="na">NO_AVAILABLE</span><span class="o">);</span>
                                <span class="n">beanDefinition</span><span class="o">.</span><span class="na">getPropertyValues</span><span class="o">().</span><span class="na">addPropertyValue</span><span class="o">(</span><span class="n">property</span><span class="o">,</span> <span class="n">registryConfig</span><span class="o">);</span>
                            <span class="o">}</span>
                            <span class="c1">// 多注册中心配置？？</span>
                            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="s">"registry"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="sc">','</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">parseMultiRef</span><span class="o">(</span><span class="s">"registries"</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">beanDefinition</span><span class="o">,</span> <span class="n">parserContext</span><span class="o">);</span>
                            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="s">"provider"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="sc">','</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">parseMultiRef</span><span class="o">(</span><span class="s">"providers"</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">beanDefinition</span><span class="o">,</span> <span class="n">parserContext</span><span class="o">);</span>
                            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="s">"protocol"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="sc">','</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">parseMultiRef</span><span class="o">(</span><span class="s">"protocols"</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">beanDefinition</span><span class="o">,</span> <span class="n">parserContext</span><span class="o">);</span>
                            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                                <span class="n">Object</span> <span class="n">reference</span><span class="o">;</span>
                                <span class="k">if</span> <span class="o">(</span><span class="n">isPrimitive</span><span class="o">(</span><span class="n">type</span><span class="o">))</span> <span class="o">{</span>
                                    <span class="k">if</span> <span class="o">(</span><span class="s">"async"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="s">"false"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">||</span> <span class="s">"timeout"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">)</span>
                                            <span class="o">&amp;&amp;</span> <span class="s">"0"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">||</span> <span class="s">"delay"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="s">"0"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
                                            <span class="o">||</span> <span class="s">"version"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="s">"0.0.0"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
                                            <span class="o">||</span> <span class="s">"stat"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="s">"-1"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
                                            <span class="o">||</span> <span class="s">"reliable"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="s">"false"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">))</span> <span class="o">{</span>
                                        <span class="c1">// 兼容旧版本xsd中的default值</span>
                                        <span class="n">value</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                                    <span class="o">}</span>
                                    <span class="n">reference</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
                                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="s">"protocol"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">)</span>
                                        <span class="o">&amp;&amp;</span> <span class="n">ExtensionLoader</span><span class="o">.</span><span class="na">getExtensionLoader</span><span class="o">(</span><span class="n">Protocol</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">hasExtension</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
                                        <span class="o">&amp;&amp;</span> <span class="o">(!</span><span class="n">parserContext</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">().</span><span class="na">containsBeanDefinition</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">ProtocolConfig</span><span class="o">.</span><span class="na">class</span>
                                                <span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span>
                                                        <span class="n">parserContext</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">().</span><span class="na">getBeanDefinition</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
                                                                <span class="o">.</span><span class="na">getBeanClassName</span><span class="o">())))</span> <span class="o">{</span>
                                    <span class="k">if</span> <span class="o">(</span><span class="s">"dubbo:provider"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">element</span><span class="o">.</span><span class="na">getTagName</span><span class="o">()))</span> <span class="o">{</span>
                                        <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"Recommended replace &lt;dubbo:provider protocol=\""</span> <span class="o">+</span> <span class="n">value</span>
                                                <span class="o">+</span> <span class="s">"\" ... /&gt; to &lt;dubbo:protocol name=\""</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="s">"\" ... /&gt;"</span><span class="o">);</span>
                                    <span class="o">}</span>
                                    <span class="c1">// 兼容旧版本配置</span>
                                    <span class="n">ProtocolConfig</span> <span class="n">protocol</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProtocolConfig</span><span class="o">();</span>
                                    <span class="n">protocol</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
                                    <span class="n">reference</span> <span class="o">=</span> <span class="n">protocol</span><span class="o">;</span>
                                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="s">"monitor"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">)</span>
                                        <span class="o">&amp;&amp;</span> <span class="o">(!</span><span class="n">parserContext</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">().</span><span class="na">containsBeanDefinition</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">MonitorConfig</span><span class="o">.</span><span class="na">class</span>
                                                <span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span>
                                                        <span class="n">parserContext</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">().</span><span class="na">getBeanDefinition</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
                                                                <span class="o">.</span><span class="na">getBeanClassName</span><span class="o">())))</span> <span class="o">{</span>
                                    <span class="c1">// 兼容旧版本配置</span>
                                    <span class="n">reference</span> <span class="o">=</span> <span class="n">convertMonitor</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
                                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="s">"onreturn"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">))</span> <span class="o">{</span>
                                    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">lastIndexOf</span><span class="o">(</span><span class="s">"."</span><span class="o">);</span>
                                    <span class="n">String</span> <span class="n">returnRef</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>
                                    <span class="n">String</span> <span class="n">returnMethod</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                                    <span class="n">reference</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RuntimeBeanReference</span><span class="o">(</span><span class="n">returnRef</span><span class="o">);</span>
                                    <span class="n">beanDefinition</span><span class="o">.</span><span class="na">getPropertyValues</span><span class="o">().</span><span class="na">addPropertyValue</span><span class="o">(</span><span class="s">"onreturnMethod"</span><span class="o">,</span> <span class="n">returnMethod</span><span class="o">);</span>
                                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="s">"onthrow"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">))</span> <span class="o">{</span>
                                    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">lastIndexOf</span><span class="o">(</span><span class="s">"."</span><span class="o">);</span>
                                    <span class="n">String</span> <span class="n">throwRef</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>
                                    <span class="n">String</span> <span class="n">throwMethod</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                                    <span class="n">reference</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RuntimeBeanReference</span><span class="o">(</span><span class="n">throwRef</span><span class="o">);</span>
                                    <span class="n">beanDefinition</span><span class="o">.</span><span class="na">getPropertyValues</span><span class="o">().</span><span class="na">addPropertyValue</span><span class="o">(</span><span class="s">"onthrowMethod"</span><span class="o">,</span> <span class="n">throwMethod</span><span class="o">);</span>
                                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                                    <span class="k">if</span> <span class="o">(</span><span class="s">"ref"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">property</span><span class="o">)</span>
                                            <span class="o">&amp;&amp;</span> <span class="n">parserContext</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">().</span><span class="na">containsBeanDefinition</span><span class="o">(</span><span class="n">value</span><span class="o">))</span> <span class="o">{</span>
                                        <span class="n">BeanDefinition</span> <span class="n">refBean</span> <span class="o">=</span> <span class="n">parserContext</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">().</span><span class="na">getBeanDefinition</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
                                        <span class="k">if</span> <span class="o">(!</span><span class="n">refBean</span><span class="o">.</span><span class="na">isSingleton</span><span class="o">())</span> <span class="o">{</span>
                                            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"The exported service ref "</span> <span class="o">+</span> <span class="n">value</span>
                                                    <span class="o">+</span> <span class="s">" must be singleton! Please set the "</span> <span class="o">+</span> <span class="n">value</span>
                                                    <span class="o">+</span> <span class="s">" bean scope to singleton, eg: &lt;bean id=\""</span> <span class="o">+</span> <span class="n">value</span>
                                                    <span class="o">+</span> <span class="s">"\" scope=\"singleton\" ...&gt;"</span><span class="o">);</span>
                                        <span class="o">}</span>
                                    <span class="o">}</span>
                                    <span class="n">reference</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RuntimeBeanReference</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
                                <span class="o">}</span>
                                <span class="n">beanDefinition</span><span class="o">.</span><span class="na">getPropertyValues</span><span class="o">().</span><span class="na">addPropertyValue</span><span class="o">(</span><span class="n">property</span><span class="o">,</span> <span class="n">reference</span><span class="o">);</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 获取所有属性</span>
        <span class="c1">// ok,现在解析每一个节点对应的属性参数，比如 address，loadbalance等</span>
        <span class="n">NamedNodeMap</span> <span class="n">attributes</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getAttributes</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="na">getLength</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="na">item</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">getLocalName</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">props</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">parameters</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">parameters</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ManagedMap</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="n">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">();</span>
                <span class="c1">// 整了这么多，到这里终于放进ManagedMap里面去了</span>
                <span class="n">parameters</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="k">new</span> <span class="n">TypedStringValue</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">parameters</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 这里放到beanDefinition属性里面，进而在Context中就可以拿到了</span>
            <span class="n">beanDefinition</span><span class="o">.</span><span class="na">getPropertyValues</span><span class="o">().</span><span class="na">addPropertyValue</span><span class="o">(</span><span class="s">"parameters"</span><span class="o">,</span> <span class="n">parameters</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">beanDefinition</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">//.............................</span>
    <span class="o">}</span>

</code></pre></div></div>


                </div>
                <div class="read-all">
                    <a  href="/2014/10/22/Dubbo-Provider-Groups-Bug-Analyse/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
        </ul>



        <!-- Pagination links -->
        <div class="pagination">
          
            <a href="/index.html" class="previous"><i class="fa fa-angle-double-left"></i></a>
            <a href="/page3" class="previous"><i class="fa fa-angle-left"></i></a>
          
          <span class="page_number ">4/8</span>
          
            <a href="/page5" class="next"><i class="fa fa-angle-right"></i></a>
            <a href="/page8" class="next"><i class="fa fa-angle-double-right"></i></a>
          
        </div>
    </div>
    <!-- <button class="anchor"><i class="fa fa-anchor"></i></button> -->
    <div class="right">
        <div class="wrap">
            <div class="side">
                <div>
                    <i class="fa fa-pencil-square-o" aria-hidden="true"></i>
                    Recent Posts
                </div>
                <ul class="content-ul" recent>
                    
                        <li><a href="/2017/03/29/java-server-in-action/">深入浅出Java服务端原理之基础篇</a></li>
                    
                        <li><a href="/2016/12/10/rpc-theory-in-action/">深入浅出RPC原理</a></li>
                    
                        <li><a href="/2016/05/29/talk-about-java-gc/">聊聊 Java GC</a></li>
                    
                        <li><a href="/2016/04/29/thrift-service-discory-using-zookeeper-ourea/">Ourea-基于Zookeeper的Thrift服务发现框架实现</a></li>
                    
                        <li><a href="/2016/03/10/junit-mockito-guice-in-action-and-junit-test-mechanism/">基于JUnit Mockito Guice测试实践及JUnit运行机制浅析</a></li>
                    
                        <li><a href="/2016/01/02/delayed-message-consume-service-use-kafka/">基于kafka的定时消息/任务服务</a></li>
                    
                        <li><a href="/2015/09/05/zookeeper-programmer-guide/">Zookeeper 编程指南</a></li>
                    
                        <li><a href="/2015/08/30/nginx-proxy-configure-and-sduty/">Nginx 反向代理配置和工作原理</a></li>
                    
                        <li><a href="/2015/04/29/LogBack-Implemention-And-Slf4j-Mdc/">Slf4j MDC 使用和 基于 Logback 的实现分析</a></li>
                    
                        <li><a href="/2015/02/26/Python-Tutoril-Python-Object-Oriented-Programming/">Python 教程学习之 Python 面向对象编程</a></li>
                    
                </ul>
            </div>

            <!-- Content -->
            <div class="side ">
                <div>
                    <i class="fa fa-th-list"></i>
                    Categories
                </div>
                <ul class="content-ul" cate>
                    
                    <li>
                        <a href="/category/#Java" class="categories-list-item" cate="Java">
                            <span class="name">
                                Java
                            </span>
                            <span class="badge">19</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#IDE" class="categories-list-item" cate="IDE">
                            <span class="name">
                                IDE
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Log" class="categories-list-item" cate="Log">
                            <span class="name">
                                Log
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Thread" class="categories-list-item" cate="Thread">
                            <span class="name">
                                Thread
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Spring" class="categories-list-item" cate="Spring">
                            <span class="name">
                                Spring
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#GC" class="categories-list-item" cate="GC">
                            <span class="name">
                                GC
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Mysql" class="categories-list-item" cate="Mysql">
                            <span class="name">
                                Mysql
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Script" class="categories-list-item" cate="Script">
                            <span class="name">
                                Script
                            </span>
                            <span class="badge">3</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Linux" class="categories-list-item" cate="Linux">
                            <span class="name">
                                Linux
                            </span>
                            <span class="badge">5</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Python" class="categories-list-item" cate="Python">
                            <span class="name">
                                Python
                            </span>
                            <span class="badge">5</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Redis" class="categories-list-item" cate="Redis">
                            <span class="name">
                                Redis
                            </span>
                            <span class="badge">6</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Redis Cookbook" class="categories-list-item" cate="Redis Cookbook">
                            <span class="name">
                                Redis Cookbook
                            </span>
                            <span class="badge">6</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#tools" class="categories-list-item" cate="tools">
                            <span class="name">
                                tools
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Json" class="categories-list-item" cate="Json">
                            <span class="name">
                                Json
                            </span>
                            <span class="badge">3</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Dubbo" class="categories-list-item" cate="Dubbo">
                            <span class="name">
                                Dubbo
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Git" class="categories-list-item" cate="Git">
                            <span class="name">
                                Git
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Nginx" class="categories-list-item" cate="Nginx">
                            <span class="name">
                                Nginx
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Zookeeper" class="categories-list-item" cate="Zookeeper">
                            <span class="name">
                                Zookeeper
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Translation" class="categories-list-item" cate="Translation">
                            <span class="name">
                                Translation
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Kafka" class="categories-list-item" cate="Kafka">
                            <span class="name">
                                Kafka
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#JUnit" class="categories-list-item" cate="JUnit">
                            <span class="name">
                                JUnit
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Guice" class="categories-list-item" cate="Guice">
                            <span class="name">
                                Guice
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Thrift" class="categories-list-item" cate="Thrift">
                            <span class="name">
                                Thrift
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#rpc" class="categories-list-item" cate="rpc">
                            <span class="name">
                                rpc
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#dubbo" class="categories-list-item" cate="dubbo">
                            <span class="name">
                                dubbo
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#thrift" class="categories-list-item" cate="thrift">
                            <span class="name">
                                thrift
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#java" class="categories-list-item" cate="java">
                            <span class="name">
                                java
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#socket" class="categories-list-item" cate="socket">
                            <span class="name">
                                socket
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <div class="side">
                <div>
                    <i class="fa fa-tags"></i>
                    Tags
                </div>
                <div class="tags-cloud">
                    
                    
                    
                    

                    

                    
                </div>
            </div>

            <!-- <div class="side">
                <div>
                    <i class="fa fa-external-link"></i>
                    Links
                </div>
                <ul  class="content-ul">

                </ul>
            </div> -->
        </div>
    </div>
</div>
<!-- <script src="/js/scroll.min.js " charset="utf-8"></script> -->
<!-- <script src="/js/pageContent.js " charset="utf-8"></script> -->


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
             本站保留着一点点技术积蓄！ 
        </p>
        <p class="contact">
            Contact me at: 
            <a href="https://github.com/ketao1989" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a>  
            <a href="mailto:ketao1989@126.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>  
            <a href="http://weibo.com/柯小小西" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a>       
        </p>
        <p>
            本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </p>
        <p class="power">
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>.
            </span>
            <span>
                Theme designed by <a href="https://github.com/Gaohaoyang">HyG</a>.
            </span>
        </p>
    </div>
</footer>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <div class="back-to-top">
    <a href="#top" data-scroll>
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /js/main.js " charset="utf-8"></script>
    <script src=" /js/smooth-scroll.min.js " charset="utf-8"></script>
    <script type="text/javascript">
      smoothScroll.init({
        speed: 500, // Integer. How fast to complete the scroll in milliseconds
        easing: 'easeInOutCubic', // Easing pattern to use
        offset: 20, // Integer. How far to offset the scrolling anchor location in pixels
      });
    </script>
    <!-- <script src=" /js/scroll.min.js " charset="utf-8"></script> -->
  </body>

</html>
