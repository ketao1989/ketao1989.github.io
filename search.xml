<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>业务监控告警的一点思考</title>
      <link href="2020/11/26/2020-11-26-biz-monitor-experience/"/>
      <url>2020/11/26/2020-11-26-biz-monitor-experience/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>很多开发同学，只关心功能开发和上线，上线后的运维工作，作为软件产品的生命周期中非常重要的一个环节，常常被忽视。即使一些同学可能有一些意识知道要关心产品上线后的情况，但是不知道如何去下手。</p><p>在这里，我们主要从开发的角度，聊聊如何做好软件上线后的监控，以及异常情况下的告警。</p><p>（这里，不会去关心业务层面上的一些运行数据，比如GMV，PV等等，虽然这些数据的异常变化，可能也跟系统稳定性也存在一些关系）</p><h2 id="1-1-为什么关心监控"><a href="#1-1-为什么关心监控" class="headerlink" title="1.1 为什么关心监控"></a>1.1 为什么关心监控</h2><p>真实世界中，我们不会构建一个100%稳定可靠的服务，一个是因为各种软件上的bug或者硬件设备的故障，再或者各种人为操作的配置问题或者网络问题等等；二是因为如果我们保证极端可靠性，解决前面的问题，其超高成本带来的收益非常低，低到所有公司，哪怕是Google也不会去接受。</p><span id="more"></span><p>因此，我们需要做的是，在产品整体成本可接受的情形下，尽量通过后期运维手段来降低服务不可用时间，从而提高服务的SLA，保证服务的高可靠性。</p><p>而，降低服务不可用时间，就需要做到最快发现故障问题，最快解决故障问题。这些就需要监控来辅助开发解决。</p><p>因此，在【Site Reliability Engineering: How Google Runs Production Systems】书中，介绍了一些监控场景，这里抽取一些进行说明：</p><p>分析长期趋势。比如，根据当前数据库数据量的增长速度和存量情况，可以提前发现数据库容量问题等，提早改造来规避可能的故障。<br>跨时间范围的比较。比如老的接口新加了redis缓存之后，响应是不是比之前快了很多，可以上线前后的时间区间接口rt做一个对比拿到结论。<br>问题关联分析。比如，我们发现某个接口的rt增长了，分析原因，可以看看其他监控数据是不是也出现关联变化，比如可能是请求量暴增，或者下游依赖的接口出现响应变慢的问题。然后，再采取对应的方案去解决。<br>也就是，从监控上，我们可以获取到 系统各个维度的请求情况，处理情况。</p><h2 id="1-2-为什么需要告警"><a href="#1-2-为什么需要告警" class="headerlink" title="1.2 为什么需要告警"></a>1.2 为什么需要告警</h2><p>有了监控大盘，我们就可以随时观察系统运行状况。但是，系统不会在我们看大盘的时候，才出现异常情况，因此，我们需要主动快速去发现系统可能的异常点，将可能的系统失败阻挡在产品故障之前，或者刚刚开始的时候。</p><h1 id="二、监控"><a href="#二、监控" class="headerlink" title="二、监控"></a>二、监控</h1><h2 id="2-1-监控什么"><a href="#2-1-监控什么" class="headerlink" title="2.1 监控什么"></a>2.1 监控什么</h2><p>前面说，我们的服务不会存在百分百可靠，所以对服务而言就存在一定的不确定性，这个不确定性，就是风险。</p><p>和业务一样，存在风险，我们就需要对风险进行管理。监控的对象或者说目标，就是风险。</p><h3 id="2-2-1-业务风险"><a href="#2-2-1-业务风险" class="headerlink" title="2.2.1 业务风险"></a>2.2.1 业务风险</h3><p>所谓风险，也就是不确定性，与之对应的就是服务的可用性。一般，现有衡量业务可用性，最常用的是：系统正常运行时间/（系统正常运行时间+停机时间）</p><p>虽然，我们在很多文章或者宣传册中，都用这个时间比来宣传系统的可用性，4个9，5个9啥的，但是，这种时间维度的可用性，在当前微服务化的时代，衡量服务可用性毫无意义。</p><p>这里，我们使用另一种计算公式：请求成功数/(请求成功数 + 请求失败数) = 请求成功数/ 请求总数。例如，一个服务，一天请求总数10000次，失败1次，那就是99.99%。</p><p>因此，我们在监控的时候，肯定是需要监控请求总数，成功数，对应失败数的。</p><p>但是，不同服务，相同服务不同的业务源，对于服务风险的诉求是不一样，比如，实时用户登录查询用户信息的请求，和定时任务跑脚本时获取用户信息请求，对服务的容忍度显然是不一样的。</p><p>因此，我们需要针对风险，分出个三六九等。</p><h3 id="2-2-2-业务风险容忍度"><a href="#2-2-2-业务风险容忍度" class="headerlink" title="2.2.2 业务风险容忍度"></a>2.2.2 业务风险容忍度</h3><p>和风控中风险识别规则一样，不同场景下识别风险的规则阈值一般会存在不同。而，在风控中，我们会针对不同接入业务，按照业务属性，配置不同的阈值和规则，来识别、监控风险。</p><p>业务系统监控，一样需要这么做。</p><p>因此，我们就需要梳理，一个服务接口，是否需要针对不同接入场景，单独出来不同的监控大盘，进行更专业的风险监控。</p><p>那么，接下来就是监控关注的第二个点：判断业务对外接口或者实现逻辑内部，哪些点存在风险，或者有助于我们发现相关风险，做好埋点，制好大盘。</p><p>举几个例子：</p><p>场景一、准入提供通用的决策接口，外部一些地方需要做风险判断时，都通过改接口接入。这个时候，肯定会存在一个现象：不同业务对失败的容忍度是不一样的，因此对不同业务做细粒度的埋点监控，是必要的，对应可能还会做服务细粒度的隔离，限流措施。</p><p>场景二、特征中心会提供大量指标查询，从接口层面看如果总qps1w，失败10，千一的失败率，可能怀疑是网络抖动，偶尔超时等问题。但是从细粒度监控上，发现某个API/指标的特征查询qps 10，失败10，百分比的失败率，则需要立马去查原因了。</p><h3 id="2-2-3-具化容忍度–风险带来的故障程度"><a href="#2-2-3-具化容忍度–风险带来的故障程度" class="headerlink" title="2.2.3 具化容忍度–风险带来的故障程度"></a>2.2.3 具化容忍度–风险带来的故障程度</h3><p>和上面风险容忍度类似，如果某个接口出现问题，会导致业务故障，那么必然需要进行监控。</p><p>比如，提供给电商交易主链路使用的风险决策接口，如果RT超过约定的超时时间，这个时候即使我们都是成功返回，但是对于业务方而言，其实对业务是有损的，甚至会导致业务故障。</p><p>因此，对于业务RT的监控，尤其是某些重要请求业务方细粒度的RT监控，是非常必要的。</p><p>回到故障程度，故障程度其实是风险容忍度一个具化的点。我们可能不知道业务方的容忍程度，那么我们就看业务方会不会因为我们接口返回失败/超时，导致出现有损服务，甚至故障。</p><h3 id="2-2-4-风险溯源"><a href="#2-2-4-风险溯源" class="headerlink" title="2.2.4 风险溯源"></a>2.2.4 风险溯源</h3><p>当我们从大盘上发现风险/系统问题的时候，我们最需要做的就是找出原因，也就是风险溯源。</p><p>风险出现的原因，分为外部原因和内部原因。外部原因，就是基础中间件组件，外部依赖的接口等出现问题影响了我；内部原因，就是自己代码bug导致的失败问题影响了最终返回。</p><p>针对外部原因，我们监控的东西其实很明显：依赖三方接口（包括基础中间件）的成功数，失败数，RT耗时等，其实就是我们在基础设施层中的所有实现接口，都需要进行监控。</p><p>针对内部原因，通常，一些非预期异常数需要监控；此外，一般而言，对于RT敏感的服务，内部核心逻辑的耗时需要监控，甚至需要细粒度的场景耗时监控。</p><h3 id="2-2-5-总结"><a href="#2-2-5-总结" class="headerlink" title="2.2.5 总结"></a>2.2.5 总结</h3><p>说了这么多，总结一下，我们到底需要监控哪些东西。</p><p>就两个：次数，耗时。所有你根据上面一些原则，总结梳理出来的风险相关点，都需要去监控。</p><h1 id="三、告警"><a href="#三、告警" class="headerlink" title="三、告警"></a>三、告警</h1><p>告警，其实就是风险触达，或者预期风险触达。</p><h2 id="3-1-告警现状"><a href="#3-1-告警现状" class="headerlink" title="3.1 告警现状"></a>3.1 告警现状</h2><p>说触达可能有点专业术语，其实就是你收到的各种APP通知，营销短信通知，广告电话通知之类的。就问你，没完没了，你根本就不需要的通知，你烦不烦！</p><p>现在，存在一种现象，就是系统要不没有告警，要不就是一堆告警。ERROR日志报警，企业微信各种同比环比告警，失败数、耗时等超阈值告警，等等。</p><p>目前有的告警，大部分设置之初是合理的。但是，随着业务不断发展，系统不断优化，很多一直告警就需要进行调整或者删除了。</p><p>但是，开发同学并没有同步去调整这些设置，导致无效告警越来越多，最后大家产生疲劳，对需要关注的告警也忽略了。</p><h2 id="3-2-告警什么"><a href="#3-2-告警什么" class="headerlink" title="3.2 告警什么"></a>3.2 告警什么</h2><p>如何做风险触达？做什么风险数据的触达？</p><h3 id="3-2-1-风险触达"><a href="#3-2-1-风险触达" class="headerlink" title="3.2.1 风险触达"></a>3.2.1 风险触达</h3><p>所谓风险触达，就是我发现系统存在故障，或者可能即将存在故障的时候，给相关同学进行告警通知。让开发同学立马去追踪系统问题，恢复服务，或者采取其他措施避免即将出现的服务不可用。</p><p>风险触达，首先需要准确触达，然后就是智能触达。当然智能也分三六九等。所谓智能触达，就是一个故障，可能会导致大量告警设置都被触发，这个时候，可以根据关联或者历史学习，直接将原因告警进行推送。</p><p>这里，我们基于目前的告警平台来配置告警，所以目前要做的是准确性。准确性包含两个方面，风险准确，对象准确。</p><p>所谓风险准确，按照目前告警平台设置而已，就是阈值设置是合理的。触发监控阈值的告警，确实是存在异常情况，避免一堆非异常告警，耗费大家的精力；其次，该有的告警要有，不能系统出现异常或者故障了，没有相关的告警被触达给开发同学。</p><p>所谓对象准确，就是我们告警通知的对象，要设置合理，不要随意设置一堆人。告警对象需要在告警通知时，及时响应告警，查找问题，回复告警原因。因此，该业务owner，备份owner，必须要指定清楚。非相关干系人，一般不需要设置，除非一些特殊情况，比如特征中心的接口，使用三方数据采集系统的指标监控告警，那么可以加上三方系统的owner。</p><h3 id="3-2-2-风险准确触达"><a href="#3-2-2-风险准确触达" class="headerlink" title="3.2.2 风险准确触达"></a>3.2.2 风险准确触达</h3><p>要做到准确触达，其实挺难的，而且要不断优化不断调整。</p><p>告警设置，首先有个问题，就是是针对现象设置告警，还是针对原因设置告警。如果我们对业务十分熟悉，只要出现原因级别的告警，就知道哪些对外业务会存在问题，但是，现阶段，我们优先对现象进行告警，然后在日常问题中对原因也设置告警，不过不建议不告警现象。</p><p>比如，我们监控的对外接口RT耗时过大告警，然后数据库查询耗时过大告警，都出现了。这里，接口告警其实是现象告警，数据库sql慢告警就是“原因”告警。当然，再底层原因，可能是数据量大导致sql慢，也可能请求多导致sql慢，或者机器本身原因导致sql执行慢，需要具体看。(所以这里”原因”打了引号。)</p><p>因此，简单而言，我们现在，对所有我们关心的监控大盘，进行告警设置。</p><p>确认好了针对啥去设置告警，接下来需要考虑告警阈值如何设置。</p><p>一般而言，我们对上线的服务，可以做一个大致的预估，给出一些阈值。比如，预估准入决策下，某个场景业务就最高也就10qps，那么我们就按照10qps来去做一些阈值设置。</p><p>还有一种比较简单的情况，就是业务正常运行几天，通过运行的数据，来推测合理请求量，合理失败率，合理耗时等等，然后来设置告警阈值，在通过告警的一些反馈，不断修正阈值，最后接近正确的触达。</p><h3 id="3-2-3-告警维度"><a href="#3-2-3-告警维度" class="headerlink" title="3.2.3 告警维度"></a>3.2.3 告警维度</h3><p>嗯，针对监控大盘，我们需要怎样设置异常告警。</p><p>划重点！！！</p><p>以下是多年经验的总结，抛砖引玉。</p><h4 id="系统请求量类告警"><a href="#系统请求量类告警" class="headerlink" title="系统请求量类告警"></a>系统请求量类告警</h4><ul><li>我们预估一个服务的处理能力是QPS 1w，那么当请求量超过1w的时候，就肯定需要告警，或者当请求接近1w的时候，就需要告警，给开发同学一个时间提前准备；</li><li>假设，当我们预估正常的请求量都在10以上，那么我们就需要设置一个低于10的QPS告警，这类告警阈值需要考虑清楚，避免低峰期间无效告警。</li></ul><h4 id="系统耗时类告警"><a href="#系统耗时类告警" class="headerlink" title="系统耗时类告警"></a>系统耗时类告警</h4><ul><li>我们预估一个服务的最大处理RT 50ms，那么当1分钟（天网监控粒度）超过50ms，就需要告警；</li><li>假设，针对某些对外服务的业务，请求方超时设置30ms，则意味着我们需要对这些进行告警，当平均耗时超过30ms时，需要告警，这意味着上游业务都是失败的。</li></ul><h4 id="系统异常类告警"><a href="#系统异常类告警" class="headerlink" title="系统异常类告警"></a>系统异常类告警</h4><ul><li>我们预估对外服务的接口，能够容忍的一个系统失败数10，那么当失败数超过10，就需要告警（这类告警很容易变成无效告警，所以需要根据业务发展进行调整）；</li><li>同样，某个业务可能容忍的失败数比较大，直接用本系统的失败告警，但是有些业务可能请求数比较小，但是业务还很重要，这个时候需要针对这些业务细粒度设置告警阈值。</li></ul><h4 id="系统同比环比告警"><a href="#系统同比环比告警" class="headerlink" title="系统同比环比告警"></a>系统同比环比告警</h4><p>某些情况下，无法给直接阈值。一般而言，因为电商交易很多时候以周为周期，所以可以采用周同比，环比一般因为业务一直不断发展，可参照价值反而比较小。</p><ul><li>针对请求量和异常类次数告警，可以采用周同比的方式，去设置一些震荡比率，触发告警。比如异常次数周同比增幅20%，可能认为系统存在未知问题，需要定位。</li></ul><h3 id="3-2-4-总结"><a href="#3-2-4-总结" class="headerlink" title="3.2.4 总结"></a>3.2.4 总结</h3><p>依然做一个总结，我们要怎么做告警。</p><p>因为监控是基于对业务的梳理，所以告警前期针对监控大盘（现象）进行合理阈值的设置即可；后期，逐步针对一些原因监控，设置阈值告警。目的，同时接收现象和原因告警，可以关联起来，从而收到告警的时候，能大致感知到系统异常原因。</p><h3 id="3-2-5-最后"><a href="#3-2-5-最后" class="headerlink" title="3.2.5 最后"></a>3.2.5 最后</h3><p>告警，有新增就得有删除。</p><p>如果一个告警出现之后，没有人去关注，或者不需要去关注，那么这个告警需要删除或者调整了；<br>如果一个告警出来之后，接收人不明所以，或者根本猜都猜不出来原因，那么这个报警是无价值的，需要其他原因告警项来新增进来，辅助决策；<br>如果一个告警十分频繁的触发，那么请立马修复问题，或者调整告警阈值。<br>告警内容，最大的价值，是不上线也能大概知道哪里除了问题，如果做不到，那么告警的优化还需要持续进行…….</p><h1 id="四、日志"><a href="#四、日志" class="headerlink" title="四、日志"></a>四、日志</h1><p>日志，目的是为了协查问题。所以，日志需要规范化，正式化。</p><h2 id="4-1-日志内容"><a href="#4-1-日志内容" class="headerlink" title="4.1 日志内容"></a>4.1 日志内容</h2><p>日志的目的，是为了发现异常，定位问题。所以，如果一个参数失败，但是不把参数打出来，你怎么知道为啥参数失败。</p><p>日志打印，可以使用日志模板。根据自己的喜好，可以分多个日志文件，或者业务日志都放在一个文件里。日志需要上传到天网，便于分布式环境下，查问题。</p><p>划重点！！！</p><p>日志需要打印哪些内容。</p><ul><li>对外服务的请求入参，返回出参 ；</li><li>对外服务的请求整体耗时，不管成功失败，都需要打印耗时。</li><li>依赖的三方服务，请求发起的参数和时间，请求接收到的参数和耗时。</li><li>所有业务失败，抛异常的地方，都需要打印日志，包括异常堆栈，功能描述，失败原因，可能查问题时需要的上下文数据。</li><li>所有非预期异常或失败，打印ERROR级别日志，预期的失败异常，一般使用WARN级别日志级别即可。</li><li>打印日志，必须要有traceid，便于调用链查询，需要关注的功能简述，使用中文，且放在日志内容前面，便于天网日志平台检索。例如，log.info(“[支付预下单]业务请求request:{}”,request) 或者 log.info(“[{}]业务请求request:{}”,this.getClass().getSimpleName(),request)</li></ul><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>SRE 一般讲 四个黄金指标：延迟，流量，错误 ，饱和度。</p><ul><li>延迟：处理请求所需要的耗时，区分成功和失败都需要；</li><li>流量：针对系统负载需求锁进行度量的指标，例如QPS，TPS等；</li><li>错误：请求失败的速率；</li><li>饱和度：服务容量有多满。受限资源指标度量，例如内存利用率，IO利用率等。</li></ul><p>以上，根据实践过程，随时调整和补充。</p>]]></content>
      
      
      <categories>
          
          <category> monitor </category>
          
          <category> stability </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>系统结构分层规范总结</title>
      <link href="2020/04/27/2020-04-27-ddd-system-arch-code/"/>
      <url>2020/04/27/2020-04-27-ddd-system-arch-code/</url>
      
        <content type="html"><![CDATA[<h1 id="一、通用DDD架构"><a href="#一、通用DDD架构" class="headerlink" title="一、通用DDD架构"></a>一、通用DDD架构</h1><p>首先，看下图：<br><img src="/images/2020/system-arch-level.png" alt="系统分层结构对比"></p><p>左图、是经典的DDD架构分层图。右图、在使用依赖倒置原则下的分层图。</p><p>两个结构图对比，最典型的区别就是基础设施层，在最上层还是最底层。由于，我们项目都在使用spring或者guice等ioc工具，所以推荐使用右图的分层架构。</p><span id="more"></span><p>在DDD中，推崇使用端口适配器模式（也叫六边形架构）来做服务代码边界切分，系统内部处理自己的领域服务，通过适配器接口方式和外部进行交互。简而言之，即模块层次之间面向接口开发，内部无约束。如下图：<br><img src="/images/2020/adapter-core.png" alt="六边形架构"></p><h1 id="二、项目结构分层实践"><a href="#二、项目结构分层实践" class="headerlink" title="二、项目结构分层实践"></a>二、项目结构分层实践</h1><p>按照DDD架构的思想，结合我们日常使用场景，列出通用的项目代码模块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;<span class="keyword">module</span>&gt;dragonfly-api&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">module</span>&gt;dragonfly-infrastructure&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">module</span>&gt;dragonfly-deploy&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">module</span>&gt;dragonfly-application&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">module</span>&gt;dragonfly-presentation&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">module</span>&gt;dragonfly-domain&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">module</span>&gt;dragonfly-common&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">&lt;/modules&gt; </span><br></pre></td></tr></table></figure><p>对外部署，为dragonfly-deploy模块，该模块会集成其他所有模块，因此，给出目前项目结构图：<br><img src="/images/2020/ddd-system-arch.png" alt="DDD代码结构分层"></p><p>** 和传统分层架构，最大的不同，在于我们把基础设施层dragonfly-infrastructure放在最上层。参考六边形架构，我们其实只区分上下两层，基础设施层位于上层，其他位于下层。**</p><p>** 因此，基础设施层负责实现图三中应用内部整块的适配器(接口)，而领域层，应用层负责提供需要外部实现的能力接口即可。**</p><p>下面，具体来介绍每一个模块（排除dragonfly-api和dragonfly-deploy两个场景模块）的定位和使用。</p><h2 id="2-1-基础设施层-dragonfly-infrastructure"><a href="#2-1-基础设施层-dragonfly-infrastructure" class="headerlink" title="2.1 基础设施层 dragonfly-infrastructure"></a>2.1 基础设施层 dragonfly-infrastructure</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基础设施层。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 最上层的基础设施层，主要提供使用基础能力的实现，例如持久化能力，nsq、邮件、短信等异步消息能力，还有远程服务调用能力等。</span></span><br><span class="line"><span class="comment"> * 位于最上层，需要依赖spring框架的依赖倒置能力，这样子使用方模块只需要调用接口，而不需要引入实现类。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 例如，仓储层的接口定义和实现，按照传统定义都在domain层。但是按照目前的定位，则仓储层的接口定义在domain层，而实现则在基础设施层。</span></span><br><span class="line"><span class="comment"> * 至于，基础设施层，是使用mysql存储，还是使用hbase，es持久化，则是基础设施层实现接口的多个adapter后的设置。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="2-2-用户接口层-dragonfly-presentation"><a href="#2-2-用户接口层-dragonfly-presentation" class="headerlink" title="2.2 用户接口层 dragonfly-presentation"></a>2.2 用户接口层 dragonfly-presentation</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户接口层（展现层）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 用户接口层，只处理用户显示和用户请求。它不包含领域或者业务逻辑。一些对用户参数的简单合法性验证，可以在该层进行；</span></span><br><span class="line"><span class="comment"> * 但是如果涉及权限，复杂的判断等，则不归属该层进行。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 为了和领域模型进行解耦，在展现层会有自己的展现模型（Request(xxDto) &amp; Result(xxDto)）进行对外数据输出。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 用户接口层，是应用层的直接客户。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="2-3-应用层-dragonfly-application"><a href="#2-3-应用层-dragonfly-application" class="headerlink" title="2.3 应用层 dragonfly-application"></a>2.3 应用层 dragonfly-application</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 应用层。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 应用服务，位于应用层中。应用服务和领域服务是不同的，因此领域服务不应该出现在应用服务中。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 应用服务，可以用于控制持久化事务和安全认证，或者向其他系统发送事件的消息通知，另外还可以用于创建邮件以发送给用户。</span></span><br><span class="line"><span class="comment"> * 应用服务不处理业务逻辑，它是领域模型的直接客户，应用服务是轻量级的，主要用于协调对领域对象的操作，例如聚合。同时，</span></span><br><span class="line"><span class="comment"> * 应用服务是表达用例和用户故事的主要手段。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 因此，应用服务的通常用途：接收来自用户界面（展现层）的输入参数，通过仓储服务获取聚合实例，然后执行相应的命令操作即可；</span></span><br><span class="line"><span class="comment"> * 当然，应用服务，也可以拿到领域服务，完成相关领域的任务操作。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="2-4-领域层-dragonfly-domain"><a href="#2-4-领域层-dragonfly-domain" class="headerlink" title="2.4 领域层 dragonfly-domain"></a>2.4 领域层 dragonfly-domain</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 领域层。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 在DDD最核心的模块，就是领域层。在领域层中，主要包括实体(唯一id，生命周期)，值对象（不会变化，直接替换，没有id来表示值对象的唯一性）。</span></span><br><span class="line"><span class="comment"> * 此外，还有领域服务和领域事件。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 需要重点的说，在DDD中，实体内部是会有业务操作的，因此领域服务，是在实体内部不好实现的情况下，才出现的。比如操作多个领域对象来生成一个值对象，</span></span><br><span class="line"><span class="comment"> * 或者对一个领域对象进行转换等。随意的领域服务，就会导致领域对象的贫血模型。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 实体具有哪些行为，决定了实体内部需要实现哪些服务。比如，一个账号，有状态转变，有效无效，绑定等，这些就是这个实体的行为，也就是实体内部要实现的方法。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 此外，如果一个服务没有多种实现，并且也不存在接口和实现位于多个模块中时，不需要去额外定义一个接口。直接创建一个实现类即可。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="2-5-通用工具集-dragonfly-common"><a href="#2-5-通用工具集-dragonfly-common" class="headerlink" title="2.5 通用工具集 dragonfly-common"></a>2.5 通用工具集 dragonfly-common</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用工具集。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 这个模块，主要聚合一些通用的工具类，还有包括一些常量，自定义异常，错误码等，便于统一管理。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 对于一些特定的工具类，由于在使用的时候，可能做了入参的前置校验和场景确认，在工具方法实现的时候，最简化处理。这种工具类NOT！！！放在这里，</span></span><br><span class="line"><span class="comment"> * 避免其他人直接使用，导致非预期结果。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 由于通用工具集，提供项目中其他所有模块使用，所以这里位于所有模块的最底层。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="三、一些实践中的重点"><a href="#三、一些实践中的重点" class="headerlink" title="三、一些实践中的重点"></a>三、一些实践中的重点</h1><blockquote><blockquote><p>待后续补充</p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> stability </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Netty系列--NIO学习</title>
      <link href="2018/05/05/2018-05-05-netty-series-of-nio/"/>
      <url>2018/05/05/2018-05-05-netty-series-of-nio/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Netty官方文档：Netty是一款异步的事件驱动的网络应用程序框架，支持快速地开发可维护的高性能的面向协议的服务器和客户端。</p></blockquote><p>其实，在官网 <a href="https://netty.io/">https://netty.io/</a> 中特别指出，netty是基于NIO的网络通信框架。因此，在学习Netty之前，先熟悉java NIO组件。一般，我们说NIO，指的是非阻塞IO (Non-blocking IO)。</p><h1 id="1-I-O模型"><a href="#1-I-O模型" class="headerlink" title="1. I/O模型"></a>1. I/O模型</h1><p><br>在计算机开发领域中，一个服务的性能受制于两方面：CPU处理能力和I/O处理能力。也就是说，我们希望我们的服务，可以消耗更少的CPU计算单元，消耗更少的I/O处理等待时长。</p><p>因此，由于I/O性能对整个系统的影响如此重要，在很多系统里，尽量来避免IO问题。例如，Redis通过使用内存，异步刷磁盘来提高IO性能，保证系统的处理能力。</p><p>当然，在很多时候，我们是避免不了I/O性能的制约的。比如，网络通信，就是一个典型的I/O问题。在优化I/O问题之前，先来聊聊I/O模型。</p><p>在《UNIX网络编程卷1》中，将I/O模型分为5种：</p><ul><li>阻塞式I/O；</li><li>非租塞式I/O；</li><li>I/O复用(select，poll，epoll等)；</li><li>信号驱动式I/O(SIGIO)；</li><li>异步I/O(POSIX的aio_系列函数)</li></ul><p>在区分阻塞和非租塞，异步和同步之前，先介绍下，一个输入操作主要包括两个阶段：</p><ol><li>等待数据准备好；</li><li>从内核向进程复制数据。</li></ol><p>对于一个网络I/O请求来说，第一步就是等待网络通信的数据传输到服务器上，系统内核会将所有传输过来的数据保存在对应位置的缓冲区中；第二步就是将网络的数据从内核区复制到用户进程的缓冲区中，然后应用就可以处理。</p><span id="more"></span><h2 id="1-1-概念解释"><a href="#1-1-概念解释" class="headerlink" title="1.1 概念解释"></a>1.1 概念解释</h2><h3 id="1-1-1-同步和异步"><a href="#1-1-1-同步和异步" class="headerlink" title="1.1.1 同步和异步"></a>1.1.1 同步和异步</h3><p>所谓同步，就是系统中最小CPU调度单位在执行任务的过程中，前一个任务没有执行完成返回之前，是一直处于阻塞的状态，不行进行后续的动作。</p><p>与此相反，所以异步，就是前一个任务执行还未完成的时候，其也可以执行后续的动作，而不需一直处理等待过程中。</p><p>在I/O模型中：<br>我们通常认为，同步就是在整个输入过程中，线程都是处理等待的状态，直到用户态的进程缓冲区中有了数据可以触发后续执行；<br>而异步，执行发出数据请求之后，直接返回执行后续的动作，直到内核数据接收完成拷贝到进程缓冲区之后，触发预先设置的回调动作。因此，我们说nodeJs是异步的，就是因为nodejs都是通过各种回调函数来处理I/O请求的。</p><h3 id="1-1-2-阻塞和非阻塞"><a href="#1-1-2-阻塞和非阻塞" class="headerlink" title="1.1.2 阻塞和非阻塞"></a>1.1.2 阻塞和非阻塞</h3><p>所谓阻塞，就是系统中细小CPU调用单位在执行任务过程中，需要一些条件准备好之后，等待条件确认满足，才能返回继续执行。</p><p>与此相反，所谓非阻塞，就是执行任务的时候，如果需要一些条件准备好时，系统不会一直处在等待的状态，而是返回一个标识，然后，可能会循环check条件是否满足。</p><p>在I/O模型中：<br>我们通常认为，阻塞就是在输入过程中，如果数据没有准备好，线程会一直处理等待准备数据的动作完成；<br>而非阻塞，则不会盲目去等待所有数据完成，而是内核会立刻返回一个错误标识，系统根据这个标识来循环的去check数据是否准备好。等数据准备好了之后，再由进程把数据复制到进程缓冲区中。</p><h3 id="1-1-3-总结"><a href="#1-1-3-总结" class="headerlink" title="1.1.3 总结"></a>1.1.3 总结</h3><p>从上面的介绍，可以看出，阻塞和同步，非阻塞和异步，并没有什么必然的等号关系。完全是两个不同维度的定义。<br>比如说，非阻塞I/O也会是同步I/O；虽然说异步I/O必然是非阻塞的。</p><h2 id="1-2-阻塞和多路复用I-O"><a href="#1-2-阻塞和多路复用I-O" class="headerlink" title="1.2 阻塞和多路复用I/O"></a>1.2 阻塞和多路复用I/O</h2><p>虽然有5中I/O模型，但是实际上，我们用的最多的就是2种。阻塞I/O和多路复用I/O(Java中的非阻塞NIO)。</p><h3 id="1-2-1-阻塞式I-O"><a href="#1-2-1-阻塞式I-O" class="headerlink" title="1.2.1 阻塞式I/O"></a>1.2.1 阻塞式I/O</h3><p>上文介绍了，I/O分成两个阶段，而这两个阶段都是处理等待的时候，则是阻塞式I/O。如下图：</p><p><img src="/images/2018/block_io.png" alt="阻塞式I/O模型"></p><p>在上图中，调用recvfrom，系统调用直到数据包到达并且数据被复制到应用的缓冲区时才返回，而在此之间，进程一直处理阻塞等待的状态。</p><h3 id="1-2-2-多路复用I-O"><a href="#1-2-2-多路复用I-O" class="headerlink" title="1.2.2 多路复用I/O"></a>1.2.2 多路复用I/O</h3><p>如上面非租塞I/O所述，系统在知道数据未准备好的时候，会根据标识，不停的轮询内核拿到结果，其实这对于系统性能而言，并不是十分友好。</p><p>于是，多路复用I/O将其拆成两个方法调用，首先以“准非阻塞方式”等待数据准备好，然后再来copy数据。如下图所示：</p><p><img src="/images/2018/multi_io.png" alt="多路复用I/O模型"></p><p>实际上，多路复用就是用一个统一的内核线程来管理所有需要获取数据的请求，当统一线程发现有数据准备好后，会通知相应的用户线程来copy数据。所以，上面说“准非阻塞方式”，当多个线程中的至少一个数据准备好后，统一线程就会返回。</p><h3 id="1-2-3-总结"><a href="#1-2-3-总结" class="headerlink" title="1.2.3 总结"></a>1.2.3 总结</h3><p>从如上的图可以发现，多路复用I/O和阻塞I/O相比，并没有什么优势，毕竟阻塞I/O还只需要一个接口。多路复用，顾名思义，就是针对多路请求的，如果请求量很少很少的时候，直接使用多线程+阻塞I/O才是一个更好的选择。</p><p>此外，当请求量很大，并且每个连接都很活跃的时候，多路复用并不推荐，因为这个时候，每个连接都会非常活跃，而使用一个统一的内核线程管理数据准备情况，会导致单点严重。</p><p>但是，从现实的网络应用模型来说，绝大部分的网络连接，都是处于非活跃状态，因此，多路复用模型才在网络应用上，效果会如此好，应用如此广泛。</p><h2 id="1-3-多路复用方法"><a href="#1-3-多路复用方法" class="headerlink" title="1.3 多路复用方法"></a>1.3 多路复用方法</h2><p>在linux系统中，主要有select，poll和epoll三个方法，而在linux内核2.6推出epoll之后，基本上多路复用指的就是epoll。</p><h3 id="1-3-1-wakeup-callback机制"><a href="#1-3-1-wakeup-callback机制" class="headerlink" title="1.3.1 wakeup callback机制"></a>1.3.1 wakeup callback机制</h3><p>在linux 2.6内核中，推出了所谓wakeup callback机制。linux内核通过睡眠队列来组织所有等待某个事件的任务，而wakeup方法则可以异步唤醒整个睡眠队列上的任务，而队列上的任务都会关联上一个callback回调方法。当我们的wakeup方法执行唤醒动作的时候，会遍历整个睡眠队列的节点，然后调用对应的callback方法。</p><h4 id="1-3-1-1-睡眠等待"><a href="#1-3-1-1-睡眠等待" class="headerlink" title="1.3.1.1 睡眠等待"></a>1.3.1.1 睡眠等待</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">define sleep_list;  </span><br><span class="line">define wait_entry;  </span><br><span class="line">wait_entry.task= current_task;  </span><br><span class="line">wait_entry.callback = func1;  </span><br><span class="line"><span class="keyword">if</span> (something_not_ready); <span class="keyword">then</span>  </span><br><span class="line">    // 如果条件没有准备好，则陷入内核阻塞路径  </span><br><span class="line">    add_entry_to_list(wait_entry, sleep_list);  </span><br><span class="line">go on:    </span><br><span class="line">    // 进行循环等待中，直到关心的事件准备好</span><br><span class="line">    schedule();  </span><br><span class="line">    <span class="keyword">if</span> (something_not_ready); <span class="keyword">then</span>  </span><br><span class="line">        goto go_on;  </span><br><span class="line">    endif  </span><br><span class="line">    // 将当前的任务从睡眠队列中移除</span><br><span class="line">    del_entry_from_list(wait_entry, sleep_list);  </span><br><span class="line">endif  </span><br></pre></td></tr></table></figure><h4 id="1-3-1-2-唤醒动作"><a href="#1-3-1-2-唤醒动作" class="headerlink" title="1.3.1.2 唤醒动作"></a>1.3.1.2 唤醒动作</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">something_ready;  </span><br><span class="line">// 当某个事情准备好之后，唤醒整个睡眠队列</span><br><span class="line">for_each(sleep_list) as wait_entry; <span class="keyword">do</span>  </span><br><span class="line">    // 对每个睡眠队列中的节点执行回调方法</span><br><span class="line">    wait_entry.callback(...);  </span><br><span class="line">    <span class="keyword">if</span>(wait_entry.exclusion); <span class="keyword">then</span>  </span><br><span class="line">        <span class="built_in">break</span>;  </span><br><span class="line">    endif  </span><br><span class="line"><span class="keyword">done</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一般而言，在callback中执行如下逻辑：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">common_callback_func(...)  </span><br><span class="line">&#123;  </span><br><span class="line">    // 自定义逻辑</span><br><span class="line">    do_something_private;  </span><br><span class="line">    wakeup_common;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>其中，do_something_private是wait_entry自己的自定义逻辑，而wakeup_common则是公共逻辑，旨在将该wait_entry的task加入到CPU的就绪task队列，然后让CPU去调度它。</p><h3 id="1-3-2-select-amp-amp-poll"><a href="#1-3-2-select-amp-amp-poll" class="headerlink" title="1.3.2 select &amp;&amp; poll"></a>1.3.2 select &amp;&amp; poll</h3><p>select函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或者多个事件发生或者经历一段指定的时间后才会唤醒它，结束阻塞等待。</p><p>简单的看下，linux select函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @params nfds         集合中所有文件描述符的范围，即所有文件描述符的最大值加1</span></span><br><span class="line"><span class="comment"> * @params readfds      需要监视的读变化的文件描述符集合</span></span><br><span class="line"><span class="comment"> * @params writefds     需要监视的写变化的文件描述符集合</span></span><br><span class="line"><span class="comment"> * @params exceptfds    需要监视的出现的错误异常的文件描述符集合</span></span><br><span class="line"><span class="comment"> * @params timeout      select方法阻塞等待的最长时间，超过该超时时间则结束阻塞，返回0</span></span><br><span class="line"><span class="comment"> * @return &lt;0：表示方法执行出错；=0：表示等待超时，没有可读写或异常事件；&gt;0：表示某fd可读写或出错</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上文已经介绍了多路复用IO的使用场景：网络连接需要处理大量网络连接，并且只会有部分是处于活跃状态，当应用调用select方法的时候，select函数会将需要监控的各个fd_set集合copy到系统的内核空间，然后自己会先遍历一次需要监控的所有fd_set集合，确认对应等待的数据是否满足条件。如果，不存在任何一个fd条件满足，则会进入schedule_timeout的内部循环。</p><p>在schedule_timeout中，在超时时间内，select会阻塞，将所有的set中的socket放入了<code>wakeup callback机制</code>中介绍的睡眠队列中，等待数据的状态的变化。当其中一个socket事件发现数据发生变化的时候，则会执行对应统一的callback方法，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for_each_N_socket as sk; <span class="keyword">do</span>  </span><br><span class="line">    event.evt = sk.poll(...);  </span><br><span class="line">    event.sk = sk;  </span><br><span class="line">    put_event_to_user; </span><br><span class="line"><span class="keyword">done</span>; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也就是说，由于wakeup中的callback并没有给出是哪个socket准备好了，所以select会遍历所有注册在其上的socket，执行poll函数，判断对应的socket数据是否准备好。</p><p>虽然select限制了最大只能有1024个socket可以服用，但是如果每次唤醒都只因为1个socket数据准备好了，而需要遍历1024个socket，对性能的影响也是非常大的。更不用说，我们还可以通过修改<code>FD_SETSIZE</code>配置，来增大这个大小限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @params fds     所有需要监视变化的文件描述符集合</span></span><br><span class="line"><span class="comment"> * @params nfds    需要监视的文件描述符范围，即所有文件描述符的最大值加1</span></span><br><span class="line"><span class="comment"> * @params timeout 超时时间，超时返回0</span></span><br><span class="line"><span class="comment"> * @return &lt;0：表示方法执行出错；=0：表示等待超时，没有可读写或异常事件；&gt;0：表示某fd可读写或出错</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>poll底层和select是基本上一致的，其主要是为了解决1024数量的限制，但是性能上的问题，并没有解决，甚至由于限制的大小增大，反而性能更差。</p><h3 id="1-3-3-epoll"><a href="#1-3-3-epoll" class="headerlink" title="1.3.3 epoll"></a>1.3.3 epoll</h3><p>在<code>select&amp;&amp;poll</code>中介绍了，其对应的callback只是通知对应的fd_set中某个socket数据准备好了，并没有告知具体情况，这个时候，select方法只能遍历所有的fd_set来找到真正准备好的socket，来处理后续流程。</p><p>然而，我们显然可以做的更进一步，每个socket都有自己的callback方法，来完成自己对应的回调逻辑。</p><p>epoll 新增了一个链表ready_list，这个链表内的所有socket都是数据已经准备好了，应用进程可以处理了。这个时候，当等待在睡眠队列上的节点呗唤醒之后，将自己加入到epoll准备好的ready_lis中，然后epoll_wait返回的时候，只需要遍历ready_list链表即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">epoll_wakecallback(...)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 将自己这个socket加入到ready_list中</span></span><br><span class="line">    add_this_socket_to_ready_list;  </span><br><span class="line">    <span class="comment">// 唤醒epoll_wait等待函数</span></span><br><span class="line">    wakeup_single_epoll_waitlist;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上所述，因为epoll和select不同之处，在于每个socket fd 都有一个callback，因此在使用epoll的时候，也需要添加对应的socket callback。所以，epoll在使用上，会相对比较复杂。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个epoll句柄，因此其返回时一个fd文件描述符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @params size 监听的socket数目，显然和select方法的nfds是不同的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * epoll事件注册函数。这个方法其实是核心方法，其告诉内核需要监听什么事件，并且在事件触发的时候，执行什么回调</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @params epfd create返回的epoll句柄fd</span></span><br><span class="line"><span class="comment"> * @params op 需要执行的动作，比如EPOLL_CTL_ADD：注册新的fd到epoll句柄中</span></span><br><span class="line"><span class="comment"> * @params fd 要监听的fd</span></span><br><span class="line"><span class="comment"> * @params event 监听的事件，内核根据这个事件来决定是否触发callback，例如EPOLLIN读事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类似select方法一样，阻塞等待监听的所有fd中某个事件触发。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @params epfd create返回的epoll句柄fd</span></span><br><span class="line"><span class="comment"> * @params event 内核中得到的fd集合，表示哪些fd已经准备好了</span></span><br><span class="line"><span class="comment"> * @params maxevents events的大小。</span></span><br><span class="line"><span class="comment"> * @params timeout 超时时间，如果阻塞直到超时，则返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>在epoll中还有一个很重要的概念：ET(Edge Triggered) 和 LT(Level Triggered)。</p><p>所谓ET：只有状态发生变化的时候，才会通知，比如数据缓冲去从无到有的时候(不可读-可读)，如果缓冲区里面有数据，便不会一直通知；</p><p>所谓LT：只要缓冲区里面有数据，而这些数据没有被应用处理的时候，就会一直通知。</p><p>一般而言，为了代码健壮，绝大部分框架都对外提供基于LT触发的epoll，从而避免代码bug导致事件丢失。java NIO Selector提供的就是基于LT触发的，而如果想使用基于ET的epoll，则可以使用Netty提供的Epoll类。</p><h1 id="2-java-NIO-介绍"><a href="#2-java-NIO-介绍" class="headerlink" title="2. java NIO 介绍"></a>2. java NIO 介绍</h1><p>上文，只是简单的介绍了linux下I/O模型，以及开发服务端尝尝接触到的多路复用I/O底层接口。</p><p>在java的世界里，都进行了很好的封装。如下，我们将继续学习nio相关的类功能。</p><p>java nio 三剑客：</p><ul><li>Buffer(缓冲区)</li><li>Channel(通道)</li><li>Selector(多路复用选择器)</li></ul><p>我们知道，传统的I/O接口是基于流（字节流/字符流）来进行操作的，内部所有的接口，都是在输入输出stream上操作。因为基于流，所以不需要额外的空间来存储数据，但是同样因为基于流，所以对于stream，是不能前后移动来获取流中的数据，除非先将所有数据保存下来。</p><p>而，java nio类接口是基于缓冲区buffer和通道channel来操作的。在java nio中，数据从channel读出到buffer中，然后应用程序操作buffer中的字节；或者应用程序将缓冲区buffer中的数据写入到channel中。</p><p>如上面讲的多路复用那样，应用线程在需要读写数据的时候，只需要把请求包装之后交给selector线程来阻塞等待，而业务自己的线程可以去做一些别的事情。等到事件触发之后，再由业务线程来处理数据即可。</p><h2 id="2-1-Buffer"><a href="#2-1-Buffer" class="headerlink" title="2.1 Buffer"></a>2.1 Buffer</h2><h3 id="2-1-1-Buffer类介绍"><a href="#2-1-1-Buffer类介绍" class="headerlink" title="2.1.1 Buffer类介绍"></a>2.1.1 Buffer类介绍</h3><p>Buffer是一个用于特定类型数据的容器，在java nio中，有多个缓冲区实现，如：<br><code>ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer</code>。在网络应用开发中，用的最多的是ByteBuffer类。</p><p>Buffer除了数据内容之后，还会有一些基本的属性，例如：</p><ul><li>容量capacity：表示该缓冲区包含元素的数量；</li><li>限制limit：第一个不应该读取或者写入的元素的索引；</li><li>位置position：下一个要读取或者写入的元素的索引。</li></ul><p>以上，三个属性特别重要，基于buffer上的所有方法都是操作以上三个属性来完成各种功能的。</p><blockquote><p>需要特别说明下，buffer是非线程安全的，如果多个线程操作buffer，则需要使用同步加锁来进行约束。</p></blockquote><p>对于Buffer读写数据，主要是5个步骤：</p><ol><li>对于Buffer容器，首先需要申请分配内存空间来保存数据；</li><li>写入数据到Buffer容器中，Buffer容器会记录下写入的数据，以及更新position的值；</li><li>调用flip()方法切换读写模式,这个时候Buffer类的三个属性会进行更新，例如position现在是读位置索引等；</li><li>从Buffer容器中读取数据，Buffer容器讲数据操作了之后，会同步更新position值；</li><li>调用clear()方法或者compact()方法来请客缓冲区。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</li></ol><h3 id="2-1-2-ByteBuffer类使用"><a href="#2-1-2-ByteBuffer类使用" class="headerlink" title="2.1.2 ByteBuffer类使用"></a>2.1.2 ByteBuffer类使用</h3><p>由于ByteBuffer是使用最多的容器类型，这里直接用这种类型来介绍buffer的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create buffer with capacity of 48 bytes</span></span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//read into buffer.</span></span><br><span class="line">    <span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line">    <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;read byte size: &quot;</span> + bytesRead);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//make buffer ready for read</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------读写切换开始--------------------- &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;before flip position: &quot;</span> + buf.position() + <span class="string">&quot;, limit: &quot;</span> + buf.limit());</span><br><span class="line">        buf.flip();</span><br><span class="line">        System.out.println(<span class="string">&quot;after flip position: &quot;</span> + buf.position() + <span class="string">&quot;, limit: &quot;</span> + buf.limit());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------读写切换结束--------------------- &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> readSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (buf.hasRemaining()) &#123;</span><br><span class="line">            <span class="comment">// read 1 byte at a time</span></span><br><span class="line">            readSize++;</span><br><span class="line">            <span class="comment">// 如果这里不操作get方法，则这个while会死循环，因为buffer的position一直没变化</span></span><br><span class="line">            buf.get();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;this time read buffer data size: &quot;</span> + readSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//make buffer ready for writing</span></span><br><span class="line">        System.out.println(<span class="string">&quot;++++++++++++++++++++++清缓冲区开始+++++++++++++++++++++++ &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;before clear position: &quot;</span> + buf.position() + <span class="string">&quot;, limit: &quot;</span> + buf.limit());</span><br><span class="line">        buf.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;after clear position: &quot;</span> + buf.position() + <span class="string">&quot;, limit: &quot;</span> + buf.limit());</span><br><span class="line">        System.out.println(<span class="string">&quot;++++++++++++++++++++++清缓冲区结束+++++++++++++++++++++++ &quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        bytesRead = inChannel.read(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    aFile.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码其实并不重要，我们通过打印的数据，可以发现buffer对于三个属性的更新操作。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">read <span class="keyword">byte</span> size: <span class="number">48</span></span><br><span class="line">--------------------读写切换开始--------------------- </span><br><span class="line">before flip position: <span class="number">48</span>, limit: <span class="number">48</span></span><br><span class="line">after flip position: <span class="number">0</span>, limit: <span class="number">48</span></span><br><span class="line">--------------------读写切换结束--------------------- </span><br><span class="line"><span class="keyword">this</span> time read buffer data size: <span class="number">48</span></span><br><span class="line">++++++++++++++++++++++清缓冲区开始+++++++++++++++++++++++ </span><br><span class="line">before clear position: <span class="number">48</span>, limit: <span class="number">48</span></span><br><span class="line">after clear position: <span class="number">0</span>, limit: <span class="number">48</span></span><br><span class="line">++++++++++++++++++++++清缓冲区结束+++++++++++++++++++++++ </span><br><span class="line">read <span class="keyword">byte</span> size: <span class="number">29</span></span><br><span class="line">--------------------读写切换开始--------------------- </span><br><span class="line">before flip position: <span class="number">29</span>, limit: <span class="number">48</span></span><br><span class="line">after flip position: <span class="number">0</span>, limit: <span class="number">29</span></span><br><span class="line">--------------------读写切换结束--------------------- </span><br><span class="line"><span class="keyword">this</span> time read buffer data size: <span class="number">29</span></span><br><span class="line">++++++++++++++++++++++清缓冲区开始+++++++++++++++++++++++ </span><br><span class="line">before clear position: <span class="number">29</span>, limit: <span class="number">29</span></span><br><span class="line">after clear position: <span class="number">0</span>, limit: <span class="number">48</span></span><br><span class="line">++++++++++++++++++++++清缓冲区结束+++++++++++++++++++++++ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过返回结果，我们可以清晰的知道读写flip之后，三个属性的变化，以及clear之后，三个属性的变化。如下图，会有个形象的说明：</p><p><img src="/images/2018/buffer.png" alt="Buffer数据模型"></p><h3 id="nio-buffer-API不足之处"><a href="#nio-buffer-API不足之处" class="headerlink" title="nio buffer API不足之处"></a>nio buffer API不足之处</h3><p>如上用例的用例，我们会发现buffer API使用过程中的一些不足：</p><ol><li><p> <code>ByteBuffer buf = ByteBuffer.allocate(48);</code> 在申请的时候，需要明确指出buffer的大小，分配完成之后，则大小固定，如果后续的内容过大，则会抛异常，导致<code>BufferOverflowException</code>.</p></li><li><p>另外，还有一个很不好的体验，就是我们做读写切换的时候，需要自己手动flip来切换position位置，一不小心就可以能到读写出错。</p></li></ol><h2 id="2-2-Channel"><a href="#2-2-Channel" class="headerlink" title="2.2 Channel"></a>2.2 Channel</h2><p>在java nio体系中，channel就类似一个stream流，但是其相对stream来说，在使用上有更多的进步：</p><ol><li><p>如上所述，Channel是基于buffer缓冲区的，所以其支持在同个channel中执行读和写操作, 然而同一个Stream在构造的时候，就需要明确指出其针对的是读还是写.</p></li><li><p>buffer的引入，让Channel可以提供异步的读写，但是Stream基于流，只支持同步阻塞的读写操作；</p></li></ol><p>在java nio中，目前主要分为：</p><ul><li><p>FileChanel：用来读取、写入、映射和操作文件的通道。通过FileChannel从一个文件中读取数据, 也可以将数据写入到文件中。不过FileChannel是同步的，如果想要异步的文件Channel，则需要使用<code>AsynchronousFileChannel</code>。所谓AsynchronousFileChannel，其实就是在读写的时候，其直接返回一个future，后面只需要在需要的时候，执行future.get来感知读写进度即可。</p></li><li><p>SocketChannel：用来操作连接套接字TCP流的通道，主要是针对客户端连接。</p></li><li><p>ServerSocketChannel：用来操作连接套接字TCP流的通道，主要是针对服务端连接。</p></li></ul><p>以上，是主要的channel，还会有些其他的，暂不说明。</p><h3 id="2-2-1-SocketChannel-amp-amp-ServerSocketChannel介绍"><a href="#2-2-1-SocketChannel-amp-amp-ServerSocketChannel介绍" class="headerlink" title="2.2.1 SocketChannel &amp;&amp; ServerSocketChannel介绍"></a>2.2.1 SocketChannel &amp;&amp; ServerSocketChannel介绍</h3><p><code>SocketChannel</code> 和 <code>ServerSocketChannel</code>对应Stream模式下的Socket和ServerSocket，其最大的不同就是支持非阻塞模式。</p><p>所以，我们如下使用ServerSocketChannel：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置成阻塞模式</span></span><br><span class="line">        <span class="comment">//serverSocketChannel.configureBlocking(false);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 阻塞模式</span></span><br><span class="line">            ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">            <span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = socketChannel.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;read socket data size: &quot;</span> + bytesRead);</span><br><span class="line">                <span class="comment">// 空操作，只是为了把数据读出来</span></span><br><span class="line">                buf.get();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>特别说明，上面是一个使用serverSocketChannel的简单示例，读内容的逻辑，只试用于阻塞，开启非阻塞模式，则会出现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line">at io.github.ketao1989.nio.NioServer.main(NioServer.java:<span class="number">32</span>)</span><br></pre></td></tr></table></figure><p>关于非阻塞模式，在Selector中说明。此外，实际上在ServerSocketChannelImpl中的实现非阻塞的时候，是会关联一个Selector的，而这个Selector在不同的系统环境，是不同的。</p><table><thead><tr><th>系统</th><th align="center">Selector</th><th align="left">备注</th></tr></thead><tbody><tr><td>Unix(MacOs)</td><td align="center">KQueueSelectorImpl</td><td align="left">类Unix系统的多路复用器</td></tr><tr><td>Linux</td><td align="center">PollSelectorImpl</td><td align="left">内部应该是使用的epoll多路复用</td></tr><tr><td>windows</td><td align="center">WindowsSelectorImpl</td><td align="left">内部应该是有的是iocp</td></tr></tbody></table><p>具体Selector的介绍，见下一节。</p></blockquote><p>从上面的代码，可以明确看出，channel数据操作是基于buffer来的，其所有的接口都是基于Buffer对外暴露的。</p><p>而在，Buffer的介绍中，说过Buffer是缓冲区，可以读和写一起操作，不需要在构造一个对象。因此，基于其数据结构之上的channel也是可以读写一起操作的。</p><h2 id="2-3-Selector"><a href="#2-3-Selector" class="headerlink" title="2.3 Selector"></a>2.3 Selector</h2><p>Selector，多路复用选择器。其可以通过一个线程来同步检测多个通道channel是都有相关事件准备好了，从而减少线程hang在IO等事件上。</p><p>通常情况下，使用一个线程监听事件，而不是多线程来处理，主要原因是线程上下文切换的开销会比较大，并且每个资源暂用的资源也会有一些，因此使用单线程对于系统来说，可能当前是比较友好的。</p><blockquote><p>但是，需要说明的，由于CPU的技术发展以及操作系统的不断优化，现在多线程的开销会越来越小。如果有多核，而程序不去使用，那显然是浪费CPU能力。因此，我们会看到，有一种线程模型，是多个selector来并发执行。例如thrift的TThreadedSelectorServer，这个模型，以后有机会再详说。</p></blockquote><h3 id="2-3-1-Selector-介绍"><a href="#2-3-1-Selector-介绍" class="headerlink" title="2.3.1 Selector 介绍"></a>2.3.1 Selector 介绍</h3><p>在java中，linux环境下，selector使用epoll来实现多路复用。</p><p>下面通过代码了解selector的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置成阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册监听事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> select = selector.select();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (select == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;啦啦啦啦啦，谁把我弄起来了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (select &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey selectionKey = iterator.next();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 接收连接请求</span></span><br><span class="line">                    <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">                        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;开始处理连接:&quot;</span> + socketChannel.getRemoteAddress().toString());</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//每接收请求之后，感兴趣的树读事件，所以在同一个selector中注册读事件</span></span><br><span class="line">                        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;开始读取数据......&quot;</span>);</span><br><span class="line">                        <span class="comment">// 简单处理，不起线程了</span></span><br><span class="line">                        ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">                        <span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line">                        SocketChannel socketChannel = (SocketChannel) (selectionKey.channel());</span><br><span class="line">                        <span class="keyword">while</span> ((bytesRead = socketChannel.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;read socket data size: &quot;</span> + bytesRead);</span><br><span class="line">                            <span class="comment">// 空操作，只是为了把数据读出来</span></span><br><span class="line">                            buf.get();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 这里一定需要判断，不然关闭client之后，会出现死循环</span></span><br><span class="line">                        <span class="comment">// 一直处在 &#x27;开始读取数据......&#x27;</span></span><br><span class="line">                        <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            System.out.println(<span class="string">&quot;开始关闭会话......&quot;</span>);</span><br><span class="line">                            selectionKey.cancel();</span><br><span class="line">                            socketChannel.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>以上是实现一个很简单的selector的非阻塞服务器，在开发过程中，会存在很多小问题，例如如果我们不对bytesRead为-1的情况进行处理，则会一直处在有读事件没有处理，然后就会出现死循环。此外，基于多线程处理读数据，又会有很多地方修改和注意点，需要非常谨慎和细致。<br>因此，开发一个nio的服务器是非常需要技术的，一旦一个点遗漏，就会导致死循环。java nio 接口使用的不友好，造就了mina，netty网络库的出现。</p></blockquote><h3 id="2-3-2-Selector-wakeup方法"><a href="#2-3-2-Selector-wakeup方法" class="headerlink" title="2.3.2 Selector wakeup方法"></a>2.3.2 Selector wakeup方法</h3><p>在selector中，也有一个wakeup方法，虽然和上面的wakeup并不是一个东西，但是其目的是一样的。</p><p>在Selector中，我们知道其是一个线程阻塞的来处理所有事件监听的，如果selector不设置超时的话，就会一直处于阻塞状态，直到有时间发生。</p><p>但是，如果这个时候，其他线程需要这个线程返回，停止阻塞，就需要调用wakeup来唤醒处在select()中的线程。</p><p>举个例子，比如我服务端使用selector来处理事件，现在，我需要停止服务,但是因为没事件发生，导致selector的select方法处于阻塞状态，这个时候就需要使用wakeup唤醒。例如在thrift的TNonblockingServer，在停止server的时候，就会调用wakeup，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stop serving and shut everything down.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  stopped_ = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (selectAcceptThread_ != <span class="keyword">null</span>) &#123;</span><br><span class="line">    selectAcceptThread_.wakeupSelector();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * If the selector is blocked, wake it up.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeupSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    selector.wakeup();</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>wakeup的实现，其实很有意思，就是mock一个事件发生，然后select()方法就可以从阻塞中醒过来，从而完成wakeup的动作。<br>具体，可以参考：<a href="http://jm.taobao.org/2010/10/22/380/">http://jm.taobao.org/2010/10/22/380/</a></p></blockquote><h1 id="3-Netty-ByteBuf-介绍"><a href="#3-Netty-ByteBuf-介绍" class="headerlink" title="3. Netty ByteBuf 介绍"></a>3. Netty ByteBuf 介绍</h1><p>由于Nio的ByteBuffer的一些不足，在netty中提供了一个相同功能的类：ByteBuf。但是ByteBuf很好的简化了nio bytebuffer的使用，并且将一些常用的方法包装出来对外提供。</p><p>在介绍各个bytebuf特性之前，先看看netty bytebuf提供了哪些常用的类</p><p><img src="/images/2018/bytebuf_main_class.png" alt="netty bytebuf主要实现类图"></p><ul><li><p>EmptyByteBuf：一个空的bytebuf，其capacity为0，读写index也为0.</p></li><li><p>WrappedByteBuf：主要是对ByteBuf类进行一些包装的类型，也就是其只是对例如CompositeByteBuf进行一些装饰，额外加一些日志或者记录等。</p><ul><li>SimpleLeakAwareByteBuf：对于一些方法，比如slice，duplicate，touch等等对buf对象会有引用的时候，会进行record引用记录。</li><li>AdvancedLeakAwareByteBuf：看实现跟上面的Simple是类似的，只不过对更多的操作会记录详细的操作计数的日志。</li><li>UnreleasableByteBuf：顾名思义，就是不允许release buf空间。调用release直接返回false，不做任何处理。一般，我们在定义一个常量的bytebuf会使用这种类型，比如说，我们对每一个文件都会加以java结尾，则将java定义成一个UnreleasableByteBuf，这样内容不会修改和释放，每一次文件路径过来，加上java buf 返回。</li></ul></li><li><p>DuplicatedByteBuf：在底层数据共享的时候，该bytebuf可以对每一个Duplicated出来的对象单独提供readIndex和writeIndex，彼此之间互不影响，但是缓冲区是共享的，这样子可以节省内存占用。</p></li><li><p>ReadOnlyByteBuf/ReadOnlyByteBufferBuf：和上一个bytebuf类似，只不会新创建出来的bytebuf引用，不能操作writeIndex，也就意味着在很多为了数据安全，只能够共享读数据的地方，非常适用。</p></li><li><p>CompositeByteBuf：一个虚拟的buffer，实际上他本身并不额外分配buffer空间，而是引用组合的各个buffer为一个list和迭代器。有的时候，我们可能从好几个地方获取到buf数据，然后聚合起来返回。使用CompositeByteBuf可以避免申请新的空间，然后复制数据的过程。</p><blockquote><p>需要说明下，SlicedByteBuf这种和CompositeByteBuf刚好相反，只截取bytebuf部分缓冲区数据的类型。现在这种类型之间使用bytebuf.slice方法构造。</p></blockquote></li><li><p>PooledByteBuf：基于内存池的ByteBuf子类型，主要是重用ByteBuf对象，避免内存申请释放导致的性能问题。由于内存获取方式的不同，还有如下更优化的子类型bytebuf存在。</p><ul><li>PooledDirectByteBuf：基于directByteBuffer来构造，直接使用堆外内存进行分配空间。堆外内存的时候，可以避免内存到JVM内存的一次拷贝，在和内核做数据交换的时候，对性能的提升很大。</li><li>PooledHeapByteBuf：使用JVM堆进行内存分配的byteBuf子类型。堆内分配，如果一些数据只是在java进程内部使用，则使用堆内存分配安全性 和速度上都会比较好，毕竟内存的回收有JVM来处理。</li><li>PooledUnsafeDirectByteBuf：和PooledDirectByteBuf类似，只不过其不是使用directByteBuffer来处理，而是自己通过PlatformDependent来根据不同系统平台使用不同的分配内存方式。<br>如下代码：</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getBytes</span><span class="params">(<span class="keyword">long</span> inAddr, <span class="keyword">byte</span>[] in, <span class="keyword">int</span> inOffset, <span class="keyword">int</span> inLen, OutputStream out, <span class="keyword">int</span> outLen)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> len = Math.min(inLen, outLen);</span><br><span class="line">        PlatformDependent.copyMemory(inAddr, in, inOffset, len);</span><br><span class="line">        out.write(in, inOffset, len);</span><br><span class="line">        outLen -= len;</span><br><span class="line">        inAddr += len;</span><br><span class="line">    &#125; <span class="keyword">while</span> (outLen &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>UnpooledByteBuf</code>：在netty不存在UnpooledByteBuf这种类型，这里只是相对<code>PooledByteBuf</code>而言。</p><ul><li>UnpooledHeapByteBuf：在堆内及时分配内存的bytebuf，内部代码直接基于ByteBuffer来实现的，不过增加了引用计数的内存回收。</li><li>UnpooledDirectByteBuf：在对外分配内存的bytebuf，每次需要就直接申请分配内存空间，在大量操作分配和回收内存额时候，会导致性能下降。</li><li>UnpooledUnsafeDirectByteBuf：基于平台优化的堆外内存分配的UnpooledDirectByteBuf。</li></ul></li></ul><p>因此，如上，我们可以大概了解，bytebuf主要基于两个维度：1.堆内&amp;堆外；2.池化&amp;非池化。所以在使用的时候，需要仔细考虑下。</p><h2 id="3-1-Netty-ByteBuf-接口"><a href="#3-1-Netty-ByteBuf-接口" class="headerlink" title="3.1 Netty ByteBuf 接口"></a>3.1 Netty ByteBuf 接口</h2><h3 id="3-1-1-读写标记分离"><a href="#3-1-1-读写标记分离" class="headerlink" title="3.1.1 读写标记分离"></a>3.1.1 读写标记分离</h3><p>在nio的ByteBuffer的实现中，是使用一个position来表示读位置和写位置，使得操作的时候，读写切换，需要在此之前把position进行更新，保证不会出现非预期结果。</p><p>在netty的实现中，ByteBuf申明了两个变量，分别表示读位置readerIndex，写位置writerIndex。读操作的时候，使用和更新readerIndexn；写操作的时候，使用和更新writerIndex。于是，在初始化之后，两者都为0。然后，写执行，writerIndex递增；读执行，readerIndex递增；约束条件就是readerIndex&lt;= writerIndex.</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*      +-------------------+------------------+------------------+</span><br><span class="line">*      | discardable bytes |  readable bytes  |  writable bytes  |</span><br><span class="line">*      |                   |     (CONTENT)    |                  |</span><br><span class="line">*      +-------------------+------------------+------------------+</span><br><span class="line">*      |                   |                  |                  |</span><br><span class="line">*      <span class="number">0</span>      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span><br><span class="line">*</span><br></pre></td></tr></table></figure><p>例如，我们读写一个字节时，则可以如下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkReadableBytes0(<span class="number">1</span>);<span class="comment">//check读空间</span></span><br><span class="line">    <span class="keyword">int</span> i = readerIndex;</span><br><span class="line">    <span class="keyword">byte</span> b = _getByte(i);</span><br><span class="line">    readerIndex = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeByte</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ensureWritable0(<span class="number">1</span>);<span class="comment">//check写空间</span></span><br><span class="line">    _setByte(writerIndex++, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果，我们需要清理已读的空间，只需要将当前readIndex之前的空间clear即可，相应的index往前移，非常简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* </span><br><span class="line">*  <span class="function">BEFORE <span class="title">discardReadBytes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">*</span></span><br><span class="line"><span class="function">*      +-------------------+------------------+------------------+</span></span><br><span class="line"><span class="function">*      | discardable bytes |  readable bytes  |  writable bytes  |</span></span><br><span class="line"><span class="function">*      +-------------------+------------------+------------------+</span></span><br><span class="line"><span class="function">*      |                   |                  |                  |</span></span><br><span class="line"><span class="function">*      0      &lt;</span>=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">*  <span class="function">AFTER <span class="title">discardReadBytes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">*</span></span><br><span class="line"><span class="function">*      +------------------+--------------------------------------+</span></span><br><span class="line"><span class="function">*      |  readable bytes  |    writable <span class="title">bytes</span> <span class="params">(got more space)</span>   |</span></span><br><span class="line"><span class="function">*      +------------------+--------------------------------------+</span></span><br><span class="line"><span class="function">*      |                  |                                      |</span></span><br><span class="line"><span class="function">* <span class="title">readerIndex</span> <span class="params">(<span class="number">0</span>)</span> &lt;</span>= writerIndex (decreased)        &lt;=        capacity</span><br><span class="line">* </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码简单实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">discardReadBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="keyword">if</span> (readerIndex == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readerIndex != writerIndex) &#123;</span><br><span class="line">        setBytes(<span class="number">0</span>, <span class="keyword">this</span>, readerIndex, writerIndex - readerIndex);</span><br><span class="line">        writerIndex -= readerIndex;</span><br><span class="line">        adjustMarkers(readerIndex);</span><br><span class="line">        readerIndex = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        adjustMarkers(readerIndex);</span><br><span class="line">        writerIndex = readerIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-1-2-动态扩容"><a href="#3-1-2-动态扩容" class="headerlink" title="3.1.2 动态扩容"></a>3.1.2 动态扩容</h3><p>java 的list相对于C，其提供的动态扩容。在使用list之前，开发同学不需要事先明确集合空间的大小，等到空间预期不够的时候，则执行动态扩容。</p><p>但是，在nio的ByteBuffer中，竟然不支持动态扩容，如果一不小心写多数据了，则会抛出BufferOverflowException异常，显然和java的风格不一致。因此，在netty中，其次需要解决的，就是支持动态扩容功能。</p><p>netty的实现原理，很简单。就是在写的时候，如果空间不足，则分配一个新的更大空间，将老数据复制过去。这涉及到两个点：</p><ol><li>什么时候扩容，扩容多少？</li><li>怎么分配更大空间？</li></ol><p>在netty中，当新写入的byte数组不够存放到byteBuf空间时，才会申请扩容。在分配器Allocator中，当整个内容大小(writeIndex+bytes.size)小于4M的时候，则从64开始，*2，直到可以存放整个内容。如果需要的空间大于4M，则按照4M的倍数来存放内容。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateNewCapacity</span><span class="params">(<span class="keyword">int</span> minNewCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">1048576</span> * <span class="number">4</span>; <span class="comment">// 4 MiB page</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity == threshold) &#123;</span><br><span class="line">        <span class="keyword">return</span> threshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If over threshold, do not double but just increase by threshold.</span></span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity &gt; threshold) &#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = minNewCapacity / threshold * threshold;</span><br><span class="line">        <span class="comment">// 如果离最大空间不足4M，则直接以最大空间来创建</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity &gt; maxCapacity - threshold) &#123;</span><br><span class="line">            newCapacity = maxCapacity;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果空间足够，则直接增加一个4M来申请新空间即可</span></span><br><span class="line">            newCapacity += threshold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not over threshold. Double up to 4 MiB, starting from 64.</span></span><br><span class="line">    <span class="comment">// 如果新空间少于4M，则以64开始，找到刚好大于新空间的2的幂次方数</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">while</span> (newCapacity &lt; minNewCapacity) &#123;</span><br><span class="line">        newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(newCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确认好了新空间的大小之后，就是开始分配空间内存了。由于ByteBuf有很多种实现，比如pool的，unpool的，heapbuffer的，directBuffer的。拿个最简单的实现示例UnpooledHeapByteBuf来看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    checkNewCapacity(newCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = array.length;</span><br><span class="line">    <span class="keyword">byte</span>[] oldArray = array;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &gt; oldCapacity) &#123;</span><br><span class="line">        <span class="comment">// new 一个byte数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] newArray = allocateArray(newCapacity);</span><br><span class="line">        <span class="comment">// 数据copy</span></span><br><span class="line">        System.arraycopy(oldArray, <span class="number">0</span>, newArray, <span class="number">0</span>, oldArray.length);</span><br><span class="line">        <span class="comment">//替换底层数据结构byte array</span></span><br><span class="line">        setArray(newArray);</span><br><span class="line">        <span class="comment">// 非pool的，这块等着gc回收好了</span></span><br><span class="line">        freeArray(oldArray);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newCapacity &lt; oldCapacity) &#123;</span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-1-3-引用计数"><a href="#3-1-3-引用计数" class="headerlink" title="3.1.3 引用计数"></a>3.1.3 引用计数</h3><p>引用计数是最简单的GC方式，其在循环引用的场景下，会存在内存泄漏的问题；但是由于其简单性，在某些确认不会存在彼此循环引用的情况下，是非常易于开发和理解的。</p><p>引用计数，算是ByteBuf提供的基本功能，在最基础的接口定义上，就把<code>ReferenceCounted</code>包含进去了，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;ClassMayBeInterface&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuf</span> <span class="keyword">implements</span> <span class="title">ReferenceCounted</span>, <span class="title">Comparable</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>特别说明下，这个注解ClassMayBeInterface，表明其实ByteBuf是个接口，使用abstract class只是为了后期可能内部实现一些默认方法，或者其他一些工具性质方法，在jdk8之前，只能使用抽象类来解决。<br>此外，其实在netty3中，ByteBuf就是一个接口，将接口改为abstract class会有5%的性能提升。</p></blockquote><p>和GC中的引用计数一样，当byteBuf对象被引用的时候，调用retain方法计数增一；调用release方法计数减一。当最终计数为1的时候，再执行release的时候，则会使用deallocate将buf对象释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下两个保证多线程安全可见的特性组合使用，可以学习下。AtomicIntegerFieldUpdater+refCnt来原子CAS更新计数.</span></span><br><span class="line"><span class="comment"> * 上面的结合主要是在不修改对外暴露方法的前提下，内部来保证线程安全，从netty提交记录也大概可以看出来。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;AbstractReferenceCountedByteBuf&gt; refCntUpdater =</span><br><span class="line">        AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, <span class="string">&quot;refCnt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> refCnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ByteBuf <span class="title">retain0</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> increment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldRef = refCntUpdater.getAndAdd(<span class="keyword">this</span>, increment);</span><br><span class="line">    <span class="comment">// 以下判断负数，或者加完increment之后整数溢出（这种判断很有趣）</span></span><br><span class="line">    <span class="keyword">if</span> (oldRef &lt;= <span class="number">0</span> || oldRef + increment &lt; oldRef) &#123;</span><br><span class="line">        <span class="comment">// Ensure we don&#x27;t resurrect (which means the refCnt was 0) and also that we encountered an overflow.</span></span><br><span class="line">        refCntUpdater.getAndAdd(<span class="keyword">this</span>, -increment);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(oldRef, increment);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">release0</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldRef = refCntUpdater.getAndAdd(<span class="keyword">this</span>, -decrement);</span><br><span class="line">    <span class="keyword">if</span> (oldRef == decrement) &#123;</span><br><span class="line">        deallocate();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldRef &lt; decrement || oldRef - decrement &gt; oldRef) &#123;</span><br><span class="line">        <span class="comment">// Ensure we don&#x27;t over-release, and avoid underflow.</span></span><br><span class="line">        refCntUpdater.getAndAdd(<span class="keyword">this</span>, decrement);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(oldRef, decrement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用计数，在netty中，也主要根据对象使用，然后自动释放&amp;回收空间。如上代码，具体释放的动作，是一个抽象方法，需要子类来实现。例如：</p><p>池化的PooledByteBuf的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bytebuf上面的相关空间进行销毁，比如内存页的块chuck在堆外内存的时候，进行free，还有相关引用置为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handle &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> handle = <span class="keyword">this</span>.handle;</span><br><span class="line">        <span class="keyword">this</span>.handle = -<span class="number">1</span>;</span><br><span class="line">        memory = <span class="keyword">null</span>;</span><br><span class="line">        tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">        chunk.arena.free(chunk, handle, maxLength, cache);</span><br><span class="line">        chunk = <span class="keyword">null</span>;</span><br><span class="line">        recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的实现回收，默认是将内存块push到stack栈中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    recyclerHandle.recycle(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在非池化的UnpooledByteBuf则基本上不会做什么操作，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freeArray(array);<span class="comment">//空方法</span></span><br><span class="line">    array = EmptyArrays.EMPTY_BYTES;<span class="comment">//对应buffer的底层数据结构设置为空byte[] EMPTY_BYTES = &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>如上，对于需要进行内存管理的buf来说，retain &amp; release来管理引用计数，然后再必要的时候，进行内存释放和回归，是很需要的。</p></blockquote><h2 id="3-2-Netty-ByteBuf高级特性"><a href="#3-2-Netty-ByteBuf高级特性" class="headerlink" title="3.2 Netty ByteBuf高级特性"></a>3.2 Netty ByteBuf高级特性</h2><h3 id="3-2-1-内存泄漏检测"><a href="#3-2-1-内存泄漏检测" class="headerlink" title="3.2.1 内存泄漏检测"></a>3.2.1 内存泄漏检测</h3><p>上面有一个基于引用计数的内存回收。但是，由于retain和release的方法调用都是由开发者自己来主动触发的，这就导致可能哪里遗忘了release buf对象的操作，导致一直没办法进行主动内存释放的操作。</p><p>内存泄漏检测，主要针对PooledByteBuf，因为是自己管理buf池子，就需要判断什么时候buf可以释放，当前有没有存在未释放的buf。</p><p>当前，netty内存泄漏检测的级别主要有：</p><ul><li>DISABLED – 完全禁用检查。不推荐。</li><li>SIMPLE – 检查1/128比例的缓冲区是否存在内存泄露。默认检测为该级别。</li><li>ADVANCED – 检查1/128比例的缓冲区，并提示发生内存泄露的位置。</li><li>PARANOID – 与ADVANCED等级一样，不同的是会检查所有的缓冲区。对于自动化测试很有用，你可以让构建测试失败 如果构建输出中包含’LEAK’, 用JVM选项 -Dio.netty.leakDetectionLevel 来指定内存泄露检查等级</li></ul><p>于是，开启检测之后，如果存在内存泄漏，则在日志里，会存在如下错误信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LEAK: ByteBuf.release() was not called before it<span class="string">&#x27;s garbage-collected. &quot; +</span></span><br><span class="line"><span class="string">                &quot;Enable advanced leak reporting to find out where the leak occurred. &quot; +</span></span><br><span class="line"><span class="string">                &quot;To enable advanced leak reporting, &quot; +</span></span><br><span class="line"><span class="string">                &quot;specify the JVM option &#x27;</span>-Dio.netty.leakDetection.level=advanced<span class="string">&#x27; or call ResourceLeakDetector.setLevel() &quot; +</span></span><br><span class="line"><span class="string">                &quot;See http://netty.io/wiki/reference-counted-objects.html for more information.</span></span><br></pre></td></tr></table></figure><p>在PooledByteBufAllocator中，新建buf都会进行装饰，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newHeapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PoolThreadCache cache = threadCache.get();</span><br><span class="line">    PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena = cache.heapArena;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (heapArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buf = heapArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = PlatformDependent.hasUnsafe() ?</span><br><span class="line">                <span class="keyword">new</span> UnpooledUnsafeHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">                <span class="keyword">new</span> UnpooledHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们，在测试的时候，则可以调用open方法打开检测，然后执行track指令，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DefaultResourceLeak <span class="title">track0</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">     Level level = ResourceLeakDetector.level;</span><br><span class="line">     <span class="comment">// .....</span></span><br><span class="line">     <span class="comment">// 为了测试，检测所有怀疑资源泄漏的地方</span></span><br><span class="line">     <span class="keyword">if</span> (level.ordinal() &lt; Level.PARANOID.ordinal()) &#123;</span><br><span class="line">         <span class="comment">// 由于对系统压力大，所以进行采样，大概1/128比例</span></span><br><span class="line">         <span class="keyword">if</span> ((PlatformDependent.threadLocalRandom().nextInt(samplingInterval)) == <span class="number">0</span>) &#123;</span><br><span class="line">             reportLeak();</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> DefaultResourceLeak(obj, refQueue, allLeaks);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 其他设置，主动触发就会出一份检测报告</span></span><br><span class="line">     reportLeak();</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> DefaultResourceLeak(obj, refQueue, allLeaks);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外，在内存泄漏检测的实现中，使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源泄漏的统计对象是一个弱引用，在内存紧张的时候，会进行GC回收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultResourceLeak</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">ResourceLeakTracker</span>&lt;<span class="title">T</span>&gt;, <span class="title">ResourceLeak</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在refQueue中保存的是DefaultResourceLeak类型的弱引用，然后放到ReferenceQueue中，当GC的时候，会查看</span></span><br><span class="line"><span class="comment"> * ReferenceQueue中的元素，进行GC回收，而不管外部是否还有改元素对象的引用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; refQueue = <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-2-零拷贝优化"><a href="#3-2-2-零拷贝优化" class="headerlink" title="3.2.2 零拷贝优化"></a>3.2.2 零拷贝优化</h3><p>一般，我们拷贝，主要存在两种情况：</p><ul><li>我们创建新buf的时候，当需要从某个已存在的buf对象的部分或全部类型来回写新buf时，就需要拷贝这部分内容。</li><li>当我们需要把数据从不同空间转移的时候，例如内核区到用户区，就需要进行数据拷贝的操作。</li></ul><p>针对以上两种情况，netty都存在一些针对使用场景的优化，来避免不必要的拷贝。这些操作，我们统一称之为零拷贝。</p><h4 id="3-2-2-1-零拷贝之ByteBuf创建"><a href="#3-2-2-1-零拷贝之ByteBuf创建" class="headerlink" title="3.2.2.1 零拷贝之ByteBuf创建"></a>3.2.2.1 零拷贝之ByteBuf创建</h4><h5 id="CompositeByteBuf"><a href="#CompositeByteBuf" class="headerlink" title="CompositeByteBuf"></a>CompositeByteBuf</h5><p>当我们从不同的解析方法里面返回了header bytebuf和body bytebuf，然后想组合成一个请求整体进行后续反序列化等操作的时候，就需要将不同的buf组合成新的bytebuf，于是，就有了CompositeByteBuf。</p><p>CompositeByteBuf并没有真的copy多个bytebuf的数据到最终的buf中，而只是维护各个bytebuf的对象引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeByteBuf</span> <span class="keyword">extends</span> <span class="title">AbstractReferenceCountedByteBuf</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Iterator&lt;ByteBuf&gt; EMPTY_ITERATOR = Collections.&lt;ByteBuf&gt;emptyList().iterator();</span><br><span class="line"></span><br><span class="line">    CompositeByteBuf(ByteBufAllocator alloc, <span class="keyword">boolean</span> direct, <span class="keyword">int</span> maxNumComponents, ByteBuf[] buffers, <span class="keyword">int</span> offset, <span class="keyword">int</span> len) &#123;</span><br><span class="line">        <span class="keyword">super</span>(AbstractByteBufAllocator.DEFAULT_MAX_CAPACITY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.alloc = alloc;</span><br><span class="line">        <span class="keyword">this</span>.direct = direct;</span><br><span class="line">        <span class="keyword">this</span>.maxNumComponents = maxNumComponents;</span><br><span class="line">        components = newList(maxNumComponents);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里讲buffer的数据加入到components列表中</span></span><br><span class="line">        addComponents0(<span class="keyword">false</span>, <span class="number">0</span>, buffers, offset, len);</span><br><span class="line">        <span class="comment">//当前components size 超过指定maxSize，触发copy数据操作</span></span><br><span class="line">        consolidateIfNeeded();</span><br><span class="line">        setIndex(<span class="number">0</span>, capacity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">addComponent0</span><span class="params">(<span class="keyword">boolean</span> increaseWriterIndex, <span class="keyword">int</span> cIndex, ByteBuf buffer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> readableBytes = buffer.readableBytes();</span><br><span class="line"></span><br><span class="line">            Component c = <span class="keyword">new</span> Component(buffer.order(ByteOrder.BIG_ENDIAN).slice());</span><br><span class="line">            <span class="keyword">if</span> (cIndex == components.size()) &#123;</span><br><span class="line">                wasAdded = components.add(c);</span><br><span class="line">                <span class="comment">// 维护各个offset:对应buf在list中基于字节的开始偏移量和结束偏移量</span></span><br><span class="line">                <span class="keyword">if</span> (cIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                    c.endOffset = readableBytes;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Component prev = components.get(cIndex - <span class="number">1</span>);</span><br><span class="line">                    c.offset = prev.endOffset;</span><br><span class="line">                    c.endOffset = c.offset + readableBytes;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不同之处在于，更新offset将是一个On的操作了</span></span><br><span class="line">                components.add(cIndex, c);</span><br><span class="line">                wasAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (readableBytes != <span class="number">0</span>) &#123;</span><br><span class="line">                    updateComponentOffsets(cIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (increaseWriterIndex) &#123;</span><br><span class="line">                writerIndex(writerIndex() + buffer.readableBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cIndex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有更新成功，则需要把对应的buffer引用-1</span></span><br><span class="line">            <span class="keyword">if</span> (!wasAdded) &#123;</span><br><span class="line">                buffer.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从上面的代码，可以清晰的看到，正常情况下，完全没有copy每一个组合中的bytebuf数据，而是维护一个包含bytebuf的component list，每个bytebuf的偏移信息等维护在component中，便于后续对CompositeByteBuf对象的操作。</p></blockquote><h5 id="DuplicatedByteBuf"><a href="#DuplicatedByteBuf" class="headerlink" title="DuplicatedByteBuf"></a>DuplicatedByteBuf</h5><p>ByteBuf维护了writeIndex和readIndex，当多个地方同时操作ByteBuf的时候，就会导致index错乱，这个时候，我们就需要复制一份数据，构造一个全新的ByteBuf对象。但是，另外一个方案，就是我只重新构造index，对于底层的buf，还是沿用原始的bytebuf。这样子，我们就不需要copy bytebuf中的所有数据到新的对象中。</p><h4 id="3-2-2-2-零拷贝之数据迁移"><a href="#3-2-2-2-零拷贝之数据迁移" class="headerlink" title="3.2.2.2 零拷贝之数据迁移"></a>3.2.2.2 零拷贝之数据迁移</h4><p>在不同系统空间之间会存在数据的来回拷贝，比如网络数据过来时，会从内核区的内存区间，拷贝到用户区的内存区间。如果加上JVM的堆内存，则还需要从用户区的Native内存拷贝到JVM堆内内存中，因此，正常需要好多次内存拷贝操作。</p><p>因此，为了快速优化拷贝性能，则需要考虑：</p><ol><li>socket数据 –&gt; 内核区空间</li><li>内核区空间 –&gt; Native内存空间</li><li>Native内存 –&gt; 堆内内存空间</li></ol><p>一般情况下，用户态的内存空间和系统内核的内存空间之间是隔离的，不允许彼此操作。</p><h5 id="DirectByteBuf"><a href="#DirectByteBuf" class="headerlink" title="DirectByteBuf"></a>DirectByteBuf</h5><p>直接操作堆外内存。避免堆内和堆外之间内存的复制拷贝。</p><h2 id="4-Netty-ByteBuf-内存管理"><a href="#4-Netty-ByteBuf-内存管理" class="headerlink" title="4. Netty ByteBuf 内存管理"></a>4. Netty ByteBuf 内存管理</h2><h3 id="4-1-堆内堆外内存"><a href="#4-1-堆内堆外内存" class="headerlink" title="4.1 堆内堆外内存"></a>4.1 堆内堆外内存</h3><h3 id="4-2-池化非池化内存"><a href="#4-2-池化非池化内存" class="headerlink" title="4.2 池化非池化内存"></a>4.2 池化非池化内存</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://cloud.tencent.com/developer/article/1005481">大话 Select、Poll、Epoll</a></li><li><a href="http://goldendoc.iteye.com/blog/1152079">Java NIO 的 wakeup 剖析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> netty </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计原则讨论123</title>
      <link href="2018/01/15/2018-01-15-design-principle-intro/"/>
      <url>2018/01/15/2018-01-15-design-principle-intro/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本设计原则，基于dubbo.io页面上整理而来。原文地址：<a href="http://dubbo.io/books/dubbo-dev-book/principals/introduction.html">http://dubbo.io/books/dubbo-dev-book/principals/introduction.html</a></p></blockquote><h2 id="1-代码基本要求"><a href="#1-代码基本要求" class="headerlink" title="1.代码基本要求"></a>1.代码基本要求</h2><h3 id="1-1-避免NPE和越界异常"><a href="#1-1-避免NPE和越界异常" class="headerlink" title="1.1 避免NPE和越界异常"></a>1.1 避免NPE和越界异常</h3><p>在java中，虽然可能出现各种异常，甚至我们使用异常来驱动非法业务逻辑执行流程，但是如果在执行过程中出现 空指针异常和越界异常，是非常不允许的。这说明代码不够健壮，开发同学意识不够严谨。推荐的做法，对数据进行判断，打印详细的错误信息，以及可能的告知上次参数不合法等。</p><h3 id="1-2-尽早失败FailFast"><a href="#1-2-尽早失败FailFast" class="headerlink" title="1.2 尽早失败FailFast"></a>1.2 尽早失败FailFast</h3><p>系统设计中，有一个尽早失败说法，表示，比如我们请求失败了，不进行重试，直接返回错误。代码中，也存在尽早失败的原则。比如，一个不合法的参数值或者记录状态，在请求的时候，应该进行参数检查，然后报错。在，开发过程中，有些同学，喜欢在使用参数的时候，才进行判断和错误处理，这样会导致耗费不必要的执行时间，甚至导致需要回滚之前的操作。</p><p>一般情况下，大家基本上会进行所有参数的前置校验；但是存在，一个请求，需要查询数据库判断是否状态合法时，可能有的时候，为了避免查表耗时，从而到用的时候才进行校验的情况。在正常业务下，为了这一点的RT提升，而可能让后续逻辑变得复杂，不太推荐。</p><span id="more"></span><h3 id="1-3-异常防御"><a href="#1-3-异常防御" class="headerlink" title="1.3 异常防御"></a>1.3 异常防御</h3><p>所谓，异常防御，是说我们的业务代码中，肯定有一些操作并不影响主流程流转。因此，我们需要对非核心逻辑的错误进行封装和容忍。</p><p>比如，银行卡签约支付，其中在支付过程中输入六要素完成预绑卡后，会调用商户平台绑卡接口，进行落绑卡记录数据。但是可能因为网络或者系统原因，并不会绑卡成功，这个并不会接下来的支付确认扣款操作，因此，我们会进行异常防御，捕获异常打印日志。</p><h3 id="1-4-降低代码误解率"><a href="#1-4-降低代码误解率" class="headerlink" title="1.4 降低代码误解率"></a>1.4 降低代码误解率</h3><p>代码误解，就是整个项目的代码，在某些时候可能会让开发理解出现分歧，开发包括别人和自己。</p><p>比如，一个方法返回null表示执行过程出现错误，返回””表示业务正常。这之后，如果我们忘记了这个约定，就会导致任何时候可能我们都以为出错了，或者业务都正常运行的。</p><p>又或者list为null表示当前不进行切流，size为0表示所有流量都切过去。这个再后面的时候，可能因为什么原因，需要切流回滚，而自己忘了这个约定，直接设置[]，导致都切流了。</p><p>因此，一个原则就是永远不要区分 null 引用和 empty 值。</p><h3 id="1-5-提供代码可测性"><a href="#1-5-提供代码可测性" class="headerlink" title="1.5 提供代码可测性"></a>1.5 提供代码可测性</h3><p>所谓，可测性，就是我们可以很好的写单元测试的MOCK部分。可 Mock 性是隔离的基础，把间接依赖的逻辑屏蔽掉。</p><p>基本上，大家的代码，基于spring的框架，mock还是没啥问题的。目前， Mock 性的一个最大的杀手就是静态方法。因此，除了工具类，其他尽量少写静态代码。</p><h3 id="1-6-查询修改分隔"><a href="#1-6-查询修改分隔" class="headerlink" title="1.6 查询修改分隔"></a>1.6 查询修改分隔</h3><p>参与修改的方法和只包含查询的方法，尽量区分开。</p><p>修改查询放在一起，会导致方法含义不清楚，其次可能会导致用错。比如，queryXXX(YYYDTO dto)方法，返回一个对象，但是其内部会对dto进行修改，这个时候，如果其他人不清楚内部实现，而直接用这个方法，从而不小心修改了不该被改的数据，最后数据莫名其妙出现变更，是非常不幸的。</p><h2 id="2-设计基本常识"><a href="#2-设计基本常识" class="headerlink" title="2.设计基本常识"></a>2.设计基本常识</h2><h3 id="2-1-API和SPI分离"><a href="#2-1-API和SPI分离" class="headerlink" title="2.1 API和SPI分离"></a>2.1 API和SPI分离</h3><p>API (Application Programming Interface) 是给使用者用的，而 SPI (Service Provide Interface) 是给扩展者用的。API和SPI分离，就是说，两者不会混合在一起，做到使用者不要看到SPI的实现。</p><p>比如，作为一个支付使用者，只需要知道支付API怎么调用即可，在其API调用实现的地方，不应该掺杂 SPI的扩展实现逻辑在里面，比如卡券支付扩展了支付SPI的具体实现逻辑。</p><h3 id="2-2-扩展接口职责单一"><a href="#2-2-扩展接口职责单一" class="headerlink" title="2.2 扩展接口职责单一"></a>2.2 扩展接口职责单一</h3><p>我们提供的一些接口，允许其他开发扩展的时候，尽量让接口功能单一，然后让使用者通过组合多个接口来完成一个大功能的实现。</p><p>对于RPC来说，dubbo提供了各个步骤的SPI接口给扩展者使用。包括：底层通讯，序列化，动态代理方式，编码，服务注册，负载均衡等等，这样比如，我们使用nova来实现服务注册发现，只需要修改registry部分就好。</p><h3 id="2-3-对象生命周期控制"><a href="#2-3-对象生命周期控制" class="headerlink" title="2.3 对象生命周期控制"></a>2.3 对象生命周期控制</h3><p>方法功能的设计，需要考虑清楚参数对象的生命周期管理。</p><p>比如，之前有个方法，要求传入dbConn数据库连接，然后进行操作数据库，操作完成之后，执行dbConn.close操作。嗯，这样子不会导致内存泄漏，但是，在后面另一个同学开发，在方法外面继续使用dbConn，然后发现出现问题(事实上，这里进行了简化。问题远比这个复杂，导致很久之后才发现问题，并且发现之后很久才定位出来)。</p><p>因此，有个宗旨，如果对象不是自己申请的，那么关闭释放的操作，也应该由申请方来完成。</p><h3 id="2-4-可配置一定可编程"><a href="#2-4-可配置一定可编程" class="headerlink" title="2.4 可配置一定可编程"></a>2.4 可配置一定可编程</h3><p>所谓，可配置一定可编程，就是说我们在开发组件的时候，为了方便使用，会采取配置的方式提供出去。但是，作为一个通用的组件，应该做到能配置文件完成功能的地方，那么也应该提供接口，方便其他框架组件和你的组件进行集成。</p><p>比如，支付网关业务方接入，需要引入一个基于spring的dubbo reference 配置，如果业务方不是spring/spring boot 框架呢，就不可用了。即使他使用spring框架，也有可能其无法通过配置来调用，如果提供一个代码或者按照约定配置(enable)亦可。</p><p>因此，我们使用配置是为了方便用户使用接入，而不是限制其使用场景。</p><h3 id="2-5-扩充式扩展与增量式扩展"><a href="#2-5-扩充式扩展与增量式扩展" class="headerlink" title="2.5 扩充式扩展与增量式扩展"></a>2.5 扩充式扩展与增量式扩展</h3><p>业务需求的不断增长变化，会导致之前的接口设计，需要进行功能增加和逻辑上的变更。这个时候，就出现两种扩展：扩充式扩展 和 增量式扩展。</p><p>扩充式扩展，指的是说，我们在老的接口上，增加一些判断和代码的调整，从而做到对于新老功能都能适用的一个通用实现。</p><p>增量式扩展，指的是说，放弃老的接口，新的功能需求独立实现，不调整老的接口功能。</p><p>一般情况下，我们习惯适用扩充式的扩展方式。因为，其保持接口数量尽量少，并且，修改也比较直接快速。比如，有个接口，之前没有描述字段，现在需要增加自定义描述，则直接在接口上加个字段，然后一步步透传，老接口默认为空就好了。</p><p>但是，有些情况，使用增量式扩展，会更好很多。</p><p>比如，dubbo的泛化调用。在泛化之前，接口是 invoke(Method method, Object[] args)，因为泛化没有方法和类，所以直觉上直接改成 invoke(String methodName, String[] parameterTypes, String returnTypes, Object[] args) 就可行。但是，后面会发现，为了支持泛化，要求基于jar调用都需要parameterTypes先将class转成string，得不偿失。因此，后面dubbo 针对泛化新增了逻辑，而不是修改老的基于jar的代码。</p><h3 id="2-6-避免不必要的复杂"><a href="#2-6-避免不必要的复杂" class="headerlink" title="2.6 避免不必要的复杂"></a>2.6 避免不必要的复杂</h3><p>帕累托原理，也就是所谓的二八法则。也就是说，我们拿出20%的努力去服务80%设计即可。因此，不要把我们的设计，搞得需要满足所有人所有需求，这样子，可能需要花费80%的时间耗在20%的设计上，或者根本就无法产出这样子的设计。</p><p>比如，之前的签约并发问题。业务方退款非常低，此外，基本上不存在退款完之后又订购的情况，更不用说，退订完立马订购的场景了。这个时候，就不一定非要去给自己找问题了（当然，这种态度是好的）。</p><p>因此，在把系统方案设计得尽量通用的前提下，避免钻进繁杂的20%黑洞里。此外，我们可以让业务逻辑调整一下来避免有些问题。</p><p>所以，在系统设计里面，尤其是分布式系统中，解决一个问题最好的办法，就是想办法绕过它。</p><h3 id="2-7-不可避免的兼容"><a href="#2-7-不可避免的兼容" class="headerlink" title="2.7 不可避免的兼容"></a>2.7 不可避免的兼容</h3><p>经常会遇到接口升级，这个时候，就需要考虑历史老接口的逻辑和数据的兼容问题。</p><p>服务方接口的升级，业务方并不会一定同步配合升级。这个时候老的业务和新的业务数据，能否兼容，是需要考虑的。</p><p>比如，后期新老认证迁移的时候，需要考虑两边的数据同步备份问题。在保证数据增量入口切到新的认证接口之后，还需要保证所有查询的结果数据，是一致的完整的。</p><h2 id="3-系统的健壮性"><a href="#3-系统的健壮性" class="headerlink" title="3.系统的健壮性"></a>3.系统的健壮性</h2><h3 id="3-1-日志"><a href="#3-1-日志" class="headerlink" title="3.1 日志"></a>3.1 日志</h3><p>日志，是发现问题，定位问题最好的最常用的一种方式。</p><h4 id="3-1-1-日志级别"><a href="#3-1-1-日志级别" class="headerlink" title="3.1.1 日志级别"></a>3.1.1 日志级别</h4><p>关于日志级别的约束：</p><ul><li>WARN 表示可以恢复的问题，无需人工介入。</li><li>ERROR 表示需要人工介入问题。</li></ul><p>有了这样的约定，监管系统发现日志文件的中出现 ERROR 字串就报警，又尽量减少了发生。过多的报警会让人疲倦，使人对报警失去警惕性，使 ERROR 日志失去意义。再辅以人工定期查看 WARN 级别信息，以评估系统的“亚健康”程度</p><h4 id="3-1-2-日志收集"><a href="#3-1-2-日志收集" class="headerlink" title="3.1.2 日志收集"></a>3.1.2 日志收集</h4><p>日志中，如果内容信息过多，会导致太杂乱，可能重要的信息就被忽略了，此外，对IO来说，也是一种压力。但是，日志太少了，又不方便查问题。</p><p>因此，我们需要定义关键日志信息：</p><ul><li>出问题时的现场信息，即排查问题要用到的信息。如服务调用失败时，要给出使用 Dubbo 的版本、服务提供者的 IP、使用的是哪个注册中心；调用的是哪个服务、哪个方法等等。这些信息如果不给出，那么事后人工收集的，问题过后现场可能已经不能复原，加大排查问题的难度。</li><li>如果可能，给出问题的原因和解决方法。这让维护和问题解决变得简单，而不是寻求精通者（往往是实现者）的帮助。</li></ul><blockquote><p>这里重点说下，问题原因和解决方法。之前使用HSF框架的时候，其错误出现的时候，都会给出对应的wiki地址，使用者直接跳转到wiki页面，找到出现错误的原因和解决方案，非常方便。</p></blockquote><blockquote><p>因此，我们也可以借鉴。比如，遇到支付失败，商家配置密钥错误之类的，打日志的时候，出现一个链接地址，值班同学直接根据链接，找到解决方案。</p></blockquote><h3 id="3-2-线程池"><a href="#3-2-线程池" class="headerlink" title="3.2 线程池"></a>3.2 线程池</h3><p>java的线程池非常好用，可以解决很多性能问题。但是，对于如何设计队列，以及拒绝策略，是个注意点。</p><p>一般，我们使用 LinkedBlockingQueue 来设置线程池阻塞队列，这个时候，需要考虑队列的长度了。如果你使用newFixedThreadPool，其内部没有设置queue的长度，可能会导致内存耗尽服务宕机。因此，一定要设置阻塞队列Queue的大小。</p><p>使用LinkedBlockingQueue还有一个可能的问题，就是服务超时恶化。当前面执行的任务时间较长，导致后面的服务都阻塞在队列中，而等到这些任务执行的时候，可能调用方认为服务已经超时了，然后重新调用，这个时候，老的任务继续执行，新的任务在阻塞队列等待，从而导致服务质量恶化。</p><p>因此，在HSF的实现中，没有采用LinkedBlockingQueue，而是使用SynchronousQueue，也就是没有等待的任务。线程不够的时候，就看拒绝策略了。</p><p>默认拒绝策略是AbortPolicy，也就是任务没有线程执行，队列满了之后，则执行丢弃操作。</p><p>但是，有些实现，我比较喜欢使用CallerRunsPolicy，也就是如果子线程不够的时候，由调用线程来执行。因为有的时候，我们无法对单个线程池进行评估，但是我们会对系统的处理能力进行评估，因此请求后续的任务交给调用线程来做，其实也只是将线程异步转为同步而已，但是某些阶段不会丢弃请求。</p><p>使用CallerRunsPolicy有个问题，关于ThreadLocal透传使用，会导致不容易区分是否应该被清除clear。</p><h3 id="3-3-容错可靠"><a href="#3-3-容错可靠" class="headerlink" title="3.3 容错可靠"></a>3.3 容错可靠</h3><p>如今的分布式应用，经常会依赖各种外部系统。对于一些非核心的依赖，要想办法去容错。</p><p>比如，实现一个限流，依赖redis和动态配置config。</p><p>我们把限流值配置在动态config上，然后依赖redis去统计qps从而来判断是否需要限流。但是如果config挂了，或者redis挂了呢？</p><p>动态config会保证即使server挂了，本地还会有一份快照来保证上一次的配置信息，因此高可靠。</p><p>redis呢？如果redis挂了，我们会切到本地单机限流模式，避免限流逻辑被停止不可用。</p><p>此外，dubbo的服务发现也是这样，如果zookeeper或者其他数据中心挂了，consumer端内存中还存在一份地址列表，只要不重启，就能一直使用，而不会找不到服务提供者机器。</p><h3 id="3-4-重试策略"><a href="#3-4-重试策略" class="headerlink" title="3.4 重试策略"></a>3.4 重试策略</h3><blockquote><p>不好的重试方式，会把下游的系统给搞死。此外，重试要求业务方幂等。</p></blockquote><h4 id="3-4-1-重试次数"><a href="#3-4-1-重试次数" class="headerlink" title="3.4.1 重试次数"></a>3.4.1 重试次数</h4><p>要不要重试，重试多少次，都需要好好考虑。</p><p>有些服务，其实没必要系统来重试，直接由用户再次点击刷新就可以完成了。</p><p>有些服务，保证了最终成功性，可能需要一种重试，直到服务可用。</p><p>还有一种，由于网络抖动，可能需要重试1、2次，尽量保证请求都是成功的。</p><h4 id="3-4-2-重试时机"><a href="#3-4-2-重试时机" class="headerlink" title="3.4.2 重试时机"></a>3.4.2 重试时机</h4><p>决定了重试，就需要考虑审核时候重试。</p><p>比如，服务调用3s超时，立马发起第二次重试，</p><p>比如，重试连接，由于可能出现雪崩的情况，所以重试的间隔时候，是随机的，避免瞬间请求到了服务方，把系统给打死了。</p><h2 id="4-业务异常"><a href="#4-业务异常" class="headerlink" title="4.业务异常"></a>4.业务异常</h2><h2 id="5-事件驱动"><a href="#5-事件驱动" class="headerlink" title="5.事件驱动"></a>5.事件驱动</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> design </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dubbo序列化机制处理-泛化&amp;普通RPC</title>
      <link href="2018/01/04/2018-01-03-dubbo-generic-serial-process/"/>
      <url>2018/01/04/2018-01-03-dubbo-generic-serial-process/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>当前，存在各种API网关，这些网关的定位之一就是管理域内各个服务需要对外的接口，统一做降级限流，权限控制，安全校验等工作。内部一般使用各种RPC服务，因此，基于微服务的不断扩展和升级，一般网关都是使用RPC 泛化机制来完成对内部服务的调用。</p><p>泛化机制，和普通的rpc调用有一些不同，它不需要引入各个依赖服务的jar包，调用方如果知道接口方法的具体信息：名称，版本，参数类型等，就可以完成rpc调用。</p><p>在开发过程中，使用泛化机制，发现一个”问题”，就是业务方调用我们内部的一个接口，接口中有一个参数是long类型，但是业务方使用string类型的参数(数字字符串，例如”12345678”)请求过来，但是并没有出现错误。这个问题，在于后面另一个业务方，也按照string类型请求(非纯数字，例如”E12345678”)，这个时候报错了。</p><span id="more"></span><h2 id="2-dubbo-泛化调用"><a href="#2-dubbo-泛化调用" class="headerlink" title="2. dubbo 泛化调用"></a>2. dubbo 泛化调用</h2><h3 id="2-1-dubbo-泛化调用示例"><a href="#2-1-dubbo-泛化调用示例" class="headerlink" title="2.1 dubbo 泛化调用示例"></a>2.1 dubbo 泛化调用示例</h3><p>先来看一个泛化调用的demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// --------消费端泛化调用代码--------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBizConsumer</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig(<span class="string">&quot;dubbo-provider&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ReferenceConfig&lt;GenericService&gt; ref = <span class="keyword">new</span> ReferenceConfig&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setProtocol(<span class="string">&quot;zookeeper&quot;</span>);</span><br><span class="line">        registryConfig.setAddress(<span class="string">&quot;127.0.0.1:2181&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ref.setTimeout(<span class="number">1000</span>);</span><br><span class="line">        ref.setProtocol(<span class="string">&quot;dubbo&quot;</span>);</span><br><span class="line">        ref.setConnections(<span class="number">2</span>);</span><br><span class="line">        ref.setInterface(<span class="string">&quot;io.github.ketao1989.dubbo.api.IUserBiz&quot;</span>);</span><br><span class="line">        ref.setApplication(applicationConfig);</span><br><span class="line">        ref.setRegistry(registryConfig);</span><br><span class="line">        ref.setGeneric(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        GenericService service = ref.get();</span><br><span class="line">        Object o = service.$invoke(<span class="string">&quot;queryName&quot;</span>,<span class="keyword">new</span> String[]&#123;<span class="string">&quot;long&quot;</span>&#125;,<span class="keyword">new</span> Object[]&#123;<span class="number">12</span>&#125;);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------服务端代码--------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBizProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;dubbo/dubbo-provider.xml&quot;</span>);</span><br><span class="line">        context.start();</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserBiz</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id获取用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryName</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面是一个简单的测试rpc的代码。服务端对外提供的服务是一个普普通通rpc实现，参数是一个long类型。<br>消费端的代码也是按照接口约定，传输long类型的12请求服务。和普通rpc调用不同，其没有引入jar api来调用，而是通过代码写配置来完成调用服务，这样就不需要在服务端加入和升级api的时候，还需要网关来升级版本了。</p></blockquote><h3 id="2-2-dubbo-泛化调用机制"><a href="#2-2-dubbo-泛化调用机制" class="headerlink" title="2.2 dubbo 泛化调用机制"></a>2.2 dubbo 泛化调用机制</h3><p>虽然，从上面的demo来看，泛化机制最大的不同，在消费端需要代码写入大量的接口属性信息。但是，实际上，在底层实现上，并无大区别。看看普通的rpc调用配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;dubbo-provider&quot;</span>  /&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;127.0.0.1:2181&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span> <span class="attr">id</span>=<span class="string">&quot;provider-registry&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20881&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- consumer--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;io.github.ketao1989.dubbo.api.IUserBiz&quot;</span> <span class="attr">id</span>=<span class="string">&quot;userBiz&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基于api调用的消费端，框架会对 <code>dubbo:reference</code> 进行动态代理，实际调用具体的方法的时候，会拦截，然后解析出方法，入参属性等数据，然后和泛化调用蕾西，将解析完成之后的数据，包装成<code>ReferenceConfig</code>来传递给服务端，收到结果，完成调用。</p><p>既然，消费端在底层实现上并没有什么区别，那就说明，在服务端肯定有些不同的。</p><p>在框架的服务端，存在对于泛化调用的逻辑分支：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (inv.getMethodName().equals(Constants.$INVOKE) </span><br><span class="line">               &amp;&amp; inv.getArguments() != <span class="keyword">null</span></span><br><span class="line">               &amp;&amp; inv.getArguments().length == <span class="number">3</span></span><br><span class="line">               &amp;&amp; ! invoker.getUrl().getParameter(Constants.GENERIC_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                   <span class="comment">// 通用的泛化调用</span></span><br><span class="line">                   <span class="comment">// 获取实际需要执行的方法，参数类型，参数等</span></span><br><span class="line">                   String name = ((String) inv.getArguments()[<span class="number">0</span>]).trim();</span><br><span class="line">                   String[] types = (String[]) inv.getArguments()[<span class="number">1</span>];</span><br><span class="line">                   Object[] args = (Object[]) inv.getArguments()[<span class="number">2</span>];</span><br><span class="line">                   Method method = ReflectUtils.findMethodByMethodSignature(invoker.getInterface(), name, types);</span><br><span class="line">                   Class&lt;?&gt;[] params = method.getParameterTypes();</span><br><span class="line">                   <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       args = <span class="keyword">new</span> Object[params.length];</span><br><span class="line">                   &#125;</span><br><span class="line">                   String generic = inv.getAttachment(Constants.GENERIC_KEY);</span><br><span class="line">               </span><br><span class="line">                   args = PojoUtils.realize(args, params, method.getGenericParameterTypes());</span><br><span class="line">                   Result result = invoker.invoke(<span class="keyword">new</span> RpcInvocation(method, args, inv.getAttachments()));<span class="keyword">return</span> <span class="keyword">new</span> RpcResult(PojoUtils.generalize(result.getValue()));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>泛化调用和普通调用,如上代码，实现分支是不同的。基于泛化机制的调用，其首先会对入参进行解析，构造和普通调用一样的<code>RpcInvocation</code>对象，然后执行具体实现方法，包装结果返回。<br>判断泛化调用的前置条件是方法名为<code>$invoke</code>。</p></blockquote><p>和普通rpc调用不同的地方是，泛化调用会存在多一次序列化的操作，如代码:</p><p><code>args = PojoUtils.realize(args, params, method.getGenericParameterTypes());</code></p><p>这个地方就是一个关键。将泛化调用的参数按照规则进行解析，我们拿到了method，拿到了实际方法类型列表，以及具体参数。但是，对于具体参数，dubbo框架解析的时候，会进行一些兼容处理，如下代码块(只截取我们关系的代码段)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 兼容类型转换。null值是OK的。如果不需要转换，则返回原来的值。</span></span><br><span class="line"><span class="comment">    * 进行的兼容类型转换如下：（基本类对应的Wrapper类型不再列出。）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">compatibleTypeConvert</span><span class="params">(Object value, Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(value == <span class="keyword">null</span> || type == <span class="keyword">null</span> || type.isAssignableFrom(value.getClass())) &#123;</span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">           String string = (String) value;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">char</span>.class.equals(type) || Character.class.equals(type)) &#123;</span><br><span class="line">               <span class="keyword">if</span>(string.length() != <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;CAN NOT convert String(%s) to char!&quot;</span> +</span><br><span class="line">                           <span class="string">&quot; when convert String to char, the String MUST only 1 char.&quot;</span>, string));</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> string.charAt(<span class="number">0</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type.isEnum()) &#123;</span><br><span class="line">               <span class="keyword">return</span> Enum.valueOf((Class&lt;Enum&gt;)type, string);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == BigInteger.class) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(string);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == BigDecimal.class) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(string);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == Short.class || type == <span class="keyword">short</span>.class) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> Short(string);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == Integer.class || type == <span class="keyword">int</span>.class) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> Integer(string);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == Long.class || type == <span class="keyword">long</span>.class) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> Long(string);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == Double.class || type == <span class="keyword">double</span>.class) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> Double(string);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == Float.class || type == <span class="keyword">float</span>.class) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> Float(string);</span><br><span class="line">           &#125;  <span class="keyword">else</span> <span class="keyword">if</span>(type == Byte.class || type == <span class="keyword">byte</span>.class) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> Byte(string);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == Boolean.class || type == <span class="keyword">boolean</span>.class) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> Boolean(string);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == Date.class) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(DATE_FORMAT).parse((String) value);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to parse date &quot;</span> + value + <span class="string">&quot; by format &quot;</span> + DATE_FORMAT + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Class.class) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> ReflectUtils.name2class((String)value);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上面的方法入参type，是从获取到的具体method中拿到的，value则是消费端传输过来的。因此，这个方法，就是在如果存在请求参数类型和具体执行method的参数不一致时，则进行兼容转换到正确的参数类型，完成调用。<br>所以，当我们通过泛化传来”12345678”的时候，可以自动转换为long类型，但是如果参数是”E12345678”,则自动转换就会失败，抛出异常。</p></blockquote><h3 id="2-3-dubbo泛化调用之参数类型1"><a href="#2-3-dubbo泛化调用之参数类型1" class="headerlink" title="2.3 dubbo泛化调用之参数类型1"></a>2.3 dubbo泛化调用之参数类型1</h3><p>2.2节，我们知道如果具体的参数值和实际参数类型不一致的时候，dubbo框架会尝试一次自动类型转换，来保证尽可能成功。但是，如果我们在demo中，修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = service.$invoke(<span class="string">&quot;queryName&quot;</span>,<span class="keyword">new</span> String[]&#123;<span class="string">&quot;java.lang.String&quot;</span>&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;12&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><p>会怎样？<br>看demo执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.dubbo.rpc.RpcException: io.github.ketao1989.dubbo.api.IUserBiz.queryName(java.lang.String)</span><br><span class="line">at com.alibaba.dubbo.rpc.filter.GenericFilter.invoke(GenericFilter.java:107)</span><br><span class="line">at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)</span><br><span class="line">at com.alibaba.dubbo.rpc.filter.ClassLoaderFilter.invoke(ClassLoaderFilter.java:38)</span><br><span class="line">at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)</span><br><span class="line">at com.alibaba.dubbo.rpc.filter.EchoFilter.invoke(EchoFilter.java:38)</span><br><span class="line">at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)</span><br><span class="line">at com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol$1.reply(DubboProtocol.java:108)</span><br><span class="line">at com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeHandler.handleRequest(HeaderExchangeHandler.java:84)</span><br><span class="line">at com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeHandler.received(HeaderExchangeHandler.java:170)</span><br><span class="line">at com.alibaba.dubbo.remoting.transport.DecodeHandler.received(DecodeHandler.java:52)</span><br><span class="line">at com.alibaba.dubbo.remoting.transport.dispatcher.ChannelEventRunnable.run(ChannelEventRunnable.java:82)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: java.lang.NoSuchMethodException: io.github.ketao1989.dubbo.api.IUserBiz.queryName(java.lang.String)</span><br><span class="line">at java.lang.Class.getMethod(Class.java:1786)</span><br><span class="line">at com.alibaba.dubbo.common.utils.ReflectUtils.findMethodByMethodSignature(ReflectUtils.java:816)</span><br><span class="line">at com.alibaba.dubbo.rpc.filter.GenericFilter.invoke(GenericFilter.java:57)</span><br><span class="line">... 13 more</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>抛出了异常，因此，如果消费端的类型都不对，是不可能执行成功的。</p><p>看代码逻辑，请求执行会到服务端，然后在运行到如下代码时出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Method method = ReflectUtils.findMethodByMethodSignature(invoker.getInterface(), name, types);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据方法签名从类中找出方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz 查找的类。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodName 方法签名，形如method1(int, String)。也允许只给方法名不参数只有方法名，形如method2。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回查找到的方法。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException 给定的方法签名找到多个方法（方法签名中没有指定参数，又有有重载的方法的情况）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Method <span class="title">findMethodByMethodSignature</span><span class="params">(Class&lt;?&gt; clazz, String methodName, String[] parameterTypes)</span> <span class="keyword">throws</span> NoSuchMethodException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[parameterTypes.length];<span class="comment">//java.lang.String</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i ++) &#123;</span><br><span class="line">            types[i] = ReflectUtils.name2class(parameterTypes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        method = clazz.getMethod(methodName, types);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Class反射拿到method，就会出错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="keyword">true</span>);</span><br><span class="line">        Method method = getMethod0(name, parameterTypes, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(getName() + <span class="string">&quot;.&quot;</span> + name + argumentTypesToString(parameterTypes));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>findMethodByMethodSignature方法会根据clazz类，methodName方法名和方法参数类型来反射拿到具体的方法，但是因为不存在对应给的method，所以抛异常失败。</p></blockquote><h3 id="2-4-dubbo泛化调用之参数类型2"><a href="#2-4-dubbo泛化调用之参数类型2" class="headerlink" title="2.4 dubbo泛化调用之参数类型2"></a>2.4 dubbo泛化调用之参数类型2</h3><p>在业务中，我们的dubbo调用方式，会存在复杂对象，不是原始类型。那么，如果我对象类型是正确的，但是对象内部的类型不对呢？</p><p>先看一下demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserBiz</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(UserRequest request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBizConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...... 省略一些重复代码</span></span><br><span class="line">        Map&lt;String,Object&gt; value = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        value.put(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;1234567&quot;</span>);</span><br><span class="line">        value.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;kk123&quot;</span>);</span><br><span class="line">        Object o2 = service.$invoke(<span class="string">&quot;addUser&quot;</span>,<span class="keyword">new</span> String[]&#123;<span class="string">&quot;io.github.ketao1989.dubbo.api.UserRequest&quot;</span>&#125;,<span class="keyword">new</span> Object[]&#123;value&#125;);</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>如上代码，可以看到，id是long类型，但是参数里面，id是一个字符串，但是id是在mapl里面。这个case，在执行的时候，并不会报错，而是返回值，例如：<code>&#123;&quot;id&quot;:1234567,&quot;name&quot;:&quot;kk123&quot;&#125;</code></p></blockquote><p>因此，我们可以看到泛化调用，即使type是个对象，对象里面的属性类型存在问题，也不一定会出错。在最底层，和2.2节一样，会对方法类型和值类型不一致的情况，进行兼容处理。</p><p>由于请求参数值得类型，不是Primitives类型，所以会进行特殊处理，例如我们这个demo里面是一个Map，所以走如下代码逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">realize0</span><span class="params">(Object pojo, Class&lt;?&gt; type, Type genericType, <span class="keyword">final</span> Map&lt;Object, Object&gt; history)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pojo <span class="keyword">instanceof</span> Map&lt;?, ?&gt; &amp;&amp; type != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Object, Object&gt; map;</span><br><span class="line">    <span class="comment">// 返回值类型不是方法签名类型的子集 并且 不是接口类型</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isInterface() &amp;&amp; !type.isAssignableFrom(pojo.getClass())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        map = (Map&lt;Object, Object&gt;) type.newInstance(); <span class="comment">// 由于类型不对，一般这里会抛异常</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//ignore error</span></span><br><span class="line">        map = (Map&lt;Object, Object&gt;) pojo; <span class="comment">// 执行这里的逻辑，强转map</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Object dest = newInstance(type);<span class="comment">//反射构造函数，new个对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : map.entrySet()) &#123; <span class="comment">// 遍历每个map元素</span></span><br><span class="line">      Object key = entry.getKey();</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">instanceof</span> String) &#123; <span class="comment">// 支持map，获取属性名称</span></span><br><span class="line">        String name = (String) key;</span><br><span class="line">        Object value = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Method method = getSetterMethod(dest.getClass(), name, value.getClass()); <span class="comment">//根据字段名，获取setter方法</span></span><br><span class="line">          <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!method.isAccessible()) &#123;</span><br><span class="line">              method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Type ptype = method.getGenericParameterTypes()[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 对请求值进行兼容改造处理，例如string转成需要的long，所以，转换成功就不会报错</span></span><br><span class="line">            value = realize0(value, method.getParameterTypes()[<span class="number">0</span>], ptype, history);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              method.invoke(dest, value);<span class="comment">// set方法来设置value到dest对象中</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;&#125;&#125;&#125;</span><br><span class="line">      <span class="keyword">return</span> dest;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  <span class="keyword">return</span> pojo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此，如果我们对复杂对象中的某一个属性类型，在构造map的时候没有设置对，但是在dubbo中，这两个类型之间可以进行兼容转换，则不会出错。当然，如果是”E123456”，由于无法转成long类型，所以还是会报错的。</p><h2 id="3-dubbo-序列化"><a href="#3-dubbo-序列化" class="headerlink" title="3. dubbo 序列化"></a>3. dubbo 序列化</h2><h3 id="3-1-不兼容的hessian2序列化"><a href="#3-1-不兼容的hessian2序列化" class="headerlink" title="3.1 不兼容的hessian2序列化"></a>3.1 不兼容的hessian2序列化</h3><p>最后，简单聊聊dubbo的序列化。如果，我们没有特别的进行配置，则dubbo默认使用自定义的hessian2进行序列化操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodecSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  DEFAULT_REMOTING_SERIALIZATION     = <span class="string">&quot;hessian2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Serialization <span class="title">getSerialization</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Serialization.class).getExtension(</span><br><span class="line">            url.getParameter(Constants.SERIALIZATION_KEY, DEFAULT_REMOTING_SERIALIZATION));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于hessian2的序列化，我们来一个demo看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.serialize.ObjectInput;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.serialize.ObjectOutput;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.serialize.support.hessian.Hessian2Serialization;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// UserRequestOth 和 UserRequest 一致，只是id是string</span></span><br><span class="line">        UserRequestOth request = <span class="keyword">new</span> UserRequestOth(<span class="string">&quot;11111&quot;</span>,<span class="string">&quot;rpc serial&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream(<span class="number">512</span>);</span><br><span class="line">        Hessian2Serialization hessian2Serialization = <span class="keyword">new</span> Hessian2Serialization();</span><br><span class="line"></span><br><span class="line">        ObjectOutput output = hessian2Serialization.serialize(<span class="keyword">null</span>, bos);</span><br><span class="line">        output.writeObject(request);</span><br><span class="line">        output.flushBuffer();</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream inputStream = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInput input = hessian2Serialization.deserialize(<span class="keyword">null</span>, inputStream);</span><br><span class="line">        UserRequest res  = input.readObject(UserRequest.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行的时候，会抛出异常，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.alibaba.com.caucho.hessian.io.HessianFieldException: io.github.ketao1989.dubbo.api.UserRequest.id: expected long at 0x5 java.lang.String (11111)</span><br><span class="line">at com.alibaba.com.caucho.hessian.io.JavaDeserializer.logDeserializeError(JavaDeserializer.java:671)</span><br><span class="line">at com.alibaba.com.caucho.hessian.io.JavaDeserializer$LongFieldDeserializer.deserialize(JavaDeserializer.java:515)</span><br><span class="line">at com.alibaba.com.caucho.hessian.io.JavaDeserializer.readObject(JavaDeserializer.java:233)</span><br><span class="line">at com.alibaba.com.caucho.hessian.io.JavaDeserializer.readObject(JavaDeserializer.java:157)</span><br><span class="line">at com.alibaba.com.caucho.hessian.io.Hessian2Input.readObjectInstance(Hessian2Input.java:2067)</span><br><span class="line">at com.alibaba.com.caucho.hessian.io.Hessian2Input.readObject(Hessian2Input.java:1592)</span><br><span class="line">at com.alibaba.com.caucho.hessian.io.Hessian2Input.readObject(Hessian2Input.java:1576)</span><br><span class="line">at com.alibaba.dubbo.common.serialize.support.hessian.Hessian2ObjectInput.readObject(Hessian2ObjectInput.java:94)</span><br><span class="line">at io.github.ketao1989.serial.SerialTest.main(SerialTest.java:63)</span><br><span class="line">Caused by: com.alibaba.com.caucho.hessian.io.HessianProtocolException: expected long at 0x5 java.lang.String (11111)</span><br><span class="line">at com.alibaba.com.caucho.hessian.io.Hessian2Input.error(Hessian2Input.java:2720)</span><br><span class="line">at com.alibaba.com.caucho.hessian.io.Hessian2Input.expect(Hessian2Input.java:2691)</span><br><span class="line">at com.alibaba.com.caucho.hessian.io.Hessian2Input.readLong(Hessian2Input.java:888)</span><br><span class="line">at com.alibaba.com.caucho.hessian.io.JavaDeserializer$LongFieldDeserializer.deserialize(JavaDeserializer.java:511)</span><br><span class="line">... 7 more</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>综上，如果我们client端的jar包和server端的jar包中，关于某个入参对象中的一个属性对象不一致的话，由于接收到请求后，首先就是使用自定义hessian2进行反序列，如果数据类型匹配兼容不了，dubbo调用会抛出异常返回失败。</p></blockquote><h3 id="3-2-简单兼容的dubbo处理"><a href="#3-2-简单兼容的dubbo处理" class="headerlink" title="3.2 简单兼容的dubbo处理"></a>3.2 简单兼容的dubbo处理</h3><p>如果，将上面示例代码中 <code>UserRequest</code>和<code>UserRequestOth</code>互换下，会发现dubbo调用，并不会发送失败。为什么呢？因为，long 到 Sting类型的转换是兼容的，也就是说，任何一个类型是long的数据，都可以被转换成String类型，而不出现数据不正确的情况。</p><p>当然，我们可以看看dubbo自定义的hessian2代码中这块逻辑的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">readObject</span><span class="params">(AbstractHessianInput in,</span></span></span><br><span class="line"><span class="params"><span class="function">   Object obj,</span></span></span><br><span class="line"><span class="params"><span class="function">   String []fieldNames)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">int</span> ref = in.addRef(obj);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fieldNames.length; i++) &#123;</span><br><span class="line">       String name = fieldNames[i];</span><br><span class="line">       </span><br><span class="line">       FieldDeserializer deser = (FieldDeserializer) _fieldMap.get(name);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (deser != <span class="keyword">null</span>)</span><br><span class="line">  deser.deserialize(in, obj);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         in.readObject();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Object resolve = resolve(obj);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (obj != resolve)</span><br><span class="line">in.setRef(ref, resolve);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> resolve;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> e;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IOExceptionWrapper(obj.getClass().getName() + <span class="string">&quot;:&quot;</span> + e, e);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StringFieldDeserializer</span> <span class="keyword">extends</span> <span class="title">FieldDeserializer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Field _field;</span><br><span class="line"></span><br><span class="line">   StringFieldDeserializer(Field field)</span><br><span class="line">   &#123;</span><br><span class="line">     _field = field;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">deserialize</span><span class="params">(AbstractHessianInput in, Object obj)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     String value = <span class="keyword">null</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">value = in.readString();</span><br><span class="line"></span><br><span class="line">_field.set(obj, value);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       logDeserializeError(_field, obj, value, e);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>代码是根据最后反序列化出的对象类型来进行deserialize的，因此，针对对象，默认使用<code>JavaDeserializer</code>类来操作。把long转换为String，因此，目标字段类型是String，所以，最终使用<code>StringFieldDeserializer</code>来操作id这个字段的反序列化。</p></blockquote><p>那，由于调用方传来的是long，我们使用readString是怎么执行下去的呢？</p><p>dubbo 自定义重写了hessian2的 Hessian2Input，所以基本上，dubbo把hessian2的序列化代码重写了。下面看看Hessian2Input的readString是如何实现的（部分代码片段）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tag = read();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;true&quot;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;false&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// direct long</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xd8</span>: <span class="keyword">case</span> <span class="number">0xd9</span>: <span class="keyword">case</span> <span class="number">0xda</span>: <span class="keyword">case</span> <span class="number">0xdb</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xdc</span>: <span class="keyword">case</span> <span class="number">0xdd</span>: <span class="keyword">case</span> <span class="number">0xde</span>: <span class="keyword">case</span> <span class="number">0xdf</span>:</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xe0</span>: <span class="keyword">case</span> <span class="number">0xe1</span>: <span class="keyword">case</span> <span class="number">0xe2</span>: <span class="keyword">case</span> <span class="number">0xe3</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xe4</span>: <span class="keyword">case</span> <span class="number">0xe5</span>: <span class="keyword">case</span> <span class="number">0xe6</span>: <span class="keyword">case</span> <span class="number">0xe7</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xe8</span>: <span class="keyword">case</span> <span class="number">0xe9</span>: <span class="keyword">case</span> <span class="number">0xea</span>: <span class="keyword">case</span> <span class="number">0xeb</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xec</span>: <span class="keyword">case</span> <span class="number">0xed</span>: <span class="keyword">case</span> <span class="number">0xee</span>: <span class="keyword">case</span> <span class="number">0xef</span>:</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(tag - BC_LONG_ZERO);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(parseLong());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> BC_STRING_CHUNK:</span><br><span class="line">    _isLastChunk = tag == <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">    _chunkLength = (read() &lt;&lt; <span class="number">8</span>) + read();</span><br><span class="line"></span><br><span class="line">    _sbuf.setLength(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((ch = parseChar()) &gt;= <span class="number">0</span>)</span><br><span class="line">      _sbuf.append((<span class="keyword">char</span>) ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _sbuf.toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0-byte string</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x00</span>: <span class="keyword">case</span> <span class="number">0x01</span>: <span class="keyword">case</span> <span class="number">0x02</span>: <span class="keyword">case</span> <span class="number">0x03</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x04</span>: <span class="keyword">case</span> <span class="number">0x05</span>: <span class="keyword">case</span> <span class="number">0x06</span>: <span class="keyword">case</span> <span class="number">0x07</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x08</span>: <span class="keyword">case</span> <span class="number">0x09</span>: <span class="keyword">case</span> <span class="number">0x0a</span>: <span class="keyword">case</span> <span class="number">0x0b</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x0c</span>: <span class="keyword">case</span> <span class="number">0x0d</span>: <span class="keyword">case</span> <span class="number">0x0e</span>: <span class="keyword">case</span> <span class="number">0x0f</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x10</span>: <span class="keyword">case</span> <span class="number">0x11</span>: <span class="keyword">case</span> <span class="number">0x12</span>: <span class="keyword">case</span> <span class="number">0x13</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x14</span>: <span class="keyword">case</span> <span class="number">0x15</span>: <span class="keyword">case</span> <span class="number">0x16</span>: <span class="keyword">case</span> <span class="number">0x17</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x18</span>: <span class="keyword">case</span> <span class="number">0x19</span>: <span class="keyword">case</span> <span class="number">0x1a</span>: <span class="keyword">case</span> <span class="number">0x1b</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1c</span>: <span class="keyword">case</span> <span class="number">0x1d</span>: <span class="keyword">case</span> <span class="number">0x1e</span>: <span class="keyword">case</span> <span class="number">0x1f</span>:</span><br><span class="line">    _isLastChunk = <span class="keyword">true</span>;</span><br><span class="line">    _chunkLength = tag - <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    _sbuf.setLength(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((ch = parseChar()) &gt;= <span class="number">0</span>)</span><br><span class="line">      _sbuf.append((<span class="keyword">char</span>) ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _sbuf.toString();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x30</span>: <span class="keyword">case</span> <span class="number">0x31</span>: <span class="keyword">case</span> <span class="number">0x32</span>: <span class="keyword">case</span> <span class="number">0x33</span>:</span><br><span class="line">    _isLastChunk = <span class="keyword">true</span>;</span><br><span class="line">    _chunkLength = (tag - <span class="number">0x30</span>) * <span class="number">256</span> + read();</span><br><span class="line"></span><br><span class="line">    _sbuf.setLength(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((ch = parseChar()) &gt;= <span class="number">0</span>)</span><br><span class="line">      _sbuf.append((<span class="keyword">char</span>) ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _sbuf.toString();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">throw</span> expect(<span class="string">&quot;string&quot;</span>, tag);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此，我们发现，如果是long数字类型，则会使用String.valueOf来进行转换为string类型，因此我们的代码处理值为long类型，目标为string类型时，没有出现任何错误，并且结果也是正确的原因所在。</p><h2 id="4-最后"><a href="#4-最后" class="headerlink" title="4. 最后"></a>4. 最后</h2><p>虽然，现在大部分接口服务都是通过泛化走网关对外提供的，而dubbo的泛化调用会对某些参数类型进行兼容处理。<br>但是，最为服务化的接口规范，我们显然是不允许修改api包中的已存在属性的类型（dubbo hessian2做了某些类型转换的兼容，并不是一个允许的好借口）。<br>一般来说，对于某些字段的类型可能不再支持当前业务发展时，采取的方式都是新增字段，来支持新功能，并且通过业务逻辑来兼容老的版本。</p><p>之所以，这样子处理，主要是因为：</p><ul><li><p>调用方业务收到影响。如果存在业务方使用jar包调用，hessian2无法兼容，那将是灾难性的后果，调用的请求将全部失败，尤其是有的系统会将dubbo反序列化失败的日志，放在单独的目录文件下，导致观察业务日志时，并没有错误的地方。这个时候，除了业务方反馈，还有就是查看调用方请求量的监控来主动发现。</p></li><li><p>存在某些不兼容的场景。比如，将string—&gt;long调整，可能当前某些时候能正常运行。后期业务方，发现自己需要业务调整，新业务的参数值变成<code>New1234</code>，这个时候，就会发现调用失败了。</p></li><li><p>最后，但是也是最重要的，这就是api的规范，遵循规范，可以避免自己和别人掉进坑里。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> dubbo </category>
          
          <category> hessian </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出Java服务端原理之基础篇</title>
      <link href="2017/03/29/2017-03-29-java-server-in-action/"/>
      <url>2017/03/29/2017-03-29-java-server-in-action/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上篇文章介绍了<a href="http://ketao1989.github.io/2016/12/10/rpc-theory-in-action/">深入浅出RPC一些原理知识</a>，这里将继续深入讲讲关于RPC网络服务技术。本文的目标，是让对Java网络服务端开发感兴趣的新人，可以一步步深入了解一个高性能服务所需要的相关知识体系。</p><p>当然，高性能高并发的服务端开发，涉及的知识点和手段众多，比如linux网络和内核参数调优等。本文只关注代码开发层级的介绍和深入。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文中，所谓 <code>服务端</code>指的是，基于client/server服务组件中的server端。在网络世界里，基本上任何一个用户交互都涉及客户端和服务器端网络通信；尤其是，当存在对服务端大量请求时，如果让服务器持续对外服务过程中，抗住更多的并发请求，是一个互联网开发同学十分关心和必备的技能。</p><p>本文中，首先会基于Java网络API开发一个<code>HelloWorld</code>版本的server端版本。<br>接下来，会不断的在前一个server版本上进行优化和升级，使得其可以响应更多的网络连接请求。<br>在此期间，会引入一些概念，比如IO同步异步、阻塞非阻塞。<br>最后，我们要站在巨人的肩膀上，基于Netty来开发一个生产级别的server端应用。</p><span id="more"></span><h2 id="网络协议介绍"><a href="#网络协议介绍" class="headerlink" title="网络协议介绍"></a>网络协议介绍</h2><blockquote><p>服务器开发，是基于网络协议基础上的，虽然Java 网络API已经封装了协议细节，但是在分析程序运行中出现的一些网络问题，优化服务通信性能时，还是很有用的。</p><p>这里主要介绍传输层的两大协议：TCP和UDP协议。（深入的介绍，请参考 《TCP/IP 详解 卷1：协议》这本经典书籍。）一般应用定制所谓自定义的网络协议，基本上都是基于传输层来实现的。</p></blockquote><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><blockquote><p> 传输层主要有两大协议：面向连接的TCP (Transmission Control Protocol)协议和面向无连接的UDP (User Datagram Protocol)协议。相对于UDP协议，TCP为了保证连接的可靠性，其协议实现细节是相当复杂的。</p></blockquote><h4 id="三次握手-四次握手"><a href="#三次握手-四次握手" class="headerlink" title="三次握手/四次握手"></a>三次握手/四次握手</h4><p>既然TCP是面向连接的协议，那就存在如何建立连接以及如何断开连接的问题。</p><blockquote><p>在介绍TCP连接协议前，需要特别指出：TCP所谓的处在连接状态<code>ESTABLISHED</code>，只是说明在通信双方建立的<code>连接状态表</code>中，当前的TCP链路是连接的。而且，通信双方的状态表，并不保证是一致的。<br>所以，在使用TCP协议的业务里，都需要有一个定时器来发送一个特殊的段给对等方检测当前链路是否依然处于连接状态，也就是<code>存活检测</code>。在后面的介绍中，还会有应用级别的<code>存活检测</code>。</p></blockquote><p>首先，在所有的介绍TCP协议的文章里都会有的握手图（来自网络，参考文献1）：</p><p><img src="/images/2017/tcp_open_close.jpeg" alt="Alt text"></p><p>所谓三次握手，就是在通信双方建立TCP连接的时候，需要双方共发送3个数据包来确认双方为通信都准备OK。</p><ol><li>第一次握手。客户端client首先初始化一个SYN序列号x，一般第一次客户端和服务端握手时，SYN初始化为0，随后每次都会加上传输数据的字节作为对端新的SYN序列号。Client将产生的SYN序列化发送给Server，并将自己的状态置为<code>SYN_SENT</code>。</li><li>第二次握手。服务端Server接收到Client发送过来的连接请求包，由于在建立TCP连接的请求包中并没有有效数据(设置FIN和SYN这种标志位的包，是不计算有效数据的)，所以Server发送的握手包中，SYN序列号为0（Server对这次建立连接也是第一次），以及ACK确认号1=0+1。此外，服务器Server将自己的状态设置为<code>SYN_RCVD</code>。</li><li>第三次握手。客户端Client接收到Server发送回来的确认包，根据服务端ACK号和SYN号，发送自己的最后一个连接数据包，其中和第二次握手相似，SYN序列号为1，ACK为1=0+1。并将自己的连接状态设置为<code>ESTABLISHED</code>。</li></ol><p>在TCP通信过程中，ACK数据，是根据对方SYN序列号，再加上本次数据包有效数据大小来计算的，而下次对端发送SYN序列号的值就是其收到的ACK值。SYN 和 ACK的逻辑，保证了TCP重传机制。</p><blockquote><p>在了解TCP建立连接进行的三次握手过程之后，肯定会有疑问，为什么是3次，而不是2次或者4次呢？</p><p> 3次考虑，是在满足日常应用场景中，所需要的最少次数。1次肯定不行，如果是2次呢？假设 C 向 S 发送连接请求，当时这个请求没有到达 S 。然后 C 重新发送一个连接请求，S接收到并且发送响应包，然后连接建立。正常数据交换完了之后，关闭连接。但是，这个时候，第一次的连接请求发送了过来，S 建立连接，一直处于等待数据交互中。<br> 或者，C 向 S 发送连接请求， 然后 S 会发送一个响应包，可能 C 可能没有收到这个响应包。这个时候，S 可能以为 C 收到了ACK包，然后S给C发送数据分组包，但是 C 一直在等待 S 的ACK应答分组包，并把 S 的数据分组报丢弃。<br> 其实，2次握手，最重要的是，在双方都以为建立连接的情况下，可能存在无法对S的序列号达成一致。但是，3次握手，就可以确认好 C 和 S 的初始序列号一致。</p><p> 以上可以阅读参考文献2。</p></blockquote><p>所谓的四次握手（也有叫做四次挥手的），就是处在连接状态的通信双方，正常断开连接所需要进行的四次数据包交互流程。由于TCP是全双工，因此通信双方都需要进行关闭，所以会进行4次握手。</p><ol><li>第一次握手。客户端将发送FIN包给服务端，关闭连接。FIN包中，FIN序列号和ACK值与前面数据组交互一样。此时，客户端处于<code>FIN_WAIT_1</code>状态。</li><li>第二次握手。服务端收到客户端的FIN包之后，只会发回一个ACK包，表示收到关闭连接请求。此时，服务端处于<code>CLOSE_WAIT</code>状态</li><li>第三次握手。作为全双工链路，服务端也需要发送FIN包来关闭自己这方的连接链路。由于ACK已经发送，所以这一次只需要发送FIN序列号。此时，服务端处于<code>LAST_ACK</code>状态。</li><li>第四次握手。客户端现在收到了服务端发送的FIN包，客户端发送ACK表示自己收到了服务端的关闭请求。此时，客户端处于<code>TIME_WAIT</code>状态；而服务端收到客户端ACK包之后，则设置自己状态为<code>CLOSED</code>。客户端的<code>TIME_WAIT</code>状态会停留两倍的MSL时长。</li></ol><blockquote><p>MSL指的是报文段的最大生存时间，如果报文段在网络通信中存活时间超过MSL时间，还没有被接收，那么会被丢弃。关于<code>TIME_WAIT</code>深入学习可以参考文献3</p></blockquote><h4 id="TCP-重传机制"><a href="#TCP-重传机制" class="headerlink" title="TCP 重传机制"></a>TCP 重传机制</h4><blockquote><p>TCP重传机制，是TCP协议保证数据可靠性的一个重要的机制。在网络环境不好的情况下，重传机制可以对上层应用层，屏蔽掉因为各种网络问题导致超时数据丢失而进行重试的策略细节。但是，正式由于屏蔽，导致很多时间排查问题时会忽略掉这点。</p><p>此外，其实在很多系统设计过程中，重传重试相关的需求还是蛮多的。学习TCP重传机制，可以给我们在设计实现自己的应用系统时提供一些借鉴。</p></blockquote><p>TCP重传机制，需要确认什么时候需要重传，以及重传哪些数据包。</p><p>TCP需要重传，肯定是在数据包丢失之后才需要重传，将发送端认为服务端未收到的报文重新发送给接收端。但是，在不可靠的网络环境下，你根本就无法确认数据包是否丢失，通过TCP ACK机制只能确保哪些数据报文被通信对方收到，但是由于接收报文是乱序的，所以当前未收到的报文可能在未来某个时候被ACK回来，也可能就真的被丢失了。</p><p>因此，TCP在发送报文之后，会开启一个定时器，然后如果在计算的超时时间内未收到ACK，则重传。所以，TCP重传机制，有的时候也被称为 TCP超时重传机制。</p><p>超时重传机制，包含两个重要的时间参数。</p><ul><li>往返时间RTT。其是发送端发送TCP包开始计算，到接收到该包ACK数据结束，这期间所消耗的时间。</li><li>超时重传时间RTO。其是，发送端发送TCP包之后，确认包丢失，然后决定重新发送该包的时间。</li></ul><p>显然，我们需要的是RTO时间，根据这个时间我们来确认是否应该超时重传了。但是RTO是动态计算出来的，也就是我们需要根据当前网络状况的不同，计算出RTO时间。因此，就说到了RTT，异常的超时时间，根据正常包往返时间来动态计算，是比较合理的。RTO初始的计算方式，就是取若干次RTT的平均时间，最小200ms，后面随着重传次数的变化，RTO也会调整。</p><blockquote><p>因此，整个流程是这样子的：发送端发送TCP报文，并且启动该报文对应的重传计时器，如果收到了ACK报文，则结束计时器，并且获得最新一次的RTT，计算RTO；如果没有收到ACK报文，并且这时间已经超过当前RTO设置，则重传报文，并且RTO时间倍增。如果，倍增之后，ACK报文还未收到，则继续倍增，直到收到或者到达设置的最大RTO超时时间。</p><p> 在LINUX中，重传此时一般为15次。</p></blockquote><p>此外，还有一种也会触发报文重传。比如，发送端先后发送了A：<code>seq=100,size=100</code>；B：<code>seq=200,size=200</code>；C：<code>seq=400,size=150</code> 三个报文，然后接收方，返回了A’：<code>ack=200</code>；B’=<code>ack=200</code>；C’=<code>ack=200</code>。那么这个时候，就不会等待RTO超时了，而是发送端会认为接收端明显没有收到seq=200的报文，立刻触发<code>快速重传机制</code>，发送丢失的数据报文。</p><h4 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h4><blockquote><p>除了重传机制，TCP另一大亮点，就是滑动窗口。其滑动窗口可以很好的保护系统可靠性，避免大流量数据导致大量传输失败，限制传输速度以及网络带宽和服务器资源的有效利用。在实际应用系统设计中，也可以充分借鉴参考。</p></blockquote><p>TCP 使用接收方接收窗口来控制通信的数据流速率，从而达到拥塞控制，避免通信过程中不必要的丢包处理。</p><p>首先来看下TCP报文头结构：</p><p><img src="/images/2017/tcp_header.gif" alt="Alt text"></p><p>如上图所示，在20字节长的报文头里面，有16bit是接收方用来告诉客户端其可接收数据的大小，发送方根据这个数据，来控制发送给接收方的数据长度。</p><p>看一个简单的例子了解下：</p><p><img src="/images/2017/tcp_window.png" alt="Alt text"></p><p>首先，在和接收端最后一次通信的时候，发送端从TCP报头中获取了剩余窗口为500，表示发送端可以发送500字节的数据给接收方；<br>然后，发送端发送400字节数据，其中seq=1到seq=200之间的数据已经ACK确认，seq=201到seq=400发送出去但是还未被确认。于是，可发送滑动窗口头部从<code>1--&gt;201</code>，尾部从<code>500--&gt;700</code>，如上图(b)；<br>接着发送端收到了接收端seq=201到seq=400的ACK报文，这个时候，滑动窗口继续向后滑动。</p><blockquote><p>需要指出一种特殊的情形，就是当发送端发送数据过快，接收端还未来得及处理时，就会出现接收端返回报头中窗口为0的情形，这就是<code>Zero Window</code>。显然，这种情况，发送端会停止发送数据，知道窗口不为0。然后就有了<code>ZWP</code>技术，当自己的大小不为0，接收端ACK他的窗口大小给发送端 。</p></blockquote><p>但是，基于滑动窗口会出现一个问题，就是当接收端处理速度比较慢，可能每次就只能处理很小字节的报文，然后告诉发送端，其剩余窗口为很小的数字。但是，一个TCP+IP头是40个字节，显然，如果窗口不为0就发送报文给接收端，是不可取的。</p><p>那如何避免在窗口很小的时候，频繁发送小传输报文给接收端呢？在TCP中，称为Silly Window Syndrome(糊涂窗口综合症)。解决方案可以是在特定时刻接收端ACK窗口为0或者发送端累计一部分报文之后在发送给接收端。</p><p>一般，我们在发送端控制比较方便。因此，就出现了<code>Nagle算法</code>。首先引入MSS概念：</p><ul><li>MSS：Maximum Segment Size，也就是最大分段大小。为了达到最佳的传输效能，TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往用MTU（最大数据包大小，以太网的MTU为1500）代替（需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes），所以一般MSS值1460。</li></ul><p>Nagle 算法的规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1]如果包长度达到 MSS ，则允许发送；</span><br><span class="line">[2]如果该包含有 FIN ，则允许发送；</span><br><span class="line">[3]设置了 TCP_NODELAY 选项，则允许发送；</span><br><span class="line">[4]设置 TCP_CORK 选项时，若所有发出去的小数据包（包长度小于 MSS ）均被确认，则允许发送；</span><br><span class="line">[5]上述条件都未满足，但发生了超时（一般为 200ms ），则立即发送。</span><br></pre></td></tr></table></figure><blockquote><p>从上面的规则可以看到，我们再开发应用层代码的时候，如果应用场景需要实时发送各种小报文数据，则需要将Socket的TCP_NODELAY设置为true，否则可能会由于报文太小，而导致数据一直未发送出去。</p></blockquote><p>滑动窗口目前看来，控制发送端发送速率来保护接收端系统是足够了的；但是，滑动窗口，还需要满足解决网络拥塞控制，因此需要更进一步。</p><p>上文介绍过TCP通过采样了RTT时间然后计算出RTO，作为重传超时时间。但是，如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，显然，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，最后，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。</p><p>因此，就出现TCP Reno算法，包含4个部分：</p><ol><li>慢热启动算法 – Slow Start。就是在发送端刚刚接入网络的时候，不会立刻将发送报文量提升到很大的值，而是慢慢试探网络，以每个RTT<code>X2</code>的指数来提速，或者当收到一个ACK则<code>+1</code>提速。在Linux 3.0 中，初始的发送大小为10个MSS。</li><li>拥塞避免算法 – Congestion Avoidance。当指数增长到最大阈值ssthresh=65535，则会对发送速率进行调整ssthresh为当前速率/2。然后回到慢启动过程。此外，很可能在这个时候会出现RTO超时情况，然后进入快速重传。</li><li>快速重传 - Fast Retransimit。调整ssthresh为当前速率/2，并且当前速率也调整为当前速率/2。然后进入拥塞避免阶段。</li><li>快速恢复算法 – Fast Recovery。</li></ol><p>基于以上的算法来调整发送端发送报文的速率，可以很好感知网络当前的负载情况，将网络延时导致重传超时作为一个影响因子，来控制网络拥塞。</p><blockquote><p>其实，在使用很多工具的时候，都会明显感觉到<code>Reno</code>算法的存在。比如在下载文件的时候，下载速度都是逐步增加到一定速率。<br> 关于TCP具体拥塞算法，可以参加文献4</p></blockquote><h4 id="TCP-存活检测"><a href="#TCP-存活检测" class="headerlink" title="TCP 存活检测"></a>TCP 存活检测</h4><blockquote><p>上面讲的东西，都比较理论，应用开发中相对用的比较少。这里，介绍一个在开发应用层网络程序时，需要考虑的知识点。</p></blockquote><p>在前文中说过，TCP由于其内部只是维护了本身的状态表，并不能实时通知当前网络断开的消息。之所以，TCP不去提供这个实时通知网络变化的原因，有2个：</p><ol><li>这样会消耗掉大量的网络带宽，试想若存在着大量的不成熟的网络应用程序，网络带宽一定会消耗殆尽；</li><li>在TCP设计之初，美国国防部设计TCP就是为了让在网络中断的情况下仍然通过其它途径维持通信的能力。<br>不过，在Linux中，提供了<code>KEEP_ALIVE</code>机制去检测TCP的存活状态。</li></ol><p>这种KEEP_ALIVE机制下，TCP会在连接空闲一定时间间隔（一般时间为 7200 s，失败后重试 10 次，每次超时时间 75 s。）后发送一个特殊的段给通信对方，若对方系统依然运行，对应端口对外接收数据，则会响应并发送一个ACK消息。</p><p>KEEP_ALIVE 可以很好的检测连接是否存活。但是在实际应用中，其存在两个问题：</p><ol><li>TCP默认的间隔时间有点过长，在我们日常环境中，使用这种默认时间来检测连接是否存活，是不行的。</li><li>TCP KEEP_ALIVE方式的存活检测，只是针对连接，而不是针对通信双方应用系统的。也就是，即使检测的连接是活跃的，但是可能对应的系统已经100%CPU，无法接收真实的应用处理了。</li></ol><p>因此，一般的应用服务器实现中，都是使用自己的心跳机制来保证应用的存活。</p><blockquote><p>应用心跳存活机制，是由应用定时周期发送心跳包给对方，这里就涉及到频率的问题了。如果时间设置的太长，则起不到实时感知网络是否端口。如果时间太短，则会导致数据量过大，增加网络和接收方负担。<br>此外，在移动智能设备占主导地位的今天，移动网络的不稳定，流量和电量的消耗，都要求心跳频率不能太频繁。</p><p> 因此，在APP端，一般如果应用正在前台使用，则心跳会相对频繁，比如30s一次，如果app被推到后台时，则心跳间隔时间可以调整大点，比如10分钟一次。</p></blockquote><h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>相对于TCP协议，UDP协议非常简单。UDP是面向无连接的，不需要在传送数据之前通过握手协议来建立连接；UDP是不可靠的协议，其不保证数据最后被交付到目的主机，因此也就没有ACK报文来告知发送端发送的数据是否成功。</p><p>此外，UDP如名字那样，面向报文的，也就是UDP包不会进行拆分或合并，没有TCP的拥塞控制和重传机制。重要的一点是，UDP报文头只占用8个字节，而TCP需要占用20个字节。</p><blockquote><p>在TCP中，我们谈到，说TCP的连接其实只是在其双方内存表里面有个一对一连接状态的维护，并不是真的建立了一条链路。而，UDP无连接的，也只是说在UDP中不存在一个一对一连接链路状态的维护，UDP可以通过socket给多个UDP端发送数据，也可以接受多个UDP端发送过来的数据，如果UDP客户端和服务端都只接收和发送该一个socket的数据，那么可以说，其实“虚连接”的。</p><p> 不过需要注意的是，在TCP中，基于这个连接上有一堆的机制和算法来保证连接可靠性，这个是UDP没有的。所以TCP和UDP最大的不同，是一个是可靠的协议，一个是非可靠的。</p></blockquote><p>UDP的不可靠，使得其适应一些特殊的应用场景。</p><ol><li>实时要求高的场景。比如视频通信。在视频直播过程中，用户是可以接受一些帧的数据包的丢失，相对而言，其无法接受一些过时的数据重放，因此业务基于UDP协议进行一些额外补充，满足一些实时性要求高的业务。</li><li>在很早以前，由于国内的网络不是很好，导致TCP协议并不能很好的发挥其稳定性的特性，并且UDP无连接以及报头小等特性，使得服务器可以支持更高的用户量。具体可以参考文献5。</li></ol><blockquote><p>虽然，QQ使用的是UDP通信，TCP一个链路维护其他信息；但是对于现如今，这种设计模式并不一定性价比最高。所以，微信的通信，就是基于TCP来完成的，而不是UDP协议。</p></blockquote><h2 id="Java-Server入门"><a href="#Java-Server入门" class="headerlink" title="Java Server入门"></a>Java Server入门</h2><blockquote><p>基于Java JDK提供的网络API开发简单的服务器是很便捷的，其封装的API接口对于开发者而已，非常易用。</p></blockquote><h3 id="ECHO-服务端"><a href="#ECHO-服务端" class="headerlink" title="ECHO 服务端"></a>ECHO 服务端</h3><p>和其他很多文章介绍网络编程一样，这里我们也首先实现一个echo服务器示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建serverSocket来监听port</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立一个socket连接</span></span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;new connect......&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> (InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 连接成功，返回连接成功消息给客户端</span></span><br><span class="line">                os.write((<span class="string">&quot;SERVER CONN OK!&quot;</span> + <span class="keyword">new</span> Date().toString() + <span class="string">&quot;\n\r&quot;</span>).getBytes(Charset.defaultCharset()));</span><br><span class="line">                os.flush();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">                <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> ((len = is.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 读取数据，将数据打印出来</span></span><br><span class="line">                    System.out.print(<span class="keyword">new</span> String(data, <span class="number">0</span>, len, Charset.defaultCharset()));</span><br><span class="line">                    <span class="comment">// echo反馈给客户端</span></span><br><span class="line">                    os.write(data, <span class="number">0</span>, len);</span><br><span class="line">                    os.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码展示的是一个单线程同步阻塞方式处理网络Socket IO操作的echo服务器版本，所以当客户端连接上服务器之后，其他客户端是不能同时操作网络IO的。</p><p> 此外，需要特别说明在 <code>public ServerSocket(int port, int backlog) throws IOException</code>方法中的backlog，在测试的时候，可以更清楚知道该参数含义：网络连接的等待队列的最大长度。</p></blockquote><p>我们使用 Telnet模拟客户端进行测试，结果如下图所示：</p><p><img src="/images/2017/socket_backlog.png" alt="Alt text"></p><blockquote><p>在代码中，我们将backlog设为1，所以，如上图，当我们1个网络IO操作处理中，1个处在网络连接等待队列中，最后1个网络连接请求由于等待队列已满，从而<code>创建网络连接操作超时</code>而导致最终失败，所以会出现<code>Operation timed out</code>。</p></blockquote><p>因此，我们看出来了这个版本的显著的缺点，就是无法同时处理多个网络请求。</p><h3 id="多线程版本-ECHO服务端"><a href="#多线程版本-ECHO服务端" class="headerlink" title="多线程版本 ECHO服务端"></a>多线程版本 ECHO服务端</h3><p>显然，服务器只能同时处理单个客户端网络请求，肯定是不行的。从代码上分析，程序阻塞的地方，是服务器从socket流中获取数据，然后处理数据返回数据等同步阻塞的IO操作。由于是单线程来处理这些IO操作，所以线程阻塞，就会导致其他网络请求无法响应处理，因此，显然的，就会才有多线程来避免这个问题。</p><blockquote><p>在实现多线程处理请求的时候，一般才有线程池来完成；并且，线程池的大小还需要进行一个限制，避免请求量过大，导致机器资源耗尽不可用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService EXECUTOR_SERVICE = createDefaultExecutorService();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolServer server = <span class="keyword">new</span> ThreadPoolServer();</span><br><span class="line">        server.startServer(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置超时无限大，保证在accept不阻塞</span></span><br><span class="line">            serverSocket.setSoTimeout(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">               <span class="comment">// 读超时设置无限大，保证不会断开client</span></span><br><span class="line">                socket.setSoTimeout(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    EXECUTOR_SERVICE.execute(<span class="keyword">new</span> ProcessorRunnable(socket));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService <span class="title">createDefaultExecutorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Runnable&gt; executorQueue = <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">8</span>, <span class="number">16</span>, <span class="number">60</span>, TimeUnit.SECONDS, executorQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessorRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProcessorRunnable</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> (InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream()) &#123;</span><br><span class="line">                <span class="comment">// 同上文代码示例</span></span><br><span class="line">                processData(is,os);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 处理完成最后，如果socket是打开的，需要进行关闭</span></span><br><span class="line">                <span class="keyword">if</span> (socket != <span class="keyword">null</span> &amp;&amp; socket.isConnected()) &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面示例除了增加多线程支持多客户端同时访问外，实现的时候，对一些实现进行了优化和完善。比如线程池，socket资源关闭，超时设置等。</p></blockquote><h4 id="设置-SO-TIMEOUT参数"><a href="#设置-SO-TIMEOUT参数" class="headerlink" title="设置 SO_TIMEOUT参数"></a>设置 SO_TIMEOUT参数</h4><p><strong>SO_TIMEOUT</strong>是设置socket超时时间的。在server的代码中，ServerSocket.setSoTimeout(int) 和Socket.setSoTimeout(int)是不一样的。在ServerSocket中超时时间指的是accept新连接的超时时间，当服务器等待指定时间还未有新的连接请求过来，则会抛出SocketTimeout异常，并且停止接收新的socket连接请求，但是现有的socket连接读写操作服务器还会继续处理。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.net.SocketTimeoutException: Accept timed out</span><br><span class="line">at java.net.PlainSocketImpl.socketAccept(Native Method)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:<span class="number">409</span>)</span><br><span class="line">at java.net.ServerSocket.implAccept(ServerSocket.java:<span class="number">545</span>)</span><br><span class="line">at java.net.ServerSocket.accept(ServerSocket.java:<span class="number">513</span>)</span><br></pre></td></tr></table></figure><p> 与之不同，Socket的超时时间则是读read超时，当和服务器建立连接的客户端在超时时间内未写入新的数据到服务端，则服务器会抛出SocketTimeout异常，同时断开连接，客户端会出现<code>Connection closed by foreign host</code>类似的错误信息。抛出异常堆栈信息，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.net.SocketTimeoutException: Read timed out</span><br><span class="line">at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">at java.net.SocketInputStream.socketRead(SocketInputStream.java:<span class="number">116</span>)</span><br><span class="line">at java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">171</span>)</span><br><span class="line">at java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">141</span>)</span><br><span class="line">at java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">127</span>)</span><br></pre></td></tr></table></figure><blockquote><p>在很多时候，我们都会给服务器的socket读设置一个超时时间，来避免由于客户端bug而导致一直占用服务器socket连接资源不释放问题，比如我们使用ssh客户端登录线上机器的时候，时间长了就会被断开连接。那如果客户端真的是期望和服务器一直保持连接该怎么办？定时发送心跳来维持连接，所以，我们一般通过修改ssh配置文件定时发送心跳包来保证不被服务器断开连接。</p></blockquote><h4 id="Executor使用说明"><a href="#Executor使用说明" class="headerlink" title="Executor使用说明"></a>Executor使用说明</h4><p>在服务器开发使用多线程模型的时候，服务器在收到客户端请求后，建立好socket连接，然后从线程池中获取一个线程来操作网络流IO。但是，在正常环境下，肯定不能无限的创建线程来支持客户端的请求，这个时候，就需要设置一个最大的线程数来保护服务器。</p><p>此外，当客户端请求处理逻辑发现线程池的初始线程数的线程都被消耗完，则依照线程池逻辑会临时放到Queue中等待线程释放，或者队列满进而在最大线程数之内创建新的线程来支持客户端请求处理。因此，就可能会有IO操作一直等待处理而不反馈给客户端（这种case对于需要及时响应的客户端请求，是很不推荐的，所以在HSF，thrift这些RPC框架中，都采用SynchronousQueue来避免这个问题）。</p><p><strong>SynchronousQueue</strong>是一个阻塞队列，但是这个队列比较特殊，其每一次插入操作都必须等待另外一个线程去获取移除操作，才能结束阻塞返回。SynchronousQueue内部使用<code>TransferQueue</code>/<code>TransferStack</code>来实现，内部逻辑比较复杂，感兴趣的可以去看JDK源码。</p><blockquote><p>SynchronousQueue 其内部只会有一个元素（姑且这么认为，实际上其是不存储元素的）。当队列为空的时候，生产者将队列head指向新创建的node节点，在node上面waiter属性则设置为该生成者占用的线程，并且node的数据类型为DATA，阻塞线程等待消费；然后，需要消费数据的线程检查到head不为null，并且node类型为DATA，则消费该node，并且unpark掉处于阻塞的生成者线程。<br>当SynchronousQueue的head为null时，消费者需要获取node进行消费，则创建一个node节点，设置waiter为消费者线程，类型为REQUEST，将head指向node节点；然后生产者有生产数据的需求时，则unpark掉处于阻塞的消费者线程。</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>TCP 的那些事儿(<a href="http://coolshell.cn/articles/11564.html">http://coolshell.cn/articles/11564.html</a>)</li><li> TCP 为什么是三次握手，为什么不是两次或四次？(<a href="https://www.zhihu.com/question/24853633">https://www.zhihu.com/question/24853633</a>)</li><li> 再叙TIME_WAIT(<a href="https://huoding.com/2013/12/31/316">https://huoding.com/2013/12/31/316</a>)</li><li> 从TCP三次握手说起–浅析TCP协议中的疑难杂症(<a href="http://wetest.qq.com/lab/view/81.html">http://wetest.qq.com/lab/view/81.html</a>)</li><li>QQ 为什么以 UDP 协议为主，以 TCP 协议为辅？ (<a href="https://www.zhihu.com/question/20292749">https://www.zhihu.com/question/20292749</a>)</li><li>微信对网络影响的技术试验及分析(<a href="http://www.52im.net/forum.php?mod=viewthread&tid=195&ctid=10">http://www.52im.net/forum.php?mod=viewthread&amp;tid=195&amp;ctid=10</a>)</li><li>  thrift server整理后的项目源码(<a href="https://github.com/ketao1989/JavaThrift">https://github.com/ketao1989/JavaThrift</a>)</li><li> 关于Java网络API中设置Socket连接超时分析 (<a href="http://cuisuqiang.iteye.com/blog/1725348">http://cuisuqiang.iteye.com/blog/1725348</a>)</li><li> Java 半关闭导致Connect reset异常分析(<a href="http://xiaoz5919.iteye.com/blog/1685138">http://xiaoz5919.iteye.com/blog/1685138</a>)</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> socket </category>
          
          <category> thrift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出RPC原理</title>
      <link href="2016/12/10/2016-12-10-rpc-theory-in-action/"/>
      <url>2016/12/10/2016-12-10-rpc-theory-in-action/</url>
      
        <content type="html"><![CDATA[<blockquote><p>远程过程调用(Remote Procedure Call，简称RPC)，在微服务大行其道的今天，得到了广泛的应用。因此，在分布式系统服务群中开发应用，了解RPC一些原理和实现架构，还是很有必要的。本文，将从大的框架层面来聊聊RPC原理和实现。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>远程过程调用RPC，就是客户端基于某种传输协议通过网络向服务提供端请求服务处理，然后获取返回数据(对于ONE WAY模式则不返还响应结果)；而这种调用对于客户端而言，和调用本地服务一样方便，开发人员不需要了解具体底层网络传输协议。简单讲，就是本地调用的逻辑处理的过程放在的远程的机器上，而不是本地服务代理来处理。</p><p>目前，Java界的RPC中间件百家争鸣，国内开源的就有阿里的Dubbo(当当二次开发的DubboX)，新浪Motan；国外跨语言的有Facebook的Thrift， Google的gRpc等。</p><span id="more"></span><h2 id="LPC-amp-IPC"><a href="#LPC-amp-IPC" class="headerlink" title="LPC &amp; IPC"></a>LPC &amp; IPC</h2><p>既然存在RPC这种远程过程调用，必然会有与之对应的本地过程调用了。本地过程调用在不同的操作系统中，叫法不同，使用方式也不太一样。在Windows编程中，称为LPC；在linux编程中，更习惯称之为IPC，即进程间通信。</p><p>但是，不管如何，其本质上就是本地机器上的不同进程之间通信协作的调用方式。</p><p>服务端开发，一般我们基于Linux，所以这里简单介绍下Linux环境下 IPC实现方式：</p><ul><li>管道</li><li>共享内存</li><li>信号量</li><li>Socket套接字</li></ul><p>除此之外，还有消息队列和信号两种实现进程间通信的方式。</p><p>信号很容易理解，比如我们在控制台输入的<code>CTRL + C</code>来向执行的进程发送kill信号来结束该进程。对于信号，一般我们再终端交互窗口中使用比较多，在服务端开发中很少涉及。</p><p>Linux提供的消息队列和各种分布式MQ不同，它是在内核中使用链表结构来保持消息的队列，然后其他进程从内核的消息队列中获取消息。目前，Linux官方不太推荐使用，将渐渐被淘汰。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道命令，在我们的<code>linux shell</code>中经常使用，一般，我们使用<code>|</code>操作符来保证两个命令之间的数据通信。比如，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java | xargs <span class="built_in">echo</span></span><br></pre></td></tr></table></figure><p>管道命令，其实内部实现就是使用的linux管道接口，每个命令其实是一个进程，各个进程的标准输出STDOUT，作为下一个进程的标准输入STDIN。</p><p>Linux管道包含：匿名管道和命名管道。</p><ul><li>匿名管道：只能父子进程间通信。使用pipe()方法来创建：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedis[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p> 参数filedis返回两个文件描述符：filedes[0]为读而打开，filedes[1]为写而打开。filedes[1]的输出是filedes[0]的输入</p></blockquote></li><li>命名管道：可以在单台机器内的任何一组进程间进行通信。一般我们使用mkfifo()来创建命名管道：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname,<span class="keyword">mode_t</span> mode)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>成功返回0，失败返回-1。成功返回之后，pathname其实就可以看着一个管道文件操作(当然并没有真实文件在磁盘存在)，对于文件操作的方法例如open,read,write都适用于fifo命名通道。</p></blockquote></li></ul><h3 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h3><p>Linux中的信号量和Java中的信号量一样，其主要用处是同步协作。</p><p>信号量其实就是一个比较特殊的变量，然后对它的操作都是原子进行的，并且一般只提供两种方法：P和V操作(在java中为wait()和notify())。</p><ul><li>P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行；</li><li>V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1。</li></ul><p>linux对外提供的API接口方法如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span> &#123;</span></span><br><span class="line">  <span class="keyword">short</span> sempid;<span class="comment">/* pid of last operaton */</span></span><br><span class="line">  ushort semval;<span class="comment">/* current value */</span></span><br><span class="line">  ushort semncnt;<span class="comment">/* num procs awaiting increase in semval */</span></span><br><span class="line">  ushort semzcnt;<span class="comment">/* num procs awaiting semval = 0 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">　　 <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">　　 <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line">　　 <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="comment">//首先获取一个信号量,只有该方法可以才能直接使用key，其他方法必须先semget然后才能使用信号量</span></span><br><span class="line">　　 <span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">//对信号量进行操作，直接控制信号量信息，比如删除信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, <span class="keyword">union</span> semun arg)</span></span>;</span><br><span class="line"><span class="comment">//改变信号量的值，P,V操作都是通过该方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> sem_id, struct sembuf *sem_opa, <span class="keyword">size_t</span> num_sem_ops)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>信号量的主要作用就是同步，所以我们一般是使用共享内存方式完成进程间通信，而在此过程中通过信号量来完成多进程间的同步协调机制。</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>由于同一台机器的硬件设备一般对于同一个系统来说，都是共享的。所以使用内存来完成进程间通信开发的思路，必然是很容易想到的，但是未必容易做到。</p><p>众所周知，进程和线程最大的区别就是一些资源是否隔离。也就是说，不同的进程，其内存资源使用是隔离独立的，每个进程有自己的一套内存地址映射逻辑，也即是系统是无法直接从不同进程的相同虚拟内存地址找到共同的物理内存地址的，这样，就无法像线程一样，简单把数据对象设置为<code>static</code>然后线程间就可以共享获取了。</p><p>因此，Linux对外提供了共享内存的方法来完成进程间通信。</p><p>共享内存是最有效的进程间通信方式。其对外提供的API如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">　   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line">　　 <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建共享内存空间，大小为size</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">//所有需要使用共享内存通信的进程，映射到自身的内存地址空间中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">//从当前进程地址空间中分离该共享内存</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br><span class="line"><span class="comment">//控制共享内存的，比如删除该共享内存空间等</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> command, struct shmid_ds *buf)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>从上面的方法可以很显然的看出，进程间的内存地址空间是独立隔离的(内核地址空间由于虚拟地址和物理地址是一致的，所以在进程间这块地址空间也是一致的，不过我们操作的都是用户空间的内存，所以不考虑这块)。当我们想要共享操作，必须要把物理内存分别绑定到对应进程的地址空间，才能共享操作。</p><p>使用的时候，很简单。<code>shmat</code>方法返回一个<code>void *</code>就可以强转某个指定的struct，然后直接操作该对象结构体即可。由于共享，所以需要考虑多线程同步安全问题。</p></blockquote><h3 id="Socket套接字"><a href="#Socket套接字" class="headerlink" title="Socket套接字"></a>Socket套接字</h3><p>从上面的几个API方法可以看到都是利用单机同用一套资源，然后各自进程的资源之间通过内核方式或者内存方式协作完成单机多进程间通信。</p><p>此外，还有一种方式来完成进程间通信，就是套接字socket。Socket一般情况下是用在不同的两台机器的不同进程之间通信的，当Socket创建时的类型为 <code>AF_LOCAL或AF_UNIX</code>时，则是本地进程通信了(当然你也可以直接使用网络套接字，如果你觉得走下网络更酷，或者以后便于服务分离)。</p><p>关于Socket的API介绍，这里就省略了。服务端/客户端模式的介绍和示例相对很常见，也很容易开发和理解。</p><p>从使用网络套接字Socket来实现进程间通信这个角度来说，其和RPC并没有什么不同了，所以有些文献分类时，说广义来讲RPC也应该包括LPC(IPC),因为从大的来讲，单机进程通信其实算是远程过程调用的一种特殊简化的方式而已。</p><p>当然，本文还是觉得还是区别开比较通用，也便于理解。</p><blockquote><p>如在Socket介绍的那样，本地过程调用很多情况下都是依赖操作系统对外提供的API来协调操作某个共享资源来完成进程间的数据交换。</p><p>如果不依赖单机共享资源，就只有Socket接口。因此，如果要扩展到分布式环境下的进程间通信，那就只能使用网络套接字来完成。</p></blockquote><p>说完单机的服务调用，在互联网时代，自然要讲web服务(Web Service)了。</p><h2 id="Web-Service技术"><a href="#Web-Service技术" class="headerlink" title="Web Service技术"></a>Web Service技术</h2><blockquote><p><code>Web Service</code>一般有两种定义：</p><ol><li>特指 W3C组织制定的<code>web service</code>规范技术。其包括SOAP(一个基于XML的可扩展消息信封格式，需同时绑定一个网络传输协议。这个协议通常是HTTP或HTTPS，但也可能是SMTP或XMPP)、WSDL(一个XML格式文档，用以描述服务端口访问方式和使用协议的细节。通常用来辅助生成服务器和客户端代码及配置信息)和UDDI(一个用来发布和搜索WEB服务的协议，应用程序可借由此协议在设计或运行时找到目标WEB服务)。从上面三个定义就可以看出，这种规范技术是一个重量级的协议。</li><li>泛指网络系统对外提供web服务所使用的技术。这里，我们主要是基于该定义来理解。</li></ol></blockquote><p>一般而言，技术体系，必然是服务于架构体系的。不同的架构，所约定的技术结构设计还是有些区别的。</p><p>因此，要了解web服务技术，必然要先了解其服务于哪个架构体系；也就是说，先去了解技术产生的架构背景。</p><h3 id="SOA-amp-微服务"><a href="#SOA-amp-微服务" class="headerlink" title="SOA &amp; 微服务"></a>SOA &amp; 微服务</h3><p>在分布式网络服务架构体系中，最火的莫过于 SOA(面向服务架构，Service-Oriented Architecture)和微服务。</p><p>嗯，一般将服务化架构，必然会扯到<code>全家桶</code>设计升级的故事。</p><p>简化版是这样子的：</p><ul><li><p>在很久很久以前，网络应用也是单机部署的，所有的业务代码全部都在一个大项目内，然后更改一个逻辑就需要重启部署应用，停止对外服务。</p></li><li><p>然后，这样子肯定不行的，就有了多机部署，通过Nginx或者其他代理/均衡软件来分发请求到相同服务的不同机器上，当其中一台机器停机部署时，请求全部打到其他机器上去。但是这个时候，所有机器上的代码还是一套。</p></li><li><p>后来，机器不断升级，但是业务不断变多，项目代码越来越大，更改一个地方编译打包部署时间非常长，于是，我们就把一些独立隔离开的业务代码分成多个项目。但是，实现业务逻辑的时候，必然有一些功能和数据是多个业务都会用到的，简单以前的代码copy过来，数据就直接操作数据库。但是，当有个公用的功能需要更改时，就发现所有相关业务都需要更改，并且数据库上的操作，还会带来其他同步兼容等等问题。</p></li><li><p>于是，就出现了SOA，也就是基于服务的架构设计理念。SOA的设计理念，就是把所有的服务都对外以HTTP或者其他协议方式对外暴露，绝对<code>不允许</code>相同的服务在不同的业务系统独立一套，然后共用底层数据库。服务化的设计系统，所有拆分的业务，彼此之间都通过暴露的服务接口通信，操作对方的数据。这样，各个业务系统之间开始独立自主的向着美好的方向发展了。</p></li><li><p>再后来，单个业务发展的越来越好，提供的功能也越来越多，这样一个业务系统的代码也变得很大了，开发人员也越来越多。于是乎，单个业务系统内部就存在问题了，当然，我们也可以拆分成不同的业务系统来开发发展。但是，单个业务系统，很多的公用逻辑都是一些业务细节，并不好独立成业务系统；此外，单个业务系统开发人员都很容易交流，因此，对于内部业务系统的架构设计，就出现了<code>微服务Micro-Service</code>了。我们把单个业务系统中一些功能细节的结构封装成服务，大的对外业务系统，组装各个微服务的接口数据，然后提供SOA服务。</p></li></ul><p>因此，SOA其实和微服务，从我的视角来看，其实就是 业务外部和内部服务的不同架构设计而已，其技术框架很大程度上都可以通用。其区别如下图：</p><p><img src="/images/2016/12/soa_ms.jpg" alt="SOA和微服务"></p><p>从上面发展历程可以看到，SOA一般使用SOAP或者REST方式来提供服务，这样外部业务系统可以使用通用网络协议来处理请求和响应，而微服务，还可以有一些私有的协议方式来提供服务，例如基于自定义协议的RPC框架。RPC使得调用服务简单，但是需要一些其他耗时间的交流协调工作，这适合微服务的场景，但是不一定适合SOA场景了。</p><h3 id="web服务技术结构"><a href="#web服务技术结构" class="headerlink" title="web服务技术结构"></a>web服务技术结构</h3><p>先给出一个web服务的技术体系结构图：</p><p><img src="/images/2016/12/web_service.png" alt="web服务技术体系"></p><p><code>web service</code>被W3C设立规范之初，SOAP方案就被提出来。但是，随着服务化技术和架构的发展，SOAP多少有点过于复杂，因此就出现了简化版的REST方案。此后，由于分布式服务应用越来越大，对性能和易用性上面要求越来越大，因此就出现了RPC框架(很多时候，RPC并不被当做一种web service方案。在绝大部分博客中，介绍web service 只会讨论 SOAP和REST，主要是其基本上都是基于SOA来介绍服务方案)。</p><h4 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h4><p>SOAP，全称为 Simple Object Access Protocol，也就是 简单对象访问协议。跟着<code>web service</code>一起出来的，说明历史悠久，不过感觉现在也慢慢要淘汰了。</p><p>SOAP，是基于XML数据格式来交换数据的；其内部定义了一套复杂完善的XML标签，标签中包含了调用的远程过程、参数、返回值和出错信息等等，通信双方根据这套标签来解析数据或者请求服务。与SOAP相关的配套协议是WSDL (Web Service Description Language)，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，类似我们现在聊服务治理中的服务发现功能。</p><p>因此，SOAP服务整体流程是：首先，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。</p><h4 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h4><p>REST，全称 REpresentational State Transfort，也就是 表示性状态转移。由于SOAP方案过于庞大复杂，在很多简单的web服务应用场景中，轻量级的REST就出现替代SOAP方案了。</p><p>和SOAP相比，REST只是对URI做了一些规范，数据才有JSON格式，底层传输使用HTTP/HTTPS来通信，因此，所有web服务器都可以快速支持该方案；开发人员也可以快速学习和使用。</p><h4 id="SOAP-amp-REST"><a href="#SOAP-amp-REST" class="headerlink" title="SOAP &amp; REST"></a>SOAP &amp; REST</h4><p>从命名来看，SOAP是一种协议，而REST只是一种方案。协议的设计很多时候，从上而下一整套都是新的，需要设计开发专门的工具支持；而方案相对就是基于目前以后的工具来做一些设计和约束，这就是为什么REST快速替换了SOAP的地位。</p><p>REST特点：</p><ul><li>由于数据返回格式是自定义的，绝大部分使用JSON，这种数据结构节省带宽，并且前端JavaScript能天生支持。</li><li>无状态，基于HTTP协议，所以只能适应无状态场景。</li></ul><p>SOAP特点：</p><ul><li>协议有安全性的一些规范。</li><li>基于xml的标签约束，而且也不要去底层是HTTP传输，所以支持有状态的场景。</li></ul><h3 id="RPC家族"><a href="#RPC家族" class="headerlink" title="RPC家族"></a>RPC家族</h3><p>RPC家族中，RMI是Java制定的远程通信协议。而后，基本上RPC框架都或多或少有RMI的影子(当然，其实主要是RPC本身的实现方式就是这样子了-_-)。RMI既然是Java的标准RPC组件，那必然其他编程语言就无法使用了；因此，Thrift这种基于IDL来跨语言的RPC组件就出现了。Thrift的使用者，只需要按照Thrift官方规定的方式来写API结构，然后生成对应语言的API接口，继而就可以跨语言完成远程过程调用了。但是，作为服务化的组件，如果没有服务治理来完成大规模应用集群中服务调用管理工作，则运维工作则是非常繁重的，因此类似dubbo这种包含服务治理的RPC组件出现了。</p><p>下面，就来介绍RPC组件。</p><h2 id="RPC介绍"><a href="#RPC介绍" class="headerlink" title="RPC介绍"></a>RPC介绍</h2><blockquote><p>RMI作为Java自带的官方RPC组件，单独介绍；然后我们来看看通用RPC实现结构。</p></blockquote><h3 id="RMI介绍"><a href="#RMI介绍" class="headerlink" title="RMI介绍"></a>RMI介绍</h3><p>RMI，全称是Remote Method Invocation，也就是远程方法调用。在JDK 1.2的时候，引入到Java体系的。当应用比较小，性能要求不高的情况下，使用RMI还是挺方便快捷的。</p><p>下面先看看RMI的调用流程。</p><p><img src="/images/2016/12/rmi.png" alt="RMI服务调用流程"></p><p>其中，有些概念需要说明：</p><blockquote><p>stub(桩)：stub实际上就是远程过程在客户端上面的一个代理proxy。当我们的客户端代码调用API接口提供的方法的时候，RMI生成的stub代码块会将请求数据序列化，交给远程服务端处理，然后将结果反序列化之后返回给客户端的代码。这些处理过程，对于客户端来说，基本是透明无感知的。</p><p>remote：这层就是底层网络处理了，RMI对用户来说，屏蔽了这层细节。stub通过remote来和远程服务端进行通信。</p><p>skeleton(骨架)：和stub相似，skeleton则是服务端生成的一个代理proxy。当客户端通过stub发送请求到服务端，则交给skeleton来处理，其会根据指定的服务方法来反序列化请求，然后调用具体方法执行，最后将结果返回给客户端。</p><p>registry(服务发现)：rmi服务，在服务端实现之后需要注册到rmi server上，然后客户端从指定的rmi地址上lookup服务，调用该服务对应的方法即可完成远程方法调用。registry是个很重要的功能，当服务端开发完服务之后，要对外暴露，如果没有服务注册，则客户端是无从调用的，即使服务端的服务就在那里。</p></blockquote><p>下面给出一个简单的Java示例来show code下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口必须继承RMI的Remote</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RmiService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须有RemoteException，才是RMI方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UnicastRemoteObject会生成一个代理proxy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmiServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">RmiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RmiServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端server启动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmiServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RmiService service = <span class="keyword">new</span> RmiServiceImpl();</span><br><span class="line">            <span class="comment">//在本地创建和暴露一个注册服务实例，端口为9999</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">//注册service服务到上面创建的注册实例上</span></span><br><span class="line">            Naming.rebind(<span class="string">&quot;rmi://127.0.0.1:9999/service1&quot;</span>,service);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------server start-----------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端调用rmi服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmiClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据注册的服务地址来查找服务，然后就可以调用API对应的方法了</span></span><br><span class="line">            RmiService service = (RmiService)Naming.lookup(<span class="string">&quot;rmi://localhost:9999/service1&quot;</span>);</span><br><span class="line">            System.out.println(service.hello(<span class="string">&quot;RMI&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上面一些核心的代码已经在注释中给了说明。</p></blockquote><h3 id="通用RPC架构"><a href="#通用RPC架构" class="headerlink" title="通用RPC架构"></a>通用RPC架构</h3><p>一般，远程过程调用RPC就是本地动态代理隐藏通信细节，通过组件序列化请求，走网络到服务端，执行真正的服务代码，然后将结果返回给客户端，反序列化数据给调用方法的过程。</p><p>RPC具体调用流程如下所示：<br><img src="/images/2016/12/rpc.png" alt="RPC调用流程"></p><p>通用的RPC组件一般包括以下一些模块：</p><blockquote><ol><li><p>serviceClient：这个模块主要是封装服务端对外提供的API，让客户端像使用本地API接口一样调用远程服务。一般，我们使用动态代理机制，当客户端调用api的方法时，serviceClient会走代理逻辑，去远程服务器请求真正的执行方法，然后将响应结果作为本地的api方法执行结果返回给客户端应用。类似RMI的stub模块。</p></li><li><p>processor：在服务端存在很多方法，当客户端请求过来，服务端需要定位到具体对象的具体方法，然后执行该方法，这个功能就由processor模块来完成。一般这个操作需要使用反射机制来获取用来执行真实处理逻辑的方法，当然，有的RPC直接在server初始化的时候，将一定规则写进Map映射中，这样直接获取对象即可。类似RMI的skeleton模块。</p></li><li><p>protocol：协议层，这是每个RPC组件的核心技术所在。一般，协议层包括编码/解码，或者说序列化和反序列化工作；当然，有的时候编解码不仅仅是对象序列化的工作，还有一些通信相关的字节流的额外解析部分。序列化工具有：hessian，protobuf，avro,thrift，json系，xml系等等。在RMI中这块是直接使用JDK自身的序列化组件。</p></li><li><p>transport：传输层，主要是服务端和客户端网络通信相关的功能。这里和下面的IO层区分开，主要是因为传输层处理server/client的网络通信交互，而不涉及具体底层处理连接请求和响应相关的逻辑。</p></li><li><p>I/O：这个模块主要是为了提高性能可能采用不同的IO模型和线程模型，当然，一般我们可能和上面的transport层联系的比较紧密，统一称为remote模块。</p></li></ol></blockquote><p>此外，还有业务代码自己去实现的client和server层。client当需要远程调用服务时，会首先初始化一个API接口代理对象，然后调用某个代理方法。server在对外暴露服务时，需要首先实现对应API接口内部的方法，当请求过来时，通过反射找到对应的实例对象，执行对应的业务代码。</p><h3 id="简单RPC组件实现"><a href="#简单RPC组件实现" class="headerlink" title="简单RPC组件实现"></a>简单RPC组件实现</h3><p>介绍完RPC相关结构和概念之后，给一个简单的RPC组件示例来对各个模块进行code级别的说明。</p><blockquote><p>以下代码仅仅是了解RPC各个模块功能的示例，对性能和异常等情况未考虑全面，生产环境不适用。</p></blockquote><h4 id="protocol模块代码"><a href="#protocol模块代码" class="headerlink" title="protocol模块代码"></a>protocol模块代码</h4><blockquote><p>协议层主要包括编解码和序列化部分。编解码就是我们对传输通信的远程调用请求接口和方法参数等数据按照我们规定的格式进行组装编码，然后在接收的一方负责把数据解码成原始的对象，然后找到需要执行的接口和方法。序列化/反序列化，则是将数据对象，按照一定的映射关系转换成字节流，供网络传输，接收的一方首先将流映射为对象数据。</p><p>有的时候，序列化/反序列化组件会包含编解码部分。此外，编解码和序列化工作先后关系也不一定。一般高性能RPC，序列化工具十分强大和通用，所以编解码部分会放在序列化之后，主要是解码的时候，可以不完成反序列化就对流进行一些处理工作，比如映射、分发等。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 很明显，这里使用JSON来序列化和反序列化RPC调用传递的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ServiceProtocol protocol = <span class="keyword">new</span> ServiceProtocol();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将对象序列化为字符串字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encode(Object o) &#123;</span><br><span class="line">        <span class="keyword">return</span> JsonUtils.encode(o).getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化成字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">decode</span><span class="params">(<span class="keyword">byte</span>[] data, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JsonUtils.decode(<span class="keyword">new</span> String(data), clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编解码模型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolModel</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String clazz;</span><br><span class="line">        <span class="keyword">private</span> String method;</span><br><span class="line">        <span class="keyword">private</span> String[] argTypes;</span><br><span class="line">        <span class="keyword">private</span> Object[] args;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// setter getter方法省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例中的代码使用JSON来序列化/反序列化工作。由于JSON序列化组件比较弱，所以这边需要将执行调用方法相关的请求数据进行编码成<code>ProtocolModel</code>对象。</p><h4 id="remote模块代码"><a href="#remote模块代码" class="headerlink" title="remote模块代码"></a>remote模块代码</h4><blockquote><p>remote模块是提供服务端和客户端通信的功能。因此，在服务端需要起一个端口来监听外部的请求，在客户端则负责发送请求，接收响应数据。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端通信组件，客户端和外部服务端数据交互时使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientRemoter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ClientRemoter client = <span class="keyword">new</span> ClientRemoter();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">byte</span>[] getDataRemote(<span class="keyword">byte</span>[] requestData) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket()) &#123;</span><br><span class="line">             socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">             socket.getOutputStream().write(requestData);</span><br><span class="line">             socket.getOutputStream().flush();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10240</span>];</span><br><span class="line">             <span class="keyword">int</span> len = socket.getInputStream().read(data);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> Arrays.copyOfRange(data, <span class="number">0</span>, len);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端起一个端口监听服务，绑定到相关processor处理器上。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerRemoter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executor =</span><br><span class="line">        Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ServerSocket server = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------start server----------------&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> Socket socket = server.accept();</span><br><span class="line">                executor.execute(<span class="keyword">new</span> MyRunnable(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            server.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> (InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10240</span>];</span><br><span class="line">                <span class="keyword">int</span> len = is.read(data);</span><br><span class="line"></span><br><span class="line">                ServiceProtocol.ProtocolModel model = ServiceProtocol.protocol</span><br><span class="line">                    .decode(Arrays.copyOfRange(data, <span class="number">0</span>, len), ServiceProtocol.ProtocolModel.class);</span><br><span class="line">                Object object = ServiceProcessor.processor.process(model);</span><br><span class="line">                os.write(ServiceProtocol.protocol.encode(object));</span><br><span class="line">                os.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// close socket...</span></span><br><span class="line">           &#125;        &#125;    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>简单处理，直接让网络一次获取所有的数据，假设一次请求和响应的数据大小小于10K。</p><p>在server端的remote中，启动服务之前是需要绑定对外提供的服务的，也就是服务server启动，其内部需要指定序列化、服务处理器等逻辑。</p></blockquote><p>通用RPC的通信层，是非常复杂的，其需要考虑各种网络环境导致的数据半包，分包和粘包情况，需要考虑高性能NIO组件，多线程处理超时，连接复用等等。</p><h4 id="processor模块代码"><a href="#processor模块代码" class="headerlink" title="processor模块代码"></a>processor模块代码</h4><blockquote><p>服务端接口方法定位处理器。作为一个组件，显然不应该在业务代码中嵌入一些非业务逻辑。processor会根据序列化完了之后的请求数据来定位具体的处理逻辑，然后调用对应的业务代码来处理获取返回结果。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ServiceProcessor processor = <span class="keyword">new</span> ServiceProcessor();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Object&gt; PROCESSOR_INSTANCE_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">publish</span><span class="params">(Class clazz, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PROCESSOR_INSTANCE_MAP.putIfAbsent(clazz.getName(), obj) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(ServiceProtocol.ProtocolModel model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(model.getClazz());</span><br><span class="line"></span><br><span class="line">            Class[] types = <span class="keyword">new</span> Class[model.getArgTypes().length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">                types[i] = Class.forName(model.getArgTypes()[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Method method = clazz.getMethod(model.getMethod(), types);</span><br><span class="line"></span><br><span class="line">            Object obj = PROCESSOR_INSTANCE_MAP.get(model.getClazz());</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> method.invoke(obj, model.getArgs());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>PROCESSOR_INSTANCE_MAP publish这个逻辑，在Spring环境中，一般通过xml配置自动注入进来，然后从context中获取对应的实例。但是，不管怎样，底层其实都是一个map来维护映射关系。</p></blockquote><p>如上文介绍的那样，经过解码获取到的调用对象，然后通过java反射机制，执行指定的方法获取结果。</p><h4 id="serviceClient模块代码"><a href="#serviceClient模块代码" class="headerlink" title="serviceClient模块代码"></a>serviceClient模块代码</h4><blockquote><p>其实，这块叫做serviceProxyClient比较直接点。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProxyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class[] &#123;clazz&#125;, <span class="keyword">new</span> ServiceProxy(clazz));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Class clazz;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceProxy</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">            ServiceProtocol.ProtocolModel model = <span class="keyword">new</span> ServiceProtocol.ProtocolModel();</span><br><span class="line">            model.setClazz(clazz.getName());</span><br><span class="line">            model.setMethod(method.getName());</span><br><span class="line">            model.setArgs(args);</span><br><span class="line"></span><br><span class="line">            String[] argType = <span class="keyword">new</span> String[method.getParameterTypes().length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argType.length; i++) &#123;</span><br><span class="line">                argType[i] = method.getParameterTypes()[i].getName();</span><br><span class="line">            &#125;</span><br><span class="line">            model.setArgTypes(argType);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] req = ServiceProtocol.protocol.encode(model);</span><br><span class="line">            <span class="keyword">byte</span>[] rsp = ClientRemoter.client.getDataRemote(req);</span><br><span class="line">            <span class="keyword">return</span> ServiceProtocol.protocol.decode(rsp, method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ProxyClient</code>就是对客户端调用API时透明化底层序列化和网络操作相关细节。所以，在proxyClient内部，我们可以看到它封装代理了这块调用逻辑，业务代码直接使用<code>getInstance</code>方法就可以获取对象实例，然后按照正常使用api方法来执行调用逻辑，获取结果。</p><blockquote><p>如果使用spring框架的话，可以进一步封装成一个bean，然后客户端业务代码只需要在xml中配置一下，就可以通过注解annotation等方式注入进来。</p></blockquote><h4 id="server业务接口实现代码"><a href="#server业务接口实现代码" class="headerlink" title="server业务接口实现代码"></a>server业务接口实现代码</h4><blockquote><p>这里给出接口对外发布和测试</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHi</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServiceImpl</span> <span class="keyword">implements</span> <span class="title">RpcService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端测试main执行代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布接口</span></span><br><span class="line">        ServiceProcessor.processor.publish(RpcService.class,<span class="keyword">new</span> RpcServiceImpl());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动server</span></span><br><span class="line">        ServerRemoter remoter = <span class="keyword">new</span> ServerRemoter();</span><br><span class="line">        remoter.startServer(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如上，我们构造了一个<code>RpcService</code>接口对外提供sayHi的服务。在main方法中，我们首先需要对外发布这个接口和对应的实现类对象。在一些框架中，这些对外暴露的接口，都是通过xml配置或者annotation来发布的。然后，我们就可以启动server服务，对外提供RPC服务。</p></blockquote><h4 id="6-client调用测试代码"><a href="#6-client调用测试代码" class="headerlink" title="6.  client调用测试代码"></a>6.  client调用测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------start invoke----------------&quot;</span>);</span><br><span class="line">        RpcService service = ServiceProxyClient.getInstance(RpcService.class);</span><br><span class="line">        System.out.println(service.sayHi(<span class="string">&quot;RPC World&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;----------end invoke----------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>看我们的测试代码非常简单，当要远程调用某个接口方法时，只需要getInstance该接口类代理对象，然后就像调用本地方法一直执行方法执行和结果处理。</p></blockquote><h2 id="RPC技术深入"><a href="#RPC技术深入" class="headerlink" title="RPC技术深入"></a>RPC技术深入</h2><p>上文简单的介绍了RPC模块各个部分，并且实现了一个简单的RPC组件。这一部分，我们要介绍在生产环节下RPC需要使用的一些技术点。</p><h3 id="RPC序列化"><a href="#RPC序列化" class="headerlink" title="RPC序列化"></a>RPC序列化</h3><blockquote><p>将RPC序列化和编解码分开，是因为个人觉得，虽然在很多时候，编解码其实就是序列化操作，但是有的时候，我们会自定义一些数据结构来封装业务数据对象，然后再序列化成二进制流。此外，在协议层，我们可能也会对普通序列化完了之后，还会对传输头进行编码工作。因此，为了更好的说明，这里分开来。</p></blockquote><p>序列化，说的简单，就是将对象转换成二进制流，也就是<code>byte[]</code>，而反序列化就是讲二进制流转换成对象。使用序列化/反序列化，主要是我们想把内存对象数据，持久化到文件fd或者通过网络传输到其他地方，而这只能使用二进制流来呈现。此外，由于RPC是通过网络通信的，所以序列化工具的性能和二进制流的大小，都是直接影响整体处理能力的关键因素。</p><p>目前基于Java的序列化工具，主要有：</p><ul><li>JDK Serializable工具</li><li>Hessian工具</li><li>Kryo工具</li><li>JSON工具</li></ul><h4 id="JDK内置序列化工具"><a href="#JDK内置序列化工具" class="headerlink" title="JDK内置序列化工具"></a>JDK内置序列化工具</h4><p>JDK自带的序列化工作不需要引入任何第三方包就可以直接使用，我们仅仅只需要实现<code>java.io.Serializable</code>接口。然后，我们在需要序列化/反序列化的时候，直接使用<code>ObjectInputStream</code>/<code>ObjectOutStream</code>来readObject将流反序列化成对象或者writeObject将对象序列化成流。</p><p>很多时候，我们并不使用原生的JDK序列化工具进行序列化，主要原因是因为其序列化后的二进制流太大，并且序列化耗时也比较长。但是，其最大的优点就是原生支持，快速使用，引入成本低，此外，其支持java所有类型，所以在有些RPC组件中，其作为默认序列化工具。</p><blockquote><p>使用JDK自带的序列化工具，尤其需要注意<code>serialVersionUID</code>这个静态变量，在反序列化的时候，会根据这个变量来判断两个类是否一样，如果修改了该变量，那么将无法兼容来的二进制数据的反序列化操作。</p><p>此外，你可以通过在类中增加writeObject 和 readObject 方法可以实现自定义序列化。</p></blockquote><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkSerialiable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">(Blog blog)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        os.writeObject(blog);</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray()));</span><br><span class="line">        Blog blog1 = (Blog) is.readObject();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(blog1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hessian工具"><a href="#Hessian工具" class="headerlink" title="Hessian工具"></a>Hessian工具</h4><p>Hessian,其实是一个开源的轻量级RPC组件。从上面分析RPC通用结构，可以看到很多RPC为了性能会自己实现序列化/反序列化工具，比如Thrift，而hessian也是如此。hessian2的性能相对JDK来说，提高了很多，而且序列化完了之后的流也小了很多。由于hessian已经生产实践了很长时间，所以其还是很值得使用的。</p><p>hessian在处理序列化的时候，会根据对象的数据类型采用不同的序列化策略，比如有些直接使用JavaSerializer，有些事自己来实现对应类型的序列化方法，其实就是如上面所介绍的那样，实现对应类型的<code>writeObject</code>和<code>readObject</code>方法。</p><p>我们只是使用hessian工具来完成序列化和反序列化工作，如果你需要自己实现一个自定义序列化工具，那么可以参考hessian的实现方式。</p><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HessianSerialibale</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">(Blog blog)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        Hessian2Output os = <span class="keyword">new</span> Hessian2Output(baos);</span><br><span class="line">        os.writeObject(blog);</span><br><span class="line">        os.close();</span><br><span class="line">        Hessian2Input is = <span class="keyword">new</span> Hessian2Input(<span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray()));</span><br><span class="line">        Blog blog1 = (Blog) is.readObject();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(blog1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>尤其需要说明，在上面的测试代码中，如果不将os close掉，则一直会报错，告诉<code>java.io.EOFException: readObject: unexpected end of file</code>.</p><p>此外，处理性能上的优势，hessian还可以在<code>serialVersionUID</code>被后期更改的时候，反序列化也没有问题。这是因为，hessian不依赖UID来匹配类型，而且hessian在序列化完了之后的二进制流里面，会保留每个field对应的一些属性信息，虽然这些信息会增加一点流大小，但是对反序列化工作很有帮助。</p></blockquote><h4 id="Kryo工具"><a href="#Kryo工具" class="headerlink" title="Kryo工具"></a>Kryo工具</h4><blockquote><p>关于Kryo的性能对比，可以参考<a href="http://developer.51cto.com/art/201506/480273.htm">各种 Java 的序列化库的性能比较测试结果</a>。</p></blockquote><p>Kryo是一个快速高效的Java对象序列化框架，其在java的序列化上的性能指标甚至优于google著名的序列化框架protobuf，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。总之，Kryo性能非常霸道。</p><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoSerializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">(Blog blog)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        Output output = <span class="keyword">new</span> Output(baos);</span><br><span class="line">        kryo.writeClassAndObject(output, blog);</span><br><span class="line">        output.close();</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        Input input = <span class="keyword">new</span> Input(bais);</span><br><span class="line">        Blog blog1 = (Blog) kryo.readClassAndObject(input);</span><br><span class="line">        input.close();</span><br><span class="line">        System.out.println(blog1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于Kryo工具生成的字节码中是不包含field元数据信息的，这样的话，在兼容性上就很难处理了。比如我现在对一个对象增加一个字段属性，但是这样子的话，老的所有序列化二进制流就无法被正常反序列化成对象了。在很多场景下，这都是无法容忍的。</p></blockquote><h4 id="JSON工具"><a href="#JSON工具" class="headerlink" title="JSON工具"></a>JSON工具</h4><blockquote><p>JSON工具进行序列化和反序列化在上文已经进行了说明，并且RPC示例代码就是使用这种方式。其性能上跟hessian差不多，并且反序列化兼容会很，但是其有个比较大的缺点，就是很多类型，可能JSON工具无法支持，并且其是基于String然后再转成二进制流的，所以流的大小，可能并没有想象的那么好。</p></blockquote><h3 id="RPC协议编解码"><a href="#RPC协议编解码" class="headerlink" title="RPC协议编解码"></a>RPC协议编解码</h3><blockquote><p>除了序列化，在编码的上/下游还需要对二进制流或者对象做一些额外的处理，而这些处理本身和二进制流化没有太大关系。</p></blockquote><p>比如dubbo给出的处理流程，可以清晰的看出序列化和编码之间的区别(个人觉得广义的编码应该包括序列化那部分)如下：</p><p><img src="/images/2016/12/dubbo_codec.png" alt="dubbo线程处理流程"></p><p>每个RPC组件，基本上都是直接基于Socket来开发通信层功能，但是在网络传输的数据由于网络链路和协议的问题，会出现半包，分包和粘包情况。这样就需要设计编解码协议头来解码网络流，如上dubbo视图。</p><p>下面我们来看下dubbo的协议编码格式(具体参考：<a href="http://dubbo.io/Developer+Guide-zh.htm#DeveloperGuide-zh-%E8%BF%9C%E7%A8%8B%E9%80%9A%E8%AE%AF%E7%BB%86%E8%8A%82">远程通讯细节</a>)：</p><p><img src="/images/2016/12/dubbo_protocol.png" alt="dubbo协议头"></p><p>Dubbo协议头分析：</p><blockquote><p>协议头固定长度<code>16</code>个字节，也就是128位。这样，当我们解码流的时候，会首先提取前16byte来解析。</p><p>先来看看MAGIC设计：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// magic header.</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span>    MAGIC              = (<span class="keyword">short</span>) <span class="number">0xdabb</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>     MAGIC_HIGH         = Bytes.short2bytes(MAGIC)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>     MAGIC_LOW          = Bytes.short2bytes(MAGIC)[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><blockquote><p><code>SerializationID</code>表示序列化类型ID，Dubbo支持多种序列化工具，比如hessian，jdk，fastjson等，所以需要在协议头里面指定序列化方式，这样在解码完了之后才能知道内容使用哪种工具反序列化。</p><p><code>event</code>表示事件，比如这个请求是<code>heartbeat</code>。<code>two way</code>表示请求是否是需要交互返回数据的请求。<code>req/res</code>表示该数据是请求还是响应。<code>status</code>表示状态位，当响应数据的时候，根据该字段判断是否成功。</p><p><code>id</code>表示请求id。这个ID真的真的很重要！！！这个id是请求客户端生成的唯一id，保证在服务运行期内id不会重复。此外，在阿里内部的RPC组件HSF最开始是将id放在data数据内，这样只有在反序列化的时候，才能拿到ReqId，但是有些时候ReqId对应的RPC请求可能由于超时或者已经被处理，导致客户端对于这种case直接丢弃就可以。因此，将id放在head里面，则直接解码的时候就可以拿到ReqId去check，而不需要额外反序列化工作。</p><p><code>data length</code>则表示正文内容的长度。解码是通过该字段来判断消息正文字节流的整个完整包，这样反序列化就可以进行正确的转换对象了。</p></blockquote><h3 id="RPC路由和负载均衡"><a href="#RPC路由和负载均衡" class="headerlink" title="RPC路由和负载均衡"></a>RPC路由和负载均衡</h3><blockquote><p>路由策略，是完成单个机器对于服务方调用链路的选择策略,然后把客户端的服务请求传输到具体的某台服务端的机器上。负载均衡是完成路由的一种实现方式，其将前端请求根据一定算法策略来分发到不同机器上，使得集群中机器资源得到充分均衡的利用，此外还可以将不可用机器剔出请求列表。但是，显然路由除了负载均衡之外，还有其他方式。</p><p>我们知道，现在的服务后台都是多台机器部署的服务集群，在这些集群在请求的入口，一般会有负责负载均衡的机器部署，来完成请求的合理分发。RPC的结构也是客户端和服务端模式，但是其结构中我们发现是没有中间代理server层的，所以对于客户端在集群中的远程服务调用，就需要客户端自己来完成负载均衡的逻辑了。</p><p>除负载均衡之外，我们还会存在其他路由加强方式。比如，我们有多个机房都部署服务的时候，我需要优先选择同机房内的服务调用。</p></blockquote><p>一般定义类似如下的接口，然后根据自己的需求实现自己的负载均衡/路由策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILoadBalanceStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从众多连接池子中选择其中一个池子.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokeConns 客户端维持的和各个服务端维持的连接池对象列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation 本次客户端调用服务端相关的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回和其中一个服务端维持链接的连接池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InvokeConn <span class="title">select</span><span class="params">(List&lt;InvokeConn&gt; invokeConns, Invocation invocation)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般RPC组件中，会实现两个通用的负载均衡策略。随机和轮询。具体实现可以参考：<a href="https://github.com/ketao1989/ourea/tree/master/ourea-core/src/main/java/com/taocoder/ourea/core/loadbalance">https://github.com/ketao1989/ourea/tree/master/ourea-core/src/main/java/com/taocoder/ourea/core/loadbalance</a></p></blockquote><p><em>再谈谈维护可用服务列表：</em></p><p>一般我们会在客户端和服务端之间维持长连接，然后通过心跳机制来确保服务端是否在线提供服务。此外，对一些没有维护长连接或者可选择不建立长连接的RPC组件来说，只能通过注册服务机制来监听服务端是否下线。</p><p>如果调用比较频繁的服务来说，客户端可以在服务连接未成功的情况下，将该机器从服务连接列表中剔除，放在<code>暂时不可用机器列表</code>，然后起一个定时任务，当机器暂存5s后，再放到可用列表尝试请求服务调用。</p><p>关于心跳请求的定时任务，可以参考使用Netty提供的<code>HashedWheelTimer</code><a href="https://zacard.net/2016/12/02/netty-hashedwheeltimer/">netty源码解读之时间轮算法实现-HashedWheelTimer</a>，其提供了在不要求高精度触发定时任务的场景下，性能非常高。</p><p><em>最后，再聊聊服务调用路由：</em></p><p>服务路由，这里特指除负载均衡之外的一些服务寻址策略。和负载均衡不同的是，这里的路由策略是单个机器根据自身特点做出的服务方选择策略，而负载均衡策略则是基于整个集群中所有机器的普适策略。如上所言，我们的多机房部署，再拿到集群机器列表之后，我们还需要维持一个本机房的机器列表(一般，对服务集群列表进行按IP前缀规则来过滤)，这样当我们选择调用机器的时候，会优先从本机房获取连接，如果没有才会按照负载均衡来获取服务调用连接。</p><p>此外，对于一些完善的RPC框架，可能还会支持动态可配置路由规则。比如，我们可以按照机器ip来配置，某些客户端调用只能路由到某些服务端机器上。对于线上测试问题跟踪而言，可以很好的根据服务调用链路，来查看日志解决问题。</p><h3 id="RPC超时管理"><a href="#RPC超时管理" class="headerlink" title="RPC超时管理"></a>RPC超时管理</h3><p>作为一个健康的服务，一定需要超时机制。相当多的服务不可用问题，都是因为客户端没有超时机制，导致服务端抖动的一段时间内，客户端一直处于占用连接等待响应的阶段，耗尽服务端资源，最后导致服务端集群雪崩。所以在请求网络服务的时候，增加超时设置是多么重要(当然，连接使用现在最大连接数的连接池也非常重要)。</p><p>RPC的调用实现，一般会有一个IO线程池来处理RPC调用，也就是我们的业务线程会将调用请求交给RPC线程来处理，返回一个future对象。远程调用处理完成之后，RPC线程会将结果填充到<code>futrue</code>对象内部，然后告知调用方调用完成，可以使用<code>futrue.get</code>来获取返回数据。如下所示：</p><p><img src="/images/2016/12/timeout.png" alt="RPC客户端调用处理"></p><p>从上图可以看出，<code>超时1</code>我们可以直接使用<code>futrue.get</code>特性来设置和处理超时问题。<code>超时2</code>指的是服务端执行的超时，比如我们客户端调用的时间是1s，但是服务端可能会超过1s，而这个时候客户端其实已经超时丢弃这次请求，但是服务端还一直执行直到完成返回，这个时候服务端需要序列化对象然后传输到客户端，但是这个流程其实可以简化的。</p><p>因此，服务端的超时管理，是当服务端业务逻辑执行完成之后(这期间实现超时中断比较难)，比较执行时间和客户端设置的超时时间，如果接近，则打包服务端超时错误信息返回给客户端即可。这样可以节省序列化数据时间(直接使用序列化好了的数据返回)，已经减少网络传输时间。</p><h3 id="RPC-服务发现"><a href="#RPC-服务发现" class="headerlink" title="RPC 服务发现"></a>RPC 服务发现</h3><p>在对外http服务里，我们有一个配套的支撑基础组件叫做DNS，其根据域名找到某几个外网ip地址。然后，请求打到网站内部，一般首先到nginx群，nginx也会根据url规则找到配置好的一组ip地址，此外，nginx根据healthcheck来检查http服务是否可用。但是，使用nginx时，我们通常需要把ip地址离线配置到nginx上。</p><p>我们提供的RPC服务都是集群部署，所以我们需要在客户端维持一个服务调用地址列表。所以，我们也需要类似DNS功能的服务。 但是，我们不想我们的RPC服务集群有机器迁移或者增加时，所需要离线给客户端配置，这就是说，我们还需要实时更新集群机器列表的功能。</p><p>这，就是RPC服务发现模块需要解决的问题。</p><p>一般，服务发现主要包括2部分：</p><ol><li>服务地址存储；</li><li>服务状态感知。</li></ol><h4 id="服务地址存储"><a href="#服务地址存储" class="headerlink" title="服务地址存储"></a>服务地址存储</h4><p>服务地址存储，首先需要一个组件来存放服务机器列表等RPC服务数据，提供存储服务的组件有很多，比如：zookeeper，redis，mysql等等。然后，在服务端正常启动可以提供服务之后，需要将自己的服务地址，比如ip，port，以及服务信息，比如接口，版本号等信息，提交到存储服务机器上。然后，客户端在启动的时候，从存储服务的机器上，根据接口，版本等服务信息来拿到提供对应服务的RPC地址列表，客户端根据这个列表就可以开始调用远程服务了。</p><p>此外，为了服务治理，比如我们需要知道哪些客户端调用了我们对外提供的服务，就需要客户端在启动的时候，把自己的地址数据和调用的服务信息提交到存储服务上去。</p><p>对于提供比较完善的服务治理功能，还可以提供后台操作界面，让某些服务端机器手动操作上/下线，这样让通过RPC调用的客户端不将流量打到下线的服务器上。</p><p>简单的服务发现，RPC方和存储组件之间的交互如下：</p><p><img src="/images/2016/12/find.png" alt="RPC服务发现结果"></p><h4 id="服务状态感知"><a href="#服务状态感知" class="headerlink" title="服务状态感知"></a>服务状态感知</h4><p>这里的服务感知，包括客户端感知服务端状态，以及存储服务感知RPC参与方的状态。</p><p>正常情况下，我们从存储组件那里拿到服务端地址后，自己来处理路由策略，然后选择一个服务端建立连接，执行远程调用。在执行的过程中，如果有服务不可用，我们可以从我们的服务列表中，将它剔除。但是，如果服务增加机器或者服务机器迁移了呢？这就需要我们及时了解服务端集群的整体机器状态。两种方式：</p><ol><li>客户端其一个定时调度任务，周期去存储组件处拉取最新的服务集群地址列表，但是这个周期粒度比较难控制。</li><li>客户端和存储组件建立一个长连接，当存储组件发现有服务集群状态发生变更，推送给客户端。但是，这又要求存储组件具有推送功能。</li></ol><p>目前有这个功能的存储组件，主要有zookeeper和redis，此外，也可以自己实现一个简单可靠的服务发现中间件，对外提供推送存储服务。</p><p>我们在服务启动的时候，会告知存储组件我们对外提供服务的地址信息和客户端的地址信息；在服务已知操作的服务下线的时候，会将存储组件中存储的服务相关信息清除掉。但是，显然，在服务下线或者客户端下线的时候，都存在没有清除存储信息就宕机的情况，这个时候就需要存储组件需要有感知各个参与方的状态了。</p><p>一般，我们会让RPC两方都和存储组件保持连接，然后通过心跳等方式来探测对方是否下线。</p><p>目前提供这个功能的存储组件，主要有zookeeper和redis。当然，你也可以实现一个，可以和所有注册服务和查找服务的server保持长连接。由于，可能有大量的机器建立长连接，所以服务器性能一定要高。</p><blockquote><p>基于zookeeper实现服务发现功能的代码，可以参考：<a href="https://github.com/ketao1989/ourea">https://github.com/ketao1989/ourea</a></p></blockquote><h3 id="RPC-多线程IO模型"><a href="#RPC-多线程IO模型" class="headerlink" title="RPC 多线程IO模型"></a>RPC 多线程IO模型</h3><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>RPC其实是一个说简单简单，说复杂复杂的组件。就如上文写的一个简单的RPC示例，其本身就是一个具备RPC功能的组件。但是，在深入篇中，可以看到每一个模块都可以深入优化，以及支持模块化插件话设计开发。</p><p>本文从单机到集群，从本地调用到远程调用的渐进过度。然后再从一个满足RPC结构图的简单示例开始，代码介绍每个模块，进而深入成熟RPC框架所需要考虑和优化的各个技术点。</p><p>本文的目的，旨在对RPC整体结构和各个模块进行介绍和深入，然后根据这些点，可以去分析开源的RPC框架或者自己写一个RPC组件。</p><p>在本文中，很多点都是一边学习，一边总结，所以知识有限，如有问题，欢迎交流。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://yq.aliyun.com/articles/8931">linux内存管理浅析</a></li><li><a href="http://www.ibm.com/developerworks/cn/websphere/library/techarticles/1601_clark-trs/1601_clark.html">微服务、SOA 和 API：是敌是友？</a></li><li><a href="http://tech.meituan.com/serialization_vs_deserialization.html">序列化和反序列化</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> rpc </category>
          
          <category> dubbo </category>
          
          <category> thrift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>聊聊 Java GC</title>
      <link href="2016/05/29/2016-05-29-talk-about-java-gc/"/>
      <url>2016/05/29/2016-05-29-talk-about-java-gc/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a><a id="Preface">序</a></h2><p>GC 是每一个Java程序员不可绕过的话题。GC 是在<code>某些时候</code>对<code>内存</code>的垃圾<code>对象数据</code>进行<code>搜寻定位</code>，然后进行内存空间<code>回收</code>。根据这个定义，则学习GC相关知识，需要关注：对JVM整个内存结构中哪些区域进行垃圾回收；在这些内存区域中的类数据或者实例数据等数据结构是什么样子的；然后想想如何在JVM内存空间中分配内存给这些实例数据；在所有已分配了的实例里，怎么找出需要回收的数据。</p><p>综上，对于JVM GC知识体系来说，就是弄清楚JVM在什么时候，对什么对象，进行什么操作来回收内存空间。</p><h2 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a><a id="JVM_Memory">JVM 内存结构</a></h2><p>既然是对内存进行GC操作，那么首先需要了解 JVM 的内存结构了。</p><p>在Oracle的官方文档【<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">Java Garbage Collection Basics</a>】中，给出了JVM的整体架构图，如下所示：</p><p><img src="/images/2016/05/jvm_conponent.png" alt="JVM架构图"></p><p>也就是说，对一个JVM来说，其主要由 <code>ClassLoader</code> 和 <code>Runtime Data 区域</code> ,<code>执行引擎</code>以及<code>本地方法</code>四大部分组成。(关键的性能优化集中在<code>Heap</code>,<code>JIT编译</code>和<code>GC</code>三大块)。</p><span id="more"></span><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>从架构图中，可以看出，<code>ClassLoader</code>是用来加载java class文件的，也就是说，在java的世界里，所有的<code>*.class</code>都必须通过<code>ClassLoader</code>加载到JVM虚拟机中，才能被执行。</p><p>对于每一个JVM来说，都会有一个默认的<code>ClassLoader</code>，用来加载二进制文件到内存中。当然，既然是默认，必然就存在自定义的<code>ClassLoader</code>了。</p><p>但是，在JVM中，存在自定义的<code>ClassLoader</code>，就需要考虑如果不让自定义的实现类加载逻辑，导致java基础类库的对象发生不可预知的安全问题，所以JVM 的<code>ClassLoader</code> 对类加载的顺序逻辑进行的限制。这就是所谓的<code>双亲委派模型</code>。</p><p><img src="/images/2016/05/classloader.png" alt="ClassLoader架构"></p><p>上图（来自【<a href="http://blog.csdn.net/xyang81/article/details/7292380">深入分析Java ClassLoader原理</a>】）展示了JVM ClassLoader 的三个模型的加载器以及应用可以自己实现的自定义加载器。从图上可以看出除了<code>Bootstrap ClassLoader</code>不存在父类之后，其他ClassLoader都有父类加载器。</p><p><code>双亲委派模型</code>就是说，ClassLoader 在加载类的时候，其首先去父类里查找是否其已经加载了该类，一层层递归查找，没有的话，就依次自己尝试加载该类，如果没找到，则会抛出<code>ClassNotFoundException</code>，当最外层的子类依然没加载成功，则最终的依次将会抛出到应用中。</p><p>简单来说，就是首先向上(父类方向)查找类是否加载，然后如果没有已经被加载，则向下(子类方向)尝试去加载类，直到加载成功，或者抛出异常。</p><p>简单地源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);<span class="comment">//向上查找</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);<span class="comment">//自己加载</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JVM-运行时内存空间"><a href="#JVM-运行时内存空间" class="headerlink" title="JVM 运行时内存空间"></a>JVM 运行时内存空间</h3><p><img src="/images/2016/05/jvm_mm.png" alt="JVM架构-运行时数据区"></p><p>上图【<a href="https://segmentfault.com/a/1190000002579346">JVM 的 工作原理，层次结构 以及 GC工作原理</a>】中可以看出线程和内存区域之间的关系。对于具体的内存空间结构，如下图所示：</p><p><img src="/images/2016/05/jvm_mm2.png" alt="内存结构"></p><p>上图包含除<code>ClassLoader</code>之外，JVM架构的其他三个部分。执行引擎中JIT是对java程序执行时的优化操作，GC引擎则是本文的重点，后面会详细介绍。本地方法则是使用C/C++编写的底层代码程序，这里不作介绍。</p><p>下面重点来说说，绿色区域的运行时数据区。</p><h4 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h4><ul><li>程序计数器：和系统中PC一样，就是执行下一条需要执行的指令；每一个线程都对应一个程序计数器；但是执行本地方法由于对JVM透明，所以对应程序计数器为空。</li><li>虚拟机栈：如上图所示，一个虚拟机栈包含局部变量，操作数栈，返回地址等信息。对于一个线程中的每一个方法，都有对应的虚拟机栈。虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StatckOverFlowError（栈溢出）；不过多数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，直到内存不足，此时，会抛出OutOfMemoryError（内存溢出）。</li><li>本地方法栈：执行native方法时，所需要的栈空间。</li></ul><blockquote><blockquote><p>本地方法栈和虚拟机栈在HotSpot实现里，是合并在一起的，统称为栈。</p></blockquote></blockquote><h4 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h4><ul><li>方法区：方法区是对所有类共享的，所以多线程操作需要进行同步处理。其内部主要存储加载类的相关信息（包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。<blockquote><blockquote><p>如上图，方法区中其中一个重要内容就是运行时常量池，但是这个在JDK7中已经移到堆中存储了。运行时常量池，包括编译后的字符常量，以及运行时的常量。因此，以前String.itern()导致的常量池爆掉抛出<code>java.lang.OutOfMemoryError: PermGen space</code>错误，现在没有了。</p></blockquote></blockquote></li><li>堆：一般来说，JVM所有的对象实例都是存储在堆上的，因此其也是线程共享的。对于JVM GC来说，其主战场就是堆空间。因此，后面的GC 操作都是基于堆空间的回收策略分析的。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>JVM 的内存结构，实际上就是堆和栈，栈是线程私有的，因此上面的对象不需要同步操作，并且重点是由于栈帧是伴随着线程方法的生命周期的，所以其内部的垃圾回收不用考虑(这里说的是存储在栈上的数据，当然方法里的变量，实例数据等分配在堆上的，还是需要垃圾回收的)。</p><p>堆上面包含几乎所有交互操作数据，各个对象实例，变量等信息都是由堆来分配管理，因此，JVM的垃圾回收就是基于堆的垃圾回收。</p><h2 id="JVM-对象实例结构"><a href="#JVM-对象实例结构" class="headerlink" title="JVM 对象实例结构"></a><a id="Class_Instace">JVM 对象实例结构</a></h2><p>垃圾回收是回收内存中标记为不再使用的对象实例，因此，需要了解对象的结构和对应的引用被访问的方式。</p><h3 id="对象实例结构"><a href="#对象实例结构" class="headerlink" title="对象实例结构"></a>对象实例结构</h3><p>在C的世界里，我们会经常计算一个数据结构所占用的内存空间；那么对于Java而言，一个对象的数据结构和内存占用是怎样的呢。</p><p>对象的实例内存布局主要包括三部分：对象头(Header)、实例数据(Instance Data)和对其数据(Padding)。</p><h4 id="JVM-对象头"><a href="#JVM-对象头" class="headerlink" title="JVM 对象头"></a>JVM 对象头</h4><p>对于JDK默认的虚拟机HotSpot来说，其对象头主要包含两部分：</p><ul><li>所谓的<code>Mark Word</code>，用于存储对象自身的运行时数据，比如hashcode，<code>GC分代年龄</code>(这个在分代GC中很重要)以及锁状态标识和线程ID等相关信息。这部分在32bit和64bit的JVM上占用的空间是不同的，分别为4B 和 8B。如下图所示：  </li></ul><p>32bit:<br><img src="/images/2016/05/32_bits.png" alt="32bit">  </p><p>64bit:<br><img src="/images/2016/05/64_bits.png" alt="64bit"></p><p>不管32还是64，其GC分代年龄都是4bit，因此，分代年龄最高为15。</p><ul><li>类型指针(kclass)，即对象指向其类元数据的指针，JVM通过这个指针可以确定该对象是哪个类的实例。比如，针对java对象调用 <code>ins instanceOf Clazz </code>方法，就是首先通过ins对象头中该指针来找到方法区中该类的相关信息，然后匹配Clazz以及其super链，匹配上了，则说明是其对应的实例对象。 </li></ul><blockquote><blockquote><p>此外，如果是数组类型的话，则在对象头中还有一块空间是用来存储数组长度，不管32还是64，这个长度占用的空间都是4B，因此，数组最大长度为<code>Integer.MAX_VALUE</code>。  </p></blockquote></blockquote><blockquote><blockquote><p>一般的，对象头在32bit下，大小为4B+4B=8B，而64bit为8B+8B=16B。(开启指针压缩，则为8B+4B=12B)</p></blockquote></blockquote><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>顾名思义，就是对象真正存储有效信息的地方。无论数据是从父类继承下来的，还是子类中定义的，都在这里记录下来。java中基础类型的内存占用如下：</p><table><thead><tr><th>类型</th><th align="right">占用字节bytes</th></tr></thead><tbody><tr><td>boolean</td><td align="right">1</td></tr><tr><td>byte</td><td align="right">1</td></tr><tr><td>short</td><td align="right">2</td></tr><tr><td>char</td><td align="right">2</td></tr><tr><td>int</td><td align="right">4</td></tr><tr><td>float</td><td align="right">4</td></tr><tr><td>long</td><td align="right">8</td></tr><tr><td>double</td><td align="right">8</td></tr><tr><td>ref</td><td align="right">4/8</td></tr></tbody></table><blockquote><blockquote><p>一般来说，一个对象实例原生数据和实例在一起，而最引用类型只是一个地址，具体的数据，在指向堆上其他对应的实例。</p></blockquote></blockquote><h4 id="对齐数据"><a href="#对齐数据" class="headerlink" title="对齐数据"></a>对齐数据</h4><p>在HotSpot JVM 中，内存中的数据都要求是按8B字节对其的，如果一个对象大小不是8B，则会自动填充对其到8B的倍数。</p><h3 id="对象访问方式"><a href="#对象访问方式" class="headerlink" title="对象访问方式"></a>对象访问方式</h3><p>如上文所述，一个对象的数据，可能会包含其他对象的引用，那么在使用的时候，就需要找到对应的对象数据信息。</p><p>【<a href="http://www.infoq.com/cn/articles/jvm-hotspot">HotSpot虚拟机对象探秘</a>】<br>Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范里面只规定了是一个指向对象的引用，并没有定义这个引用应该通过什么种方式去定位、访问到堆中的对象的具体位置，对象访问方式也是取决于虚拟机实现而定的。主流的访问方式有使用句柄和直接指针两种。</p><ul><li>如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。如图1所示。</li></ul><p><img src="/images/2016/05/indirect.png" alt="indirect"></p><ul><li>如果使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如图2所示。</li></ul><p><img src="/images/2016/05/direct.png" alt="direct"></p><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项非常可观的执行成本。从上一部分讲解的对象内存布局可以看出，就虚拟机<code>HotSpot</code>而言，它是使用第二种方式进行对象访问，但在整个软件开发的范围来看，各种语言、框架中使用句柄来访问的情况也十分常见。</p><h2 id="JVM-垃圾对象判断"><a href="#JVM-垃圾对象判断" class="headerlink" title="JVM 垃圾对象判断"></a><a id="Garbage_Search">JVM 垃圾对象判断</a></h2><p>垃圾对象查找，首先需要明确什么对象可以认为是垃圾对象。</p><h3 id="垃圾对象"><a href="#垃圾对象" class="headerlink" title="垃圾对象"></a>垃圾对象</h3><p>判断一个对象是不是垃圾对象，需要去回收其占用的内存空间，一般有两张方法，一种是基于引用计数，一种是可达性分析。</p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数，操作起来非常简单。就是在全局维护一个Map，当引用一个对象的时候，就给对应的map entry 的value加1；当这个引用失效的时候，就将对应的value减1。当value的值为0的时候，就说明此刻该对象是垃圾对象，可以被回收掉。</p><p>因此，引用计数基本上可以做到实时去回收空间，但是它有一个大问题，就是无法处理循环引用的问题。此外，对每一个对象的申请或者销毁都会导致其内部引用的对象计数进行实时更改，这个操作量级还是相当大的，这种开销有时候对应用来说可能都不能容忍。比如，有一个对象内部包含了非常多的局部变量，并且引用的这些变量可能全局Map都剩1，则当这个对象销毁的时候，其会触发大量的引用计数为0，从而大量对象进行销毁回收操作，这些操作可能导致系统暂时无法响应其他请求。</p><p>因此，现在一些编译器即使使用引用计数自动回收垃圾，也会加上其他辅助算法，比如标记-清除。</p><h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>可达性分享，也就是 <code>Tracing GC</code>。Tracing GC的核心操作之一就是从给定的根集合出发去遍历对象图。对象图是一种有向图，该图的节点是对象，边是引用。遍历它有两种典型顺序：深度优先（DFS）和广度优先（BFS）。【<a href="http://hllvm.group.iteye.com/group/topic/39376">HotSpot VM Serial GC的一个问题</a>】</p><blockquote><blockquote><p>由于深度优先DFS一般采用递归方式实现，处理tracing的时候，可能会导致栈空间溢出，所以一般采用广度优先来实现tracing。</p></blockquote></blockquote><p>广度优先遍历其实很简单，就是将遍历到了的节点处理，然后将子节点放入到队列中，迭代处理每个队列节点，直到队列为空。如下图所示：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/4/46/Animated_BFS.gif" alt="image"></p><p>对于HotSpot来说，其<code>GC Roots</code>为：</p><ul><li>虚拟机栈中引用的对象（栈帧中局部变量表中的对象）；</li><li>方法区中静态属性和常量引用的对象；</li><li>本地方法栈中的对象。</li></ul><p>因此，在遍历之前，将这些对象放入扫描的队列中，然后依次迭代遍历。</p><p>下面给出了一个简化版的遍历算法实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">breadth_first_search</span><span class="params">(Graph* graph)</span> </span>&#123;  </span><br><span class="line">  <span class="comment">// 记录灰色对象的队列  </span></span><br><span class="line">  Queue&lt;Node*&gt; scanning;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 一开始对象都是白色的  </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 把根集合的引用能碰到的对象标记为灰色  </span></span><br><span class="line">  <span class="comment">// 由于根集合的引用有可能有重复，所以这里也必须  </span></span><br><span class="line">  <span class="comment">// 在把对象加入队列前先检查它是否已经被扫描到了  </span></span><br><span class="line">  <span class="keyword">for</span> (Node* node : graph-&gt;<span class="built_in">root_edges</span>()) &#123;  </span><br><span class="line">    <span class="comment">// 如果出边指向的对象还没有被扫描过  </span></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">nullptr</span> &amp;&amp; !node-&gt;<span class="built_in">is_marked</span>()) &#123;  </span><br><span class="line">      node-&gt;<span class="built_in">set_marked</span>();        <span class="comment">// 记录下它已经被扫描到了  </span></span><br><span class="line">      scanning.<span class="built_in">enqueue</span>(child); <span class="comment">// 也把该对象放进灰色队列里等待扫描  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 逐个扫描灰色对象的出边直到没有灰色对象  </span></span><br><span class="line">  <span class="keyword">while</span> (!scanning.<span class="built_in">is_empty</span>()) &#123;  </span><br><span class="line">    Node* parent = scanning.<span class="built_in">dequeue</span>();  </span><br><span class="line">    <span class="keyword">for</span> (Node* child : parent-&gt;<span class="built_in">child_nodes</span>() &#123; <span class="comment">// 扫描灰色对象的出边  </span></span><br><span class="line">      <span class="comment">// 如果出边指向的对象还没有被扫描过  </span></span><br><span class="line">      <span class="keyword">if</span> (child != <span class="literal">nullptr</span> &amp;&amp; !child-&gt;<span class="built_in">is_marked</span>()) &#123;  </span><br><span class="line">        child-&gt;<span class="built_in">set_marked</span>();       <span class="comment">// 把它记录到黑色集合里  </span></span><br><span class="line">        scanning.<span class="built_in">enqueue</span>(child); <span class="comment">// 也把该对象放进灰色队列里等待扫描  </span></span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上遍历完之后，如果某些对象没有被遍历标记到，则它就有<code>可能</code>会被回收了。</p><blockquote><blockquote><p>可能被回收，则说明也有可能不会被回收。其实，在HotSpot的实现中，对象是有两次机会逃过被垃圾回收销毁的命运的。</p><p>如果对象进行可达性遍历之后，发现没有和GC Roots有相连的引用，则将该对象标记为不可达对象，并且进行筛选：对象是否覆盖finalize方法或者是否已经执行了该方法来决定是否接下来执行<code>finalize()</code>方法。</p><p>如果对象判定为需要执行finalize()方法，则将该对象放入<code>F-Queue</code>队列中，然后由一个虚拟机创建的低优先级Finalizer线程去触发执行队列中的finalize()方法，但是不一定会被执行（可能前面的finalize方法导致线程一直阻塞无法继续遍历执行下去）。因此，这种情况下，对象可能并不会被销毁回收。</p><p>稍后GC将对<code>F-Queue</code>队列进行第二次标记，如果这次标记还无效的话，则真的被回收销毁了。</p></blockquote></blockquote><h3 id="JVM-GC-引用"><a href="#JVM-GC-引用" class="headerlink" title="JVM GC 引用"></a>JVM GC 引用</h3><p>【<a href="http://www.zhihu.com/question/34341582/answer/58444959">这段 Java 代码中的局部变量能够被提前回收吗？编译器或 VM 能够实现如下的人工优化吗？</a>】<br>【<a href="http://rednaxelafx.iteye.com/blog/1044951">找出栈上的指针/引用</a>】</p><p>在前面章节中已经介绍了内存对象结构和访问方式，并且知道栈帧中的引用类型是GC Roots集合中的一个重要的部分，因此要获取这些引用类型数据就是GC的重要一步了。</p><h4 id="保守GC"><a href="#保守GC" class="headerlink" title="保守GC"></a>保守GC</h4><p>如果JVM选择不记录任何这种类型的数据，那么它就无法区分内存里某个位置上的数据到底应该解读为引用类型还是原生类型。这种GC就是“保守式GC（conservative GC）”。在进行GC的时候，JVM开始从一些已知位置（例如说JVM栈）开始扫描内存，扫描的时候每看到一个数字就看看它“像不像是一个指向GC堆中的指针”。这里会涉及上下边界检查（GC堆的上下界是已知的）、对齐检查（通常分配空间的时候会有对齐要求，假如说是8字节对齐，那么不能被8整除的数字就肯定不是指针），之类的。然后递归的这么扫描出去。 </p><p>保守式GC的好处是相对来说实现简单些，而且可以方便的用在对GC没有特别支持的编程语言里提供自动内存管理功能。比如在C或者C++语言中自己实现。</p><p>保守式GC的缺点有：</p><ol><li><p>会有部分对象本来应该已经死了，但有疑似指针指向它们，使它们逃过GC的收集。这对程序语义来说是安全的，因为所有应该活着的对象都会是活的；但对内存占用量来说就不是件好事，总会有一些已经不需要的数据还占用着GC堆空间。具体实现可以通过一些调节来让这种无用对象的比例少一些，可以缓解（但不能根治）内存占用量大的问题。 </p></li><li><p>由于不知道疑似指针是否真的是指针，所以它们的值都不能改写；移动对象就意味着要修正指针。换言之，对象就<code>不可移动</code>了。有一种办法可以在使用保守式GC的同时支持对象的移动，那就是增加一个间接层，不直接通过指针来实现引用，而是添加一层“句柄”（handle）在中间，所有引用先指到一个句柄表里，再从句柄表找到实际对象。这样，要移动对象的话，只要修改句柄表里的内容即可。但是这样的话引用的访问速度就降低了。Sun JDK的Classic VM曾经用过这种全handle的设计，但效果实在算不上好。 </p></li></ol><p>由于JVM要支持丰富的反射功能，本来就需要让对象能了解自身的结构，而且这种信息GC的时候也可以利用上，所以JVM都会保留一些信息在对象上，而不会采用完全保守式的GC。</p><h4 id="半保守GC"><a href="#半保守GC" class="headerlink" title="半保守GC"></a>半保守GC</h4><p>JVM可以选择在栈上不记录类型信息，而在对象上记录类型信息。这样的话，扫描栈的时候仍然会跟上面说的过程一样，但扫描到GC堆内的对象时，因为对象带有足够类型信息，JVM就够判断出在该对象内什么位置的数据是引用类型了。这种是“半保守式GC”。 </p><p>为了支持半保守式GC，运行时需要在对象上带有足够的元数据。如果是JVM的话，这些数据可能在类加载器或者对象模型的模块里计算得到，但不需要JIT编译器的特别支持。</p><p>由于半保守式GC在堆内部的数据是准确的，所以它可以在直接使用指针来实现引用的条件下支持部分对象的移动，方法是只将保守扫描能直接扫到的对象设置为不可移动（pinned），而从它们出发再扫描到的对象就可以移动了。</p><p>完全保守的GC通常使用不移动对象的算法，例如mark-sweep。半保守方式的GC既可以使用mark-sweep，也可以使用移动部分对象的算法。半保守式GC对JNI方法调用的支持会比较容易：管它是不是JNI方法调用，是栈都扫过去，不需要对引用做任何额外的处理。当然代价跟完全保守式一样，会有“疑似指针”的问题。</p><h4 id="准确GC"><a href="#准确GC" class="headerlink" title="准确GC"></a>准确GC</h4><p>与保守式GC相对的是“准确式GC”。也就是说给定某个位置上的某块数据，要能知道它的准确类型是什么，这样才可以合理地解读数据的含义；GC所关心的含义就是“这块数据是不是指针”。 要实现这样的GC，JVM就要能够判断出所有位置上的数据是不是指向GC堆里的引用，包括活动记录（栈+寄存器）里的数据。</p><p>实现方法是：从外部记录下类型信息，存成映射表。HotSpot把这样的数据结构叫做OopMap。其每次都遍历原始的映射表，循环的一个个偏移量扫描过去；这种用法也叫“解释式”；HotSpot采用的是这种方式。(示例可以参考safePoint例子)</p><p>在HotSpot中，对象的类型信息里有记录自己的OopMap，记录了在该类型的对象内什么偏移量上是什么类型的数据。所以从对象开始向外的扫描可以是准确的；这些数据是在类加载过程中计算得到的。 </p><p>每个被JIT编译过后的方法也会在一些特定的位置记录下OopMap，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用。这样GC在扫描栈的时候就会查询这些OopMap就知道哪里是引用了。这些位置就是“安全点”（safepoint）。之所以要选择一些特定的位置来记录OopMap，是因为如果对每条指令（的位置）都记录OopMap的话，这些记录就会比较大，那么空间开销会显得不值得。选用一些比较关键的点来记录就能有效的缩小需要记录的数据量，但仍然能达到区分引用的目的。因为这样，HotSpot中GC不是在任意位置都可以进入，而只能在safepoint处进入。而仍然在解释器中执行的方法(非JIT优化的代码)则可以通过解释器里的功能自动生成出OopMap出来给GC用。 </p><p>平时这些OopMap都是压缩了存在内存里的；在GC的时候才按需解压出来使用。 </p><h4 id="GC-SafePoint位置"><a href="#GC-SafePoint位置" class="headerlink" title="GC SafePoint位置"></a>GC SafePoint位置</h4><p>在HotSpot JVM中，解释执行的方法可以在任何字节码边界上执行GC，但是对于采用JIT编译执行的方法，则不能想GC就GC了，必须进入到GC SafePoint 位置。</p><ul><li>主动SafePoint：由方法里的代码主动轮询去发现需要进入SafePoint，两种情况：<ul><li>循环回跳处(loop backedge)；</li><li>方法返回处(return)；</li><li>可能抛出异常的问题(throw)。</li></ul></li><li>被动SafePoint：调用别的方法的调用点。之所以叫做“被动”是因为并不是该方法主动发现要进入safepoint的，而是某个被调用的方法主动进入了safepoint，导致其整条调用链上的调用者都被动的进入了safepoint。</li></ul><p>比如下面的这个简单方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LargeObject lo = <span class="keyword">new</span> LargeObject(); <span class="comment">// safepoint 1/2: 被动safepoint</span></span><br><span class="line">  <span class="comment">// OopMap 1: 空。</span></span><br><span class="line">  <span class="comment">// 该栈帧里尚未有任何引用类型的局部变量是活跃的——new还没执行完</span></span><br><span class="line">  <span class="comment">// OopMap 2: 记录了一个变量：刚分配的对象的引用是活的，在OopMap里；不过这还不是局部变量lo而是求值栈上的一个slot</span></span><br><span class="line">  lo.doSomeThing();                   <span class="comment">// safepoint 3: 被动safepoint</span></span><br><span class="line">  <span class="comment">// OopMap 3: 空。局部变量lo的最后一次使用是作为上面方法的&quot;this&quot;参数传递出去；</span></span><br><span class="line">  <span class="comment">// 维持&quot;this&quot;的存活是被调用方法的责任而不是调用方法的责任。此后局部变量lo再也没有被使用过，所以对main()来说lo在此处已死。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    whatever();                       <span class="comment">// safepoint 4: 被动safepoint</span></span><br><span class="line">    <span class="comment">// OopMap 4: 空。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// safepoint 5: 主动safepoint：循环回跳轮询（backedge poll）</span></span><br><span class="line">    <span class="comment">// OopMap 5: 空。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 上面循环是无限循环，所以下面如果有代码都属于不可到达的代码（unreachable code）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果上面的循环不是无限循环的话，则：</span></span><br><span class="line">  <span class="comment">// safepoint 6: 主动safepoint：返回前轮询（return poll）</span></span><br><span class="line">  <span class="comment">// OopMap 6: 空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JVM-内存管理"><a href="#JVM-内存管理" class="headerlink" title="JVM 内存管理"></a><a id="JVM_Management">JVM 内存管理</a></h2><p>前面讲了这么多，都是在介绍JVM内存中一些区域的划分，对象在内存中的结构，以及HotSpot JVM 支持的精确式GC所采用的数据结构等等。</p><p>下面，进入重点。Java 中创建一个对象时，JVM 内存如何处理，当内存空间不够时，又是如何触发垃圾回收的。</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>一般的，在java里面讨论内存分配都以为是建立在堆上，但这个不熟绝对的。细分的话，给一个新对象分配内存空间，可能是在栈上，TLAB(Thread Local Allocation Buffer) 或者堆上。</p><h4 id="逃逸分析之栈分配"><a href="#逃逸分析之栈分配" class="headerlink" title="逃逸分析之栈分配"></a>逃逸分析之栈分配</h4><p>在 JVM中提供了一种内存分配优化的方式，就是基于逃逸分析技术，将新的对象实例分配到栈上。所谓逃逸分析，就是分析指针<code>动态范围</code>的方法。简而言之，就是当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。而用来分析这种逃逸现象的方法，就称之为逃逸分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; list ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// list是全局变量，发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getListValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();;    <span class="comment">// 返回了list，发生了逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">echoTmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TestClass clazz = <span class="keyword">new</span> TestClass();<span class="comment">//未发生逃逸</span></span><br><span class="line">        clazz.echo();</span><br><span class="line">        System.out.println(<span class="string">&#x27;ok.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么，当一个方法中有变量没有发生逃逸事件，则VM可以根据设置进行内存分配优化。</p><p>从上文的对象定位可以看到，一般情况下，java对象都是在堆上分配，然后其引用指针保存在调用栈对应位置，然后在访问的时候，需要两次查找才能获取完所有的需要的对象信息，而在栈上分配对象内存的话，就避免了这个耗时。此外，当对象不在使用的时候，由于只是方法内部使用，所以下次GC就需要回收这些对象，这又需要GC线程去遍历对象树来回收内存。</p><blockquote><blockquote><p>逃逸分析的内存优化并不能在静态编译的时候进行，而需要在JIT动态编译的时候触发。逃逸分析是基于方法内部执行来的，当时在静态编译的时候，由于Java动态代理，反射等特性导致最终运行时候的逻辑是无法知道的。关于这个话题具体讨论参考【<a href="https://www.zhihu.com/question/27963717">逃逸分析为何不能在编译期进行？</a>】</p><p>在测试的时候，你需要<code> -XX:+DoEscapeAnalysis</code>设置来打开逃逸分析的优化技术。但是由于基于逃逸分析开销会有一些，而这些未必能抵住获得的性能，所以需要仔细测试是否需要打开该项优化。</p></blockquote></blockquote><h4 id="TLAB-分配区"><a href="#TLAB-分配区" class="headerlink" title="TLAB 分配区"></a>TLAB 分配区</h4><p>在创建新的对象而申请内存的时候，则需要去堆上获取内存空间，在多线程的情况下，则需要进行同步锁操作，进而影响分配效率，因此，JVM在内存新生代<code>Eden Space</code>中开辟了一小块线程私有的区域，称作TLAB。默认设定为占用Eden Space的1%。</p><p>在Java程序中很多对象都是小对象且用完之后就需要回收，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。</p><blockquote><blockquote><p>TLAB是针对线程的小对象的，如果需要分配的对象过大，还是需要在堆上进行分配。<code>-XX:TLABWasteTargetPercent</code>来设置TLAB占用Eden区的比例。</p></blockquote></blockquote><h4 id="堆空间分配"><a href="#堆空间分配" class="headerlink" title="堆空间分配"></a>堆空间分配</h4><p>如果优化全开，则JVM会先进行逃逸分析，如果未逃逸则在栈上进行分配；否则在TLAB是否有足够的空间分配，如果有，则在TLAB上分配空间；如果依然失败，则要在堆上进行分配了。</p><blockquote><blockquote><p>Notes：由于堆是所有线程共享的，所以分配时是需要加锁同步的。</p></blockquote></blockquote><p>Oracle官方参考文档【<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html#t1s2">Java Garbage Collection Basics</a>】</p><p>首先，来看看JVM 堆空间详细的分代划分：</p><p><img src="/images/2016/05/jvm_heap.png" alt="image"></p><blockquote><blockquote><p>一般，我们使用<code>-Xms</code>来设置JVM初始内存空间大小，<code>-Xmx</code>设计JVM最大内存空间大小，<code>-Xmn</code>来设置新生代的内存大小(推荐为整个堆的3/8)，<code>-Xss</code>来设置虚拟机栈的空间大小。默认，Eden区和Survivor区的内存空间比例为<code>8:1:1</code>，</p></blockquote></blockquote><p>然后，看一个新对象是如何创建的：</p><ol><li><p>一个对象分配到Eden区，此时survivor区还是一个空内存。<br><img src="/images/2016/05/allocate_1.png" alt="image"></p></li><li><p>然后，当Eden区逐渐增加，当Eden空间不足以分配新的内存申请操作的时候，就会触发minor GC。<br><img src="/images/2016/05/allocate_2.png" alt="image"></p></li><li><p>在Eden中仍存活的对象，则copy到survivor0区中，没有存活的对象则被清除掉。<br><img src="/images/2016/05/allocate_3.png" alt="image"></p></li><li><p>循环进行，当下一个minor GC发生的时候，不存活的对象被删除回收，存活的对象被copy到survivor1中。此外，上一次 minor GC被迁移到Survior0上的对象，存活的迁移到Survivor1上，并且对应的对象分代年龄上的value+1。因此，在S1上，就存在不同分代年龄的对象了。<br><img src="/images/2016/05/allocate_4.png" alt="image"></p></li><li><p>在下一次minor GC中，依然重复上面的动作，将Eden区和S1区的仍然存活的对象copy到S0上，并且对应对象的分代年龄+1。<br><img src="/images/2016/05/allocate_5.png" alt="image"></p></li><li><p>在minor GC 之后，如果存在对象的分代年龄超过设置的<code>-XX:MaxTenuringThreshold</code>值时，则copy到年老代Tenured区。<br><img src="/images/2016/05/allocate_6.png" alt="image"></p></li><li><p>minor GC 继续，将会有越来越多的对象分配到Tenured区。<br><img src="/images/2016/05/allocate_7.png" alt="image"></p></li><li><p>最后，随着Tenured区的对象越来越多，从而触发了major GC，改GC会将年老代的不用对象进行清除，然后压缩年老代内存空间。<br><img src="/images/2016/05/allocate_8.png" alt="image"> </p></li></ol><blockquote><blockquote><p>当需要分配的对象内存足够大时，则直接分配到Tenured区。Full GC和major GC 不一样，其GC时，包含minor GC 和 major GC。</p></blockquote></blockquote><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>在介绍内存回收之前，需要对内存对象生命周期进行分析。IBM研究表明，绝大部分新生对象都是朝生夕死的，也就是一次GC之后就会把对应内存空间释放出来，最后存活下来的对象很少。如下图所示（显然绝大部分对象在第一次GC的时候就被回收掉了）：<br><img src="/images/2016/05/gc_mm.png" alt="image"> </p><p>上图还表明，不同的对象的生命周期不同，对不同的GC策略影响也是不同的。这种表现行为说明，需要对内存对象空间进行分类，因此，在HotSpot中，进行了分代：年轻代和年老代，简单来理解(不完全)：年轻代都是最近才分配内存空间的对象，而年老代则是在年轻代存活足够多的时间升级到年老代来的对象。它的分代内存空间可以参考上图(内存分配)。</p><p>常见的GC策略：</p><ul><li><p>标记-清除策略(Mark-Sweep)。       </p><p>标记-清除策略应该是垃圾回收策略里面最基础最容易想到的算法。其核心思想，就是将需要进行回收的对象进行标记，然后再将没有标记的内存对象进行回收销毁。因此，这个算法存在两个阶段，首先需要从GC Rootes开始根据前面介绍的可达性分析来遍历整个内存对象树，把遍历过得对象进行标记；然后，GC算法将所有未marked的对象delete掉。整个算法很容易明白，但是对于内存分配和回收策略来说，其存在二个比较大的问题：</p><ul><li>内存碎片化问题。对内存进行大量的标记清除操作之后，会导致整个内存区域存在大量不连续内存碎片，最后如果需要分配大内存对象时，很可能需要进入下一次GC操作，甚至会导致分配失败，但是实际上内存空间总量是很充足的。针对碎片化，一般采取的策略是压缩整理方式，即将对象的内存碎片压缩移动到一起，然后将所有区域外的内存全部delete掉即可。</li><li>效率问题。标记-清除，需要首先标记整个内存空间，然后回收未被标记的对象。都是比较影响性能的操作。</li></ul></li><li><p>复制策略(Copying)。   </p><p>由于标记-清除策略效率不高，对于高并发实时服务来说，是很致命的。<br>根据内存生命周期的特点，我们将新生的对象放在一个新生代的Eden内存区域中，然后GC存活下来的对象复制到另一块小的内存区域S0/S1中。此外，新生代可能内存不足或者一些需要长期存活的对象，这些对象就需要分配移动到年老代的内存区域中。  </p><p>对于标记-清除两步骤的操作，复制策略由于采取的内存对象操作不同，导致其只需要一个步骤就能完成GC操作。在遍历GC Roots 对象树的时候，同时将标记到得对象复制到新生代小的S0/S1内存区域中，这样，当我们遍历完对象空间的时候，可以将整个新生代Eden区域内存分配的当前有效内存开始指针置为开始位置，这样，我们就操作完了对新生代对象的GC回收。</p></li><li><p>标记-整理策略(Mark-Compact/Sweep)。</p><p>复制策略效率非常高，但是其是针对新生代的对象特性而优化的，对于年老代的对象来说，其没有那么高的效率，此外主要的就是其浪费大量的内存空间用于复制GC下来的对象。因此，标记-清除策略对于老年代来说，比复制算法还是更好的，我们只需要解决内存碎片化问题即可。因此，这就是标记-整理算法了。</p><p>也就是，我们在标记完整个内存区域的对象树之后，将存活下来的对象依次移动到内存的一端，然后将内存分配指针设置为存活对象的最后，从而完成内存的清理。</p></li></ul><h2 id="JDK-GC-算法"><a href="#JDK-GC-算法" class="headerlink" title="JDK GC 算法"></a><a id="GC_Algorithm">JDK GC 算法</a></h2><p>HotSpot VM 对外提供的垃圾回收：</p><p><img src="/images/2016/05/gc.png" alt="image"></p><h3 id="年轻代三大GC"><a href="#年轻代三大GC" class="headerlink" title="年轻代三大GC"></a>年轻代三大GC</h3><p>如上图所示，对于年轻代的垃圾回收主要有三种：Serial GC，ParNew GC，ParallelScavenge(PS)。</p><h4 id="串行Serial-GC"><a href="#串行Serial-GC" class="headerlink" title="串行Serial GC"></a>串行Serial GC</h4><p>单线程垃圾回收。单线程串行的，所以在进行垃圾回收的时候，需要所有的应用线程都暂停(<code>Stop The World</code>)。全局单线程执行垃圾回收，会得到最好的单线程收集效率，因此对于client来说，其实默认的垃圾回收策略。</p><h4 id="ParNew-GC"><a href="#ParNew-GC" class="headerlink" title="ParNew GC"></a>ParNew GC</h4><p>顾名思义，就是Serial GC的多线程版本，同样也是<code>Stop The World</code>。由于ParNew GC 是目前唯一一个可以专注于老年代GC收集器CMS 配合的并行年轻代GC收集器，CMS优秀的GC性能，导致ParNew GC 被很多server应用采用。</p><blockquote><blockquote><p>并发和并行收集器：并发指应用工作线程和GC线程可以同时执行，分别在不同地CPU上；并行指的是多个GC线程同时工作，此时的工作线程是STOP的状态。</p></blockquote></blockquote><h4 id="Parallel-Scavenge-吞吐量GC"><a href="#Parallel-Scavenge-吞吐量GC" class="headerlink" title="Parallel Scavenge (吞吐量GC)"></a>Parallel Scavenge (吞吐量GC)</h4><p>ParallelSvavenge 收集器也是采用复制算法的多线程年轻代收集器。和ParNew GC不同的是，其关注点在可控吞吐量上，而后者则重视的是GC时间。因此，ParNew收集器适用于用户交互场景，而PS则适用于CPU计算而少交互的场景。吞吐量指CPU用于运行用户代码的时间和CPU总运行时间的比例，即吞吐量=用户代码运行时间/(用户代码运行时间+GC时间)。</p><blockquote><blockquote><p>ParallelScavenge和ParNew都是并行GC，主要是并行收集年轻代，目的和性能其实都差不多。</p><p>最明显的区别有下面几点： </p><ol><li><p>在JDK6u18之后，PS只用深度优先遍历。ParNew则是一直都只用广度优先顺序来遍历。 </p></li><li><p>PS完整实现了自适应大小策略，而ParNew内则没有实现完。所以千万别在用<code>ParNew + CMS</code>的组合下用UseAdaptiveSizePolicy，请只在使用UseParallelGC或UseParallelOldGC的时候用它。 </p></li><li><p>由于在”分代式GC框架”内，ParNew可以跟CMS搭配使用，而ParallelScavenge不能。当时ParNew GC被从Exact VM移植到HotSpot VM的最大原因就是为了跟CMS搭配使用。 </p></li></ol></blockquote></blockquote><h3 id="年老代三代GC"><a href="#年老代三代GC" class="headerlink" title="年老代三代GC"></a>年老代三代GC</h3><p>如上图所示，对于年轻代的垃圾回收主要有三种：Serial Old，Parallel Old，Concurrent Mark Sweep(CMS)。</p><h4 id="串行Serial-Old"><a href="#串行Serial-Old" class="headerlink" title="串行Serial Old"></a>串行Serial Old</h4><p>老年代单线程收集器，使用标记整理策略。Serial Old的标记-整理策略是先标记存活对象，然后先清理掉需要回收的对象，然后将存活的对象进行移动，保证一部分都是存活对象，一部分是空闲的内存空间。和SerialGC 一样，都需要暂停所有工作线程。</p><blockquote><blockquote><p>client模式下默认的Old GC。在Server模式下，当CMS GC时出现<code>Concurrent Mode Failure</code>，则回退使用Serial Old 收集器。</p></blockquote></blockquote><h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><p>Parallel Old 是多线程并行的老年代GC收集器，其主要是配合年轻代PS收集器的老年代版本。</p><blockquote><blockquote><p>和Serial Old不同的整理策略，其首先汇总存活的对象复制到一个区域，然后压缩起来，而不是直接清除再压缩（为什么不直接将存活的对象移动到一侧呢？）。</p></blockquote></blockquote><p><em>以上所有的收集器在执行GC的整个过程中都需要Stop The World，即不允许工作线程在GC的时候运行。</em></p><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><blockquote><blockquote><p>遇到的绝大部分server一般都是采用ParNew + CMS 收集器策略。 </p></blockquote></blockquote><p>CMS收集器目标是获取最短停顿时间的收集器，所以和上面的收集器不同，虽然其也会<code>Stop The World</code>，但是在有些阶段是可以并发进行的。因此，特别适合用户交互场景的服务系统。</p><p>CMS 主要分为4个阶段：</p><ul><li>初始化标记(STW)：标记GC Roots可以直接关联到的对象，速度非常快。</li><li>并发标记：进行GC Roots Tracing的过程。</li><li>重新标记(STW)：修正在并发标记期间工作线程操作导致变更的部分对象的标记记录。</li><li>并发清除。</li></ul><p>上面四个步骤中，1和3是需要暂停工作线程的。</p><p>由于在实际中，应用特别多，所以这里具体分析下CMS收集器。</p><p>【<a href="http://www.cnblogs.com/zhguang/p/3257367.html">Java系列笔记(3) - Java 内存区域和GC机制</a>】</p><p>CMS收集的执行过程是：初始标记(CMS-initial-mark) -&gt; 并发标记(CMS-concurrent-mark) –&gt;预清理(CMS-concurrent-preclean)–&gt;可控预清理(CMS-concurrent-abortable-preclean)-&gt; 重新标记(CMS-remark) -&gt; 并发清除(CMS-concurrent-sweep) -&gt;并发重设状态等待下次CMS的触发(CMS-concurrent-reset)<br>具体的说，先2次标记，1次预清理，1次重新标记，再1次清除。 </p><ol><li>首先jvm根据-XX:CMSInitiatingOccupancyFraction，-XX:+UseCMSInitiatingOccupancyOnly来决定什么时间开始垃圾收集；</li><li>如果设置了-XX:+UseCMSInitiatingOccupancyOnly，那么只有当old代占用确实达到了-XX:CMSInitiatingOccupancyFraction参数所设定的比例时才会触发cms gc；</li><li>如果没有设置-XX:+UseCMSInitiatingOccupancyOnly，那么系统会根据统计数据自行决定什么时候触发cms gc；因此有时会遇到设置了80%比例才cms gc，但是50%时就已经触发了，就是因为这个参数没有设置的原因；</li><li>当cms gc开始时，首先的阶段是初始标记(CMS-initial-mark)，是stop the world阶段，因此此阶段标记的对象只是从root集最直接可达的对象；<br>  CMS-initial-mark：961330K（1572864K），指标记时，old代的已用空间和总空间</li><li>下一个阶段是并发标记(CMS-concurrent-mark)，此阶段是和应用线程并发执行的，所谓并发收集器指的就是这个，主要作用是标记可达的对象，此阶段不需要用户停顿。<pre><code>此阶段会打印2条日志：CMS-concurrent-mark-start，CMS-concurrent-mark</code></pre></li><li>下一个阶段是CMS-concurrent-preclean，此阶段主要是进行一些预清理，因为标记和应用线程是并发执行的，因此会有些对象的状态在标记后会改变，此阶段正是解决这个问题因为之后的Rescan阶段也会stop the world，为了使暂停的时间尽可能的小，也需要preclean阶段先做一部分工作以节省时间<br>  此阶段会打印2条日志：CMS-concurrent-preclean-start，CMS-concurrent-preclean</li><li>下一阶段是CMS-concurrent-abortable-preclean阶段，加入此阶段的目的是使cms gc更加可控一些，作用也是执行一些预清理，以减少Rescan阶段造成应用暂停的时间<br>  此阶段涉及几个参数：<br>  -XX:CMSMaxAbortablePrecleanTime：当abortable-preclean阶段执行达到这个时间时才会结束<br>  -XX:CMSScheduleRemarkEdenSizeThreshold（默认2m）：控制abortable-preclean阶段什么时候开始执行，<br>   即当eden使用达到此值时，才会开始abortable-preclean阶段<br>  -XX:CMSScheduleRemarkEdenPenetratio（默认50%）：控制abortable-preclean阶段什么时候结束执行<br>   此阶段会打印一些日志如下：<br>  CMS-concurrent-abortable-preclean-start，CMS-concurrent-abortable-preclean，<br>   CMS：abort preclean due to time XXX</li><li>再下一个阶段是第二个stop the world阶段了，即Rescan阶段，此阶段暂停应用线程，停顿时间比并发标记小得多，但比初始标记稍长。对对象进行重新扫描并标记；<pre><code>YG occupancy：964861K（2403008K），指执行时young代的情况CMS remark：961330K（1572864K），指执行时old代的情况</code></pre>   此外，还打印出了弱引用处理、类卸载等过程的耗时</li><li>再下一个阶段是CMS-concurrent-sweep，进行并发的垃圾清理</li><li>最后是CMS-concurrent-reset，为下一次cms gc重置相关数据结构</li></ol><p>有2种情况会触发CMS 的悲观full gc，在悲观full gc时，整个应用会暂停<br>       A，concurrent-mode-failure：预清理阶段可能出现，当cms gc正进行时，此时有新的对象要进行old代，但是old代空间不足造成的。其可能性有：1，O区空间不足以让新生代晋级，2，O区空间用完之前，无法完成对无引用的对象的清理。这表明，当前有大量数据进入内存且无法释放。<br>       B，promotion-failed：新生代young gc可能出现，当进行young gc时，有部分young代对象仍然可用，但是S1或S2放不下，因此需要放到old代，但此时old代空间无法容纳此。</p><p>影响cms gc时长及触发的参数是以下2个：<br>        -XX:CMSMaxAbortablePrecleanTime=5000<br>        -XX:CMSInitiatingOccupancyFraction=80<br>解决也是针对这两个参数来的，根本的原因是每次请求消耗的内存量过大<br>解决方式：<br>      A，针对cms gc的触发阶段，调整-XX:CMSInitiatingOccupancyFraction=50，提早触发cms gc，就可以缓解当old代达到80%，cms gc处理不完，从而造成concurrent mode failure引发full gc<br>     B，修改-XX:CMSMaxAbortablePrecleanTime=500，缩小CMS-concurrent-abortable-preclean阶段的时间<br>     C，考虑到cms gc时不会进行compact，因此加入-XX:+UseCMSCompactAtFullCollection<br>       （cms gc后会进行内存的compact）和-XX:CMSFullGCsBeforeCompaction=4（在full gc4次后会进行compact）参数</p><p>在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。<br>CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。<br>另外，在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”，本次无法清理，只能下一次Full GC才清理，因此在GC期间，需要预留足够的内存给用户线程使用。所以使用CMS的收集器并不是老年代满了才触发Full GC，而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full GC，如果用户线程消耗内存不是特别大，可以适当调高-XX:CMSInitiatingOccupancyFraction以降低GC次数，提高性能，如果预留的用户线程内存不够，则会触发Concurrent Mode Failure，此时，将触发备用方案：使用Serial Old 收集器进行收集，但这样停顿时间就长了，因此-XX:CMSInitiatingOccupancyFraction不宜设的过大。<br>还有，CMS采用的是标记清除算法，会导致内存碎片的产生，可以使用-XX：+UseCMSCompactAtFullCollection来设置是否在Full GC之后进行碎片整理，用-XX：CMSFullGCsBeforeCompaction来设置在执行多少次不压缩的Full GC之后，来一次带压缩的Full GC。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> GC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ourea-基于Zookeeper的Thrift服务发现框架实现</title>
      <link href="2016/04/29/2016-04-29-thrift-service-discory-using-zookeeper-ourea/"/>
      <url>2016/04/29/2016-04-29-thrift-service-discory-using-zookeeper-ourea/</url>
      
        <content type="html"><![CDATA[<h2 id="框架背景"><a href="#框架背景" class="headerlink" title="框架背景"></a><a id="Introduction">框架背景</a></h2><p>Apache Thrift是Facebook实现的一种高效的,支持多种编程语言的远程服务调用的框架.在多语言并行于业务之中的公司,其是一个很好的RPC框架选择,但是由于缺少服务发现管理功能,在使用的时候,需要告知业务方现有业务部署的地址,并且调用方需要自己实现服务状态的感知和重试机制.此外,对于互联网公司而言,业务快速变化必然导致机器的增减,这些变化,需要通知到所有调用方来更改调用机器的配置,是非常麻烦的.</p><p>显然，对于Thrift来说，一个服务发现管理框架是多么的重要。</p><p>那么，服务发现管理框架其实可以做的很重，也可以做的很轻；对于我们，需要满足什么需求：</p><ul><li>服务调用方自动获取服务提供方地址；</li><li>服务提供方服务分组；</li><li>服务调用方负载均衡策略；</li><li>服务非兼容升级；</li></ul><p>具体的需求分析和实现，将在 <a href="#Ourea_Implement">Ourea服务发现实现原理</a>介绍。</p><h2 id="Thrift服务原生使用"><a href="#Thrift服务原生使用" class="headerlink" title="Thrift服务原生使用"></a><a id="Thrift_Native_Demo">Thrift服务原生使用</a></h2><p>Thrift 接口使用还是比较简单地，对外提供的server和client接口封装了所有的内部实现细节，所以，一般我们只需要告诉<code>Thrift</code>地址端口信息，然后就可以完成简单地RPC调用。</p><p>下面，给出一个简单地示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 服务端示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThriftServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SimpleThriftServer.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> port = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">simple</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TServerSocket tServerSocket = <span class="keyword">new</span> TServerSocket(port);</span><br><span class="line">            Hello.Processor processor = <span class="keyword">new</span> Hello.Processor(<span class="keyword">new</span> HelloService());</span><br><span class="line"></span><br><span class="line">            TServer server = <span class="keyword">new</span> TSimpleServer(<span class="keyword">new</span> TServer.Args(tServerSocket).processor(processor) );</span><br><span class="line">            server.serve();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            logger.error(<span class="string">&quot;server start error........&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SimpleThriftServer server = <span class="keyword">new</span> SimpleThriftServer();</span><br><span class="line">        server.simple(port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client 端示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThriftClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SimpleThriftClient.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> port = <span class="number">9999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ip = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TTransport transport = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transport = <span class="keyword">new</span> TSocket(ip, port);</span><br><span class="line">            TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</span><br><span class="line">            Hello.Client client = <span class="keyword">new</span> Hello.Client(protocol);</span><br><span class="line">            transport.open();</span><br><span class="line">            HelloResult result = client.sayHello(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;client invoke fail. &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (transport != <span class="keyword">null</span>) &#123;</span><br><span class="line">                transport.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>Note:</p><ul><li>TProtocol 协议和编解码组件</li><li>TTransport 传输通信组件</li><li>TProcessor 服务处理相关组件</li><li>TServer 服务提供组件</li><li>Client 服务调用客户端</li></ul></blockquote></blockquote><p>Thrift 原生的对外接口已经很简单了，但是为什么还需要去封装呢？上文的代码虽然简单，但是有几个点需要去注意：</p><ol><li>对于生产环境的服务，在发布新功能，出现故障down机，都会导致服务出现不可用的情况；此外，对外的服务一般都是集群部署，集群机器的增减也是很可能会出现的事情，因此，就会出现最初对外提供的服务IP地址会出现新增(新建服务)，减少(缩减服务)，暂时停服(机器故障)，这些所有变更通知所有业务服务调用方去更改是很难处理的事情。此外，由于服务可能存在大量的机器列表，这些配置在业务代码中，本身也是不可取的。</li><li>服务调用的时候，可能存在某些服务当时负载过高，或者服务网络问题等导致服务调用策略需要调整。也就是在选择调用集群中某台机器的时候，每个业务都要自己去实现策略，这是不可取的。此外，对于服务的负载情况无法感知，即使是静态的服务提供权重都无法获取，导致了即使客户端自己实现均衡策略，由于缺少必要的数据支持，导致只能采用轮询和随机。</li><li>业务上，服务调用之间隔离，服务接口的灰度升级等，是比较常见的技术需求。Thrift 对外发布的服务的所有IP，对于调用方来说都是平等的，也就是，如果我需要将集群中某些机器进行接口的非兼容的灰度升级，或者某些机器独立出来给一些非常重要的业务使用。目前，这种场景，只能新加机器来解决了。</li><li>对于调用方Client的调用，每次都需要去创建连接，然后和server端交互，对于大请求场景下的应用，对性能的影响是很大的。创建connection对象，是很重的，需要进行池化。</li><li>……</li></ol><p>基于以上的一些原因，开发了基于<code>Zookeeper</code>的Thrift服务发现机制框架。</p><span id="more"></span><h2 id="Ourea服务发现实现原理"><a href="#Ourea服务发现实现原理" class="headerlink" title=" Ourea服务发现实现原理"></a><a id="Ourea_Implement"> Ourea服务发现实现原理</a></h2><p>服务发现机制，在很多RPC套件中都会提供。<code>Zookeeper</code>一直作为经典实现服务发现机制的底层服务，所以这里显然也是这样的。下面给出，实现的模块交互图：</p><img src="/images/2016/04/ourea.png" /><h3 id="交互说明"><a href="#交互说明" class="headerlink" title="交互说明"></a>交互说明</h3><p>在设计交互图中，<code>Server</code>服务提供方会在启动的时候，读取服务相关配置属性，比如版本号、组名等信息，以及注册<code>Zookeeper</code>地址及相关zk操作配置信息；然后根据配置去指定<code>Zookeeper</code>集群注册服务，其路径为<code>/ourea/service_name_xxx/group_yyy/version_zzz/provider/ip=mmm&amp;port=nnn&amp;weight=lll</code>,注册完成之后，就可以启动Thrift服务了；如果发现服务启动失败，则去<code>Zookeeper</code>上注销该路径节点。</p><p>服务调用方启动的时候，同样也会读取相关配置，然后去<code>Zookeeper</code>上注册服务调用信息，注册完了之后，服务调用方会去查询<code> /ourea/service_name_xxx/group_yyy/version_zzz/provider/</code>下地子节点列表，并且注册监听逻辑，等待子节点变更则触发重新查询操作。服务调用方拿到ip列表之后，就可以按照选择的选择策略来拿到指定服务器的连接去调用相关服务接口。</p><p>需要说明的是，由于服务调用方拿到服务提供方的地址列表后，其只会监听<code>Zookeeper</code>的变更通知，调用方是直接和服务方交互的，因此，当<code>Zookeeper</code>出现不可服务时，并不会影响Thrift的服务提供和调用交互。因此，也不会影响Thrift的性能。</p><h3 id="针对Thrift原生接口的解决方案"><a href="#针对Thrift原生接口的解决方案" class="headerlink" title="针对Thrift原生接口的解决方案"></a>针对Thrift原生接口的解决方案</h3><ol><li><p>服务扩张自动感知<br>当服务提供方的服务状态发生变更，比如新加机器扩展，或者服务发布上下线等，会自动在指定路径创建一个临时节点，节点包含机器相关信息，利用<code>Zookeeper</code>的临时节点特性来实现服务状态自动感知功能。</p></li><li><p>服务调用负载策略<br>目前，ourea 也只支持方法级轮询策略和权重随机分布策略。服务会记录某个方法上次调用情况，然后从服务list中找出这次选择的机器进行服务调用。权重随机分布，是根据服务提供方在服务启动的时候，配置的机器权重来计算，权重大的服务机器，被选择的几率大于权重小的服务提供者。</p></li><li><p>服务提供粒度细化<br>服务隔离保证重要业务调用方不被其他业务干扰；此外，由于前期设计的问题，需要对部分接口进行非兼容升级(虽然我们非常不提倡这种行为)，这些问题都需要对服务提供进行细化隔离。因此，在ourea中，增加了<code>group</code>和<code>version</code>的控制。在server端，初始都是为默认的group提供服务，当存在某个重要的业务需要抗干扰服务级别时，下面一些机器，配置为特定group给改业务调用，这时，其他业务是无法自动获取到这些服务提供者地址的，从而到达服务隔离的目的。</p></li><li><p>Thrift连接池化<br>java client端，会对获取到得服务提供者地址列表分别创建对应的socket连接池，保证经过策略选择到指定机器后，可以直接和服务端交互。</p></li></ol><h2 id="Ourea服务发现框架使用示例"><a href="#Ourea服务发现框架使用示例" class="headerlink" title=" Ourea服务发现框架使用示例"></a><a id="Ourea_Demo"> Ourea服务发现框架使用示例</a></h2><p>使用ourea框架非常简单，生成jar包，引入到项目，然后如下调用方法即可完成Thrift交互。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkThriftServerSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Ourea.Processor.class.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        Properties properties = PropertiesUtils.load(<span class="string">&quot;provider.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ThriftServerConfig config = <span class="keyword">new</span> ThriftServerConfig(Integer.valueOf(properties.getProperty(<span class="string">&quot;port&quot;</span>)));</span><br><span class="line">        config.setGroup(properties.getProperty(<span class="string">&quot;group&quot;</span>));</span><br><span class="line">        ServiceProviderFactory.exposeService(<span class="keyword">new</span> OureaImpl(), <span class="keyword">new</span> ZkConfig(properties.getProperty(<span class="string">&quot;zkAddress&quot;</span>)),</span><br><span class="line">                config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkThriftClientSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Properties properties = PropertiesUtils.load(<span class="string">&quot;consumer.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Ourea.Iface client = ConsumerProxyFactory.getProxyClient(Ourea.Iface.class,</span><br><span class="line">        <span class="keyword">new</span> ZkConfig(properties.getProperty(<span class="string">&quot;zkAddress&quot;</span>)));</span><br><span class="line">    <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">while</span> (count++ &lt;<span class="number">1000</span>)&#123;</span><br><span class="line">      System.out.println(count + <span class="string">&quot;-----&quot;</span> + client.queryEcho(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务最少配置如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#zookeeper注册地址</span></span><br><span class="line"><span class="attr">zkAddress</span>=<span class="string">10.10.33.134:2181</span></span><br><span class="line"><span class="comment">#zookeeper超时时间</span></span><br><span class="line"><span class="attr">zkTimeout</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对外提供服务端口号</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">9999</span></span><br><span class="line"><span class="comment">#zookeeper注册地址</span></span><br><span class="line"><span class="attr">zkAddress</span>=<span class="string">10.10.33.134:2181</span></span><br><span class="line"><span class="comment">#zookeeper超时时间</span></span><br><span class="line"><span class="attr">zkTimeout</span>=<span class="string">3000</span></span><br><span class="line"><span class="comment">#服务细分的组/topic</span></span><br><span class="line"><span class="attr">group</span>=<span class="string">bbb</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title=" 总结"></a><a id="Summary"> 总结</a></h2><p>项目源码开源地址：<a href="https://github.com/ketao1989/ourea">https://github.com/ketao1989/ourea</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Thrift </category>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于JUnit Mockito Guice测试实践及JUnit运行机制浅析</title>
      <link href="2016/03/10/2016-03-10-junit-mockito-guice-in-action-and-junit-test-mechanism/"/>
      <url>2016/03/10/2016-03-10-junit-mockito-guice-in-action-and-junit-test-mechanism/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Introduction">前言</a></h2><p>对于一个合格的项目来说,单元测试是必不可少的一部分。尤其是，如果对于TDD思想来说，单元测试则是整个项目开发的基石。对于Javaer来说,Junit 是一个基础的单元测试框架.对于Spring框架来说, 其实现了JUnit的接口来直接支持单元测试, 但是对于Guice来说, 其定位为一个轻量级的依赖注入框架, 所以这些就需要自己来实现. 此外, 对于依赖外部的接口服务的应用, 我们在测试的时候, 是不希望其服务的不稳定导致我们单测失败; 此外, 对外部接口进行屏蔽, 也可以达到对每一个外部服务返回逻辑分支的覆盖.</p><p>因此，本文基于<code>JUnit + Mockito + Guice</code>框架说，然后基于简单地实例来说明JUnit的运行机制。</p><h2 id="单元测试实践"><a href="#单元测试实践" class="headerlink" title=" 单元测试实践"></a><a id="Action"> 单元测试实践</a></h2><p>Guice 作为一个注入框架，和Spring相比，并没有什么特别的。使用Guice介绍单元测试，其一是项目开发中使用Guice，其二由于我们需要去自己实现JUnit接口来支持Guice，能够更深入地了解JUnit结构。Mockito 是java中我比较喜欢的mock工具，当然，我也没有用过其他的。O(∩_∩)O~</p><p>首先，需要引入两个实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tao.ke Date: 16/3/9 Time: 下午4:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuiceJUnitRunner</span> <span class="keyword">extends</span> <span class="title">BlockJUnit4ClassRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Injector injector;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">    <span class="meta">@Inherited</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> GuiceModules &#123;</span><br><span class="line">        Class&lt;?&gt;[] value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">super</span>.createTest();</span><br><span class="line">        injector.injectMembers(obj);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GuiceJUnitRunner</span><span class="params">(Class&lt;?&gt; klass)</span> <span class="keyword">throws</span> InitializationError </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(klass);</span><br><span class="line">        Class&lt;?&gt;[] classes = getModulesFor(klass);</span><br><span class="line">        injector = createInjectorFor(classes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Injector <span class="title">createInjectorFor</span><span class="params">(Class&lt;?&gt;[] classes)</span> <span class="keyword">throws</span> InitializationError </span>&#123;</span><br><span class="line">        Module[] modules = <span class="keyword">new</span> Module[classes.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                modules[i] = (Module) (classes[i]).newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InitializationError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Guice.createInjector(modules);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] getModulesFor(Class&lt;?&gt; klass) <span class="keyword">throws</span> InitializationError &#123;</span><br><span class="line">        GuiceModules annotation = klass.getAnnotation(GuiceModules.class);</span><br><span class="line">        <span class="keyword">if</span> (annotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Class[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> annotation.value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>GuiceJUnitRunner 实现了JUnit框架<code>BlockJUnit4ClassRunner</code>接口，Runner是JUnit的核心，所有测试的运行，最后都是Runner来衔接运作起来的。在<code>JuiceJUnitRunner</code>中，我们根据annotation来初始化Guice环境需要的一些初始化配置，拦截器等；此外，熟悉Guice的同学知道，其有一个非常不好的体验，就是需要在最外层手动注入实例调用服务，这里我们希望可以直接注入service实例，因此在Runner初始化时完成这一动作。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tao.ke Date: 16/3/9 Time: 下午4:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(GuiceJUnitRunner.class)</span></span><br><span class="line"><span class="meta">@GuiceJUnitRunner</span>.GuiceModules(&#123; GuiceModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局初始化，加载数据库配置，注入拦截器等</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuiceModule</span> <span class="keyword">implements</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Binder binder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//binder.bind(GuiceBiz.class);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BaseTest</code>是一个基础的测试类，完成所有测试共同的工作。各个测试类可以继承该基类，然后就可以最简单的关注业务逻辑的测试。比如，下面这个测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuiceUnitSampleTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> GuiceBiz guiceBiz;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConcatString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//就是一个简单地测试而已</span></span><br><span class="line">        System.out.println(guiceBiz.concatString(<span class="string">&quot;ktcoder&quot;</span>,<span class="string">&quot;hello,&quot;</span>));</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;hello,ktcoder&quot;</span>,guiceBiz.concatString(<span class="string">&quot;ktcoder&quot;</span>,<span class="string">&quot;hello,&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，来一个复杂的测试case，这里，我们调用的外部的服务，比如数据库查询，或者其他RPC服务等等，但是我们只想测试自己的业务分支是否运行正常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuiceUnitMockSampleTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> GuiceBiz guiceBiz;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> GuiceServiceImpl guiceServiceImpl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetRoleAdmin</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Mockito.when(guiceServiceImpl.getRole(Matchers.anyString())).thenReturn(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;hello Admin&quot;</span>,guiceBiz.helloRole(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetRoleGuest</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Mockito.when(guiceServiceImpl.getRole(Matchers.anyString())).thenReturn(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;hello Guest&quot;</span>,guiceBiz.helloRole(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuiceBiz</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> GuiceServiceImpl guiceServiceImpl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloRole</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String res = guiceServiceImpl.getRole(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(res))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + <span class="string">&quot;Guest&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + <span class="string">&quot;Admin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的case可以看到，不管外部的GuiceServiceImpl是如何处理的，是否服务可靠都无所谓。我们只需要关注自己的业务逻辑，然后mock掉外部的接口，这样就可以更好地覆盖各个逻辑分支了。</p><h2 id="JUnit-运行浅析"><a href="#JUnit-运行浅析" class="headerlink" title=" JUnit 运行浅析"></a><a id="Flow"> JUnit 运行浅析</a></h2><p>一般在开发的时候，我们都使用idea 或者 eclipse 来运行测试用例，那么对于可运行的java代码，必然有一个main方法入口。</p><h3 id="idea-JUnit-主方法入口"><a href="#idea-JUnit-主方法入口" class="headerlink" title="idea JUnit 主方法入口"></a>idea JUnit 主方法入口</h3><p>在 idea 中存在一个<code>JUnitStarter</code>类，该类就有一个main方法，也就是说，当我们在idea ide工具中点击执行test方法时，实际上执行的就是这个类的入口方法。</p><p>main 方法很简单，就是准备输入输出流，一些参数准备，然后调用<code>prepareStreamsAndStart</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prepareStreamsAndStart</span><span class="params">(String[] args, <span class="keyword">final</span> <span class="keyword">boolean</span> isJUnit4, ArrayList listeners, SegmentedOutputStream out, SegmentedOutputStream err)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PrintStream oldOut = System.out;</span><br><span class="line">    PrintStream oldErr = System.err;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.setOut(<span class="keyword">new</span> PrintStream(out));</span><br><span class="line">      System.setErr(<span class="keyword">new</span> PrintStream(err));</span><br><span class="line">      IdeaTestRunner testRunner = (IdeaTestRunner)getAgentClass(isJUnit4).newInstance();</span><br><span class="line">      testRunner.setStreams(out, err);</span><br><span class="line">      result = testRunner.startRunnerWithArgs(args, listeners);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为我们使用的是JUnit4，所以会接着调用 <code>JUnit4IdeaTestRunner</code>类，在这个类中将直接和JUnit的相关接口交互，调用相关方法，进入到具体的JUnit测试中。该类首先构造JUnit工具中需要的Request类，通过Request可以获取Runner实例，然后开始运行测试case。<br>比如我们这里需要运行的时Test类中得一个方法，所以这里列出对应的处理逻辑代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// suiteClassNames[0]=&quot;io.github.ketao1989.guice.GuiceUnitSampleTest,testConcatString&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Request <span class="title">buildRequest</span><span class="params">(String[] suiteClassNames, <span class="keyword">final</span> String name, <span class="keyword">boolean</span> notForked)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (suiteClassNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Vector result = <span class="keyword">new</span> Vector();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; suiteClassNames.length; i++) &#123;</span><br><span class="line">        String suiteClassName = suiteClassNames[i];</span><br><span class="line">        <span class="keyword">int</span> index = suiteClassName.indexOf(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class clazz = loadTestClass(suiteClassName.substring(<span class="number">0</span>, index));</span><br><span class="line">            <span class="keyword">final</span> String methodName = suiteClassName.substring(index + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">final</span> RunWith clazzAnnotation = (RunWith)clazz.getAnnotation(RunWith.class);</span><br><span class="line">            <span class="keyword">final</span> Description testMethodDescription = Description.createTestDescription(clazz, methodName);</span><br><span class="line">            <span class="keyword">final</span> Request request = getParameterizedRequest(name, methodName, clazz, clazzAnnotation);/反射构造runner及<span class="function">request</span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(request != <span class="keyword">null</span>)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> request;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造完了Request，然后就可以通过new 一个 JUnitCore对象来运行request中得runner了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">startRunnerWithArgs</span><span class="params">(String[] args, ArrayList listeners, String name, <span class="keyword">boolean</span> sendTree)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Request request = JUnit4TestRunnerUtil.buildRequest(args, name, sendTree);</span><br><span class="line">    <span class="keyword">final</span> Runner testRunner = request.getRunner();</span><br><span class="line">    Description description = getDescription(request, testRunner);</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">final</span> JUnitCore runner = <span class="keyword">new</span> JUnitCore();</span><br><span class="line">    <span class="keyword">return</span> runner.run(testRunner);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的<code>startRunnerWithArgs</code>方法中会设置一些监听器负责收集运行成功失败的结果，开始结束运行等，为了了解整个运行流程，就不分析了。</p><h3 id="Request-构建-Runner"><a href="#Request-构建-Runner" class="headerlink" title="Request 构建 Runner"></a>Request 构建 Runner</h3><p>从上面的代码中看到，idea 是通过buildRequest来获取 Runner的。实际上，Request 就是一个RunnerBuilder构建工具，默认有三种实现：<code>FilterRequest</code>、<code>ClassRequest</code>和<code>SortingRequest</code>，顾名思义了，核心自然是 ClassRequest。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassRequest</span> <span class="keyword">extends</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object runnerLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; fTestClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> canUseSuiteMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Runner runner;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Runner <span class="title">getRunner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (runner == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (runnerLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (runner == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    runner = <span class="keyword">new</span> AllDefaultPossibilitiesBuilder(canUseSuiteMethod).safeRunnerForClass(fTestClass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> runner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从<code>getRunner</code>方法中可以知道这里根据需要测试的类 fTestClass 来构造runner. </p><blockquote><blockquote><p>Notes:这里使用fTestClass明明变量，竟然是因为在idea的调用代码中使用<code>field = ClassRequest.class.getDeclaredField(&quot;fTestClass&quot;);</code>,所以无法更改成正常的testClass.</p></blockquote></blockquote><p>  AllDefaultPossibilitiesBuilder类是一个builder的总入口，其会根据配置选择正确的RunnerBuilder构建Runner对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllDefaultPossibilitiesBuilder</span> <span class="keyword">extends</span> <span class="title">RunnerBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> canUseSuiteMethod;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AllDefaultPossibilitiesBuilder</span><span class="params">(<span class="keyword">boolean</span> canUseSuiteMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.canUseSuiteMethod = canUseSuiteMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从这个方法可以看出构造器的优先级，构造器会一个一个尝试，直到找到正确地为止，一般使用注解方式指定Runner</span></span><br><span class="line">    <span class="comment">// 所以这里介绍annotatedBuilder.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Runner <span class="title">runnerForClass</span><span class="params">(Class&lt;?&gt; testClass)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        List&lt;RunnerBuilder&gt; builders = Arrays.asList(</span><br><span class="line">                ignoredBuilder(),</span><br><span class="line">                annotatedBuilder(),</span><br><span class="line">                suiteMethodBuilder(),</span><br><span class="line">                junit3Builder(),</span><br><span class="line">                junit4Builder());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (RunnerBuilder each : builders) &#123;</span><br><span class="line">            Runner runner = each.safeRunnerForClass(testClass);</span><br><span class="line">            <span class="keyword">if</span> (runner != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> runner;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据RunWith 注解获取Runner类，然后反射实例化一个对象出来，即：</span></span><br><span class="line">    <span class="comment">// runnerClass.getConstructor(Class.class).newInstance(testClass);</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AnnotatedBuilder <span class="title">annotatedBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotatedBuilder(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JUnitCore-运行-Runner"><a href="#JUnitCore-运行-Runner" class="headerlink" title="JUnitCore 运行 Runner"></a>JUnitCore 运行 Runner</h3><p>JUnitCore 是对 JUnit的Runner类的一个Fecade，兼容3.x和4.x的不同runner的运行，同时，可以在command中执行命令<code>java org.junit.runner.JUnitCore TestClass1 TestClass2</code> 运行测试用例。</p><p>此外，作为Facade来说，其在调用runner的run方法时，会再方法开始和结束的时候，触发相应地监听器，发布相关通知事件。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过命令运行，这就是入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    Result result = <span class="keyword">new</span> JUnitCore().runMain(<span class="keyword">new</span> RealSystem(), args);</span><br><span class="line">    System.exit(result.wasSuccessful() ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试case真正的运行方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">run</span><span class="params">(Runner runner)</span> </span>&#123;</span><br><span class="line">    Result result = <span class="keyword">new</span> Result();</span><br><span class="line">    RunListener listener = result.createListener();</span><br><span class="line">    notifier.addFirstListener(listener);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notifier.fireTestRunStarted(runner.getDescription());</span><br><span class="line">        runner.run(notifier);</span><br><span class="line">        notifier.fireTestRunFinished(result);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        removeListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>Notes: 这里特别说明下通知notify的实现，代码中创建一个<code>SafeNotifier</code>类，来发布一个通知，但是我们知道监听器不可能只有一个，因此，对于外部的调用来说，必须调用<code>SafeNotifier.run</code>方法，这个方法会依次遍历listeneres监听器列表，然后调用对应的方法触发监听事件。</p></blockquote></blockquote><p>在实现中，我们自己自定义了Runner方法为<code>GuiceJUnitRunner</code>继承了<code>ParentRunner</code>,所以，我们直接看其run方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> RunNotifier notifier)</span> </span>&#123;</span><br><span class="line">    Statement statement = classBlock(notifier);</span><br><span class="line">    statement.evaluate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里只分析最简单的方法调用，before和after是单独实现了Statement子类，执行时根据</span></span><br><span class="line"><span class="comment">// 先后属性来决定先执行test方法还是先运行before class工作</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Statement <span class="title">classBlock</span><span class="params">(<span class="keyword">final</span> RunNotifier notifier)</span> </span>&#123;</span><br><span class="line">    Statement statement = childrenInvoker(notifier);</span><br><span class="line">    <span class="keyword">if</span> (!areAllChildrenIgnored()) &#123;</span><br><span class="line">        statement = withBeforeClasses(statement);</span><br><span class="line">        statement = withAfterClasses(statement);</span><br><span class="line">        statement = withClassRules(statement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// statement其实就是对需要执行动作的一个封装，其真正的动作就是调用evaluate方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Statement <span class="title">childrenInvoker</span><span class="params">(<span class="keyword">final</span> RunNotifier notifier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Statement() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evaluate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runChildren(notifier);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两个是实现很有意思。对于RunnerScheduler来说，字面意思就是调度，因此，其是针对不同的调用策略，执行动作的接口</span></span><br><span class="line"><span class="comment">// 当然这里，我们直接调用运行，然后执行完所有测试的case方法之后，调用finished动作。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runChildren</span><span class="params">(<span class="keyword">final</span> RunNotifier notifier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RunnerScheduler currentScheduler = scheduler;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> T each : getFilteredChildren()) &#123;</span><br><span class="line">            currentScheduler.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    ParentRunner.<span class="keyword">this</span>.runChild(each, notifier);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentScheduler.finished();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RunnerScheduler scheduler = <span class="keyword">new</span> RunnerScheduler() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(Runnable childStatement)</span> </span>&#123;</span><br><span class="line">        childStatement.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实，根据 <code>ParentRunner</code>类的代码，基本上已经能够很清晰的明白了运行测试case的流程。其流程就是：首先，我们拿到测试类中所有需要执行的test方法；然后，把测试类中需要执行的test方法封装为一个执行动作，这个动作就是分别运行各个子方法，这些方法的执行则是根据RunnerScheduler内部的调度执行策略来的。</p><p>所以，根据上面的代码，发现其实有两个方法，是需要子类去实现的，其一是怎么获取测试类中需要test的方法，其二就是如果执行这些方法，之所以会如此，是因为<code>ParentRunner</code>这个类除了针对测试类里地方法，还针对测试包下面各种测试类，所以不同的情形，其处理逻辑是不一样的。针对包Suite，其会继续遍历解析，知道拆分成测试类，对应下面的测试方法FrameworkMethod，然后调用针对测试类的处理逻辑执行。</p><h3 id="GuiceJUnitRunner-继承-BlockJUnit4ClassRunner"><a href="#GuiceJUnitRunner-继承-BlockJUnit4ClassRunner" class="headerlink" title="GuiceJUnitRunner 继承 BlockJUnit4ClassRunner"></a>GuiceJUnitRunner 继承 BlockJUnit4ClassRunner</h3><p>如上所述，<code>ParentRunner</code> 关注的两个方法，需要在子类去实现。</p><p>获取需要test的方法，这个显然 BlockJUnit4ClassRunner 就可以给出具体实现，即根据<code>@Test</code>注解来获取测试类中需要执行test的方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// getTestClass 获取的就是需要执行的测试类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;FrameworkMethod&gt; <span class="title">computeTestMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getTestClass().getAnnotatedMethods(Test.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而，另外一个问题就是如何执行测试方法。其实现也很简单，就是首先构造测试类实例，然后根据具体的测试方法，依次通过menthod.invoke调用执行就可以了。而针对构造类实例，由于Guice获取方式是通过注入，所以是需要覆盖重写的。因此，我们看父类BlockJUnit4ClassRunner代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">runChild</span><span class="params">(<span class="keyword">final</span> FrameworkMethod method, RunNotifier notifier)</span> </span>&#123;</span><br><span class="line">    Description description = describeChild(method);</span><br><span class="line">    <span class="keyword">if</span> (isIgnored(method)) &#123;</span><br><span class="line">        notifier.fireTestIgnored(description);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// runLeaf 核心动作就是 statement.evaluate()</span></span><br><span class="line">        runLeaf(methodBlock(method), description, notifier);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面createTest就是需要实例化一个测试类对象了，然后再构造一个 methodInvoker 对象，methodInvoker</span></span><br><span class="line"><span class="comment">// 从名字就可看出来其作用就是为了反射执行method方法。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Statement <span class="title">methodBlock</span><span class="params">(FrameworkMethod method)</span> </span>&#123;</span><br><span class="line">    Object test = <span class="keyword">new</span> ReflectiveCallable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">runReflectiveCall</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> createTest();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;.run();</span><br><span class="line">    <span class="comment">// 实际上就是方法执行 method.invoke(test, params)</span></span><br><span class="line">    Statement statement = methodInvoker(method, test);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ok，整个流程基本上就已经分析清楚了。此外，需要注意的是，对于继承实现Runner来说，其构造函数是带有一个testClass的参数的。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GuiceJUnitRunner</span><span class="params">(Class&lt;?&gt; klass)</span> <span class="keyword">throws</span> InitializationError </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(klass);</span><br><span class="line">    Class&lt;?&gt;[] classes = getModulesFor(klass);</span><br><span class="line">    injector = createInjectorFor(classes);<span class="comment">//创建一个injector，在createTest中，使用该injector来注入类中得各种依赖</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="遗留问题和总结"><a href="#遗留问题和总结" class="headerlink" title="遗留问题和总结"></a><a id="Problem_and_Summary">遗留问题和总结</a></h2><p>本文主要是基于Guice+JUnit+Mockito来构建一个单元测试实践，然后简要分析了JUnit的源码运行逻辑，但是并没深入到源码的细节。但是不得不说，JUnit不仅仅是一个非常优秀的测试框架，而且其代码结构和实现也非常的优美和可扩展，非常值得学习和借鉴。</p><p>后面有机会，会更深入分析其内部的实现细节，以及一些非常值得借鉴的代码设计思想。</p>]]></content>
      
      
      <categories>
          
          <category> JUnit </category>
          
          <category> Guice </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于kafka的定时消息/任务服务</title>
      <link href="2016/01/02/2016-01-02-delayed-message-consume-service-use-kafka/"/>
      <url>2016/01/02/2016-01-02-delayed-message-consume-service-use-kafka/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Introduction">前言</a></h2><p>定时任务,在很多业务场景中都会存在.一般,我们简单解决的话,就是使用数据库来存储数据供服务端周期获取执行.显然,对于数据库处理,如果多线程或者多机器处理,就会存在扩展的问题.比如:现在一个任务记录到时间了需要执行,同时被多个executor抓取来执行,就会浪费不必要的资源;并且,这种场景还非常常见. 因此, 需要额外状态处理,或者其他分库分表策略保证尽量一个executor来操作一个记录,并且如果executor失败了,其他的executor才会去执行分配给失败executor的任务. 整个设计相对而言,就相当复杂了.</p><p>基于上面的一些原因,这里我们设计了一个简单的基于kafka消息队列的定时任务方案.</p><p>这里，首先定义一下定时消息。所谓定时消息，就是业务方根据自己的业务需求，指定在接下来的大概某个时间点来发送某条消息，从而保证该消息在某个时间点之后可接受的时间区间内消费该消息。所以这里需要指出：</p><blockquote><blockquote><p>Note:<br>消息机制都是异步的，所以如果存在大量消息累积未消费，则无法保证定时消息指定的时间区间。因此，使用的时候，必须预计定时消息服务提供的服务能否满足业务的QPS要求。定时消息服务设计保证支持水平扩展，因此，可以根据业务性能需求，部署足够的服务。</p></blockquote></blockquote><p>kafka消息队列，所有触发都是基于消息机制的。所以，定时任务的设计必须要有定时消息服务来提供基础核心功能。首先，就需要设计一个基于kafka队列的定时消息服务。</p><span id="more"></span><h2 id="定时消息服务总体设计"><a href="#定时消息服务总体设计" class="headerlink" title="定时消息服务总体设计"></a><a id="Delayed_Message_Service_Design">定时消息服务总体设计</a></h2><p>定时消息服务，这里主要是服务于定时任务设计的；但是，这不意味着它不能单独提供服务。相反，定时消息服务设计时，考虑是单独部署，单独提供服务的。而定时任务，是基于定时消息服务进行封装的client端，便于没有kafka或者其他消息队列的开发者，可以直接使用，而不需要额外学习kafka的使用，虽然其接口很简便。</p><p>首先，给出定时消息服务整体的交互图：</p><img src="/images/2016/01/dms.png" /><p>从以上的交互图可以看到，业务方produce的定时消息，其 topic 是让 定时消息服务单独consume的；然后kafka-dms 服务将业务方produce生成的消息进行解析处理，剥离出真实的topic和payload，以及可能有的partitioner。拿到真实业务的消息，kafka-dms就可以根据业务的要求，延迟到指定的时间去produce kafka消息。这样，真实的业务consumer就可以在指定时间后消费定时消息。</p><p>整个交互并不复杂，简洁满足需求，可以更容易的后期维护。</p><p>和很多同学一样，简洁的设计并不意味着实现起来就简单。在实现过程中，考虑到业务的需求，以及开发的成本，做了一些折中权衡。</p><h2 id="定时消息服务具体设计与关键实现"><a href="#定时消息服务具体设计与关键实现" class="headerlink" title="定时消息服务具体设计与关键实现"></a><a id="Delayed_Message_Service_Implement">定时消息服务具体设计与关键实现</a></h2><p>在实现的时候，为了简单且满足需求，对于开发遇到的一些问题，进行了处理和简化。</p><h3 id="定时时间限制"><a href="#定时时间限制" class="headerlink" title="定时时间限制"></a>定时时间限制</h3><p>由于每个业务对于需要延迟多长时间来让消费者消费消息是多种多样的，此外，基于定时消息模式处理的业务，对于时间的精准性要求并不是很高。比如，存在一个业务场景，调用外部的异步接口，接口只会告知调用已接受并处理，但是处理结果一般是通过异步回调的方式来告知；但是由于回调未必会成功，但是业务一直处于中间状态，这个时候是需要通过查询机制来获取真实状态，完成状态调整的。这种场景，是不会对定时执行时间要求很高的，一般其只需要在约定业务处理时间后的某个时间触发即可。</p><p>基于很多上面类似场景的情况，这里我们对定时时间进行限制。也就是，业务方只能在指定的延迟时间来选择。当然，这里的延迟时间是可以根据具体使用来具体调整的。默认，我们的延迟时间级别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">MsgDelayedLevel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1MS 主要服务异步任务</span></span><br><span class="line">    ONE_MS_DELAYED(<span class="number">0</span>,<span class="number">1L</span>),</span><br><span class="line">    <span class="comment">// 1秒</span></span><br><span class="line">    ONE_S_DELAYED(<span class="number">1</span>, <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 5秒</span></span><br><span class="line">    FIVE_S_DELAYED(<span class="number">2</span>, <span class="number">5</span> * <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 10秒</span></span><br><span class="line">    TEN_S_DELAYED(<span class="number">3</span>, <span class="number">10</span> * <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 20秒</span></span><br><span class="line">    TWENTY_S_DELAYED(<span class="number">4</span>, <span class="number">20</span> * <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 30秒</span></span><br><span class="line">    THIRTY_S_DELAYED(<span class="number">5</span>, <span class="number">30</span> * <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 1分钟</span></span><br><span class="line">    ONE_M_DELAYED(<span class="number">6</span>, <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 5分钟</span></span><br><span class="line">    FIVE_M_DELAYED(<span class="number">7</span>, <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 10分钟</span></span><br><span class="line">    TEN_M_DELAYED(<span class="number">8</span>, <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 20分钟</span></span><br><span class="line">    TWENTY_M_DELAYED(<span class="number">9</span>, <span class="number">20</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 30分钟</span></span><br><span class="line">    THIRTY_M_DELAYED(<span class="number">10</span>, <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 1小时</span></span><br><span class="line">    ONE_H_DELAYED(<span class="number">11</span>, <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 2小时</span></span><br><span class="line">    TWO_H_DELAYED(<span class="number">12</span>, <span class="number">2</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 3小时</span></span><br><span class="line">    THREE_H_DELAYED(<span class="number">13</span>, <span class="number">3</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 6小时</span></span><br><span class="line">    SIX_H_DELAYED(<span class="number">14</span>, <span class="number">6</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 12小时</span></span><br><span class="line">    TWELVE_H_DELAYED(<span class="number">15</span>, <span class="number">12</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 1天</span></span><br><span class="line">    ONE_D_DELAYED(<span class="number">16</span>, <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">    <span class="comment">// 2天</span></span><br><span class="line">    TWO_D_DELAYED(<span class="number">17</span>, <span class="number">2</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>),;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> delayedMs;</span><br><span class="line"></span><br><span class="line">    MsgDelayedLevel(<span class="keyword">int</span> level, <span class="keyword">long</span> delayedMs) &#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">        <span class="keyword">this</span>.delayedMs = delayedMs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Topic-细分"><a href="#Topic-细分" class="headerlink" title="Topic 细分"></a>Topic 细分</h3><p>延迟时间限制，很大的原因，是因为实现的时候，基于kafka的消息必须顺序消费，这就意味着，如果同一个topic的partitioner内，必须定时的时间都按照顺序排序的。否则，我们只能将所有队列的消息都拿出来消费，然后在内存中排序（万一down机就完了），或者保存在数据库中（又回到最初避免的问题上了）。</p><p>基于以上问题，我们对延迟时间进行了级别限制，然后这些级别反映到 Topic 上面。也就是，目前的设计中，我们对每个级别的延迟，都单独提供了一个 Topic 来处理。这就很好地规避了以上 kafka 特性而导致实现上的问题。</p><p>每个 topic 的对应的消息队列都是一个水平的超时时间，因此，后面进入到消息队列的消息，执行时间肯定是在前面消息之后的（不考虑不同服务器的网络差异问题）。这就意味着，如果前面消息未到处理时间，后面消息，肯定可以不需要处理。</p><p>Topic 生成规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_MSG_PREFIX = <span class="string">&quot;KAFKA_DELAYED_MSG_&quot;</span>;</span><br><span class="line">String topic = KafkaConstants.DELAYED_MSG_PREFIX + delayedLevel.getLevel()；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="延迟消息处理"><a href="#延迟消息处理" class="headerlink" title="延迟消息处理"></a>延迟消息处理</h3><p>从 kafka 消息队列中 pull到消息，按照约定的格式进行解析，然后进行处理，produce 真实的业务消息，push 到kafka消息队列中。当我们pull到的消息还未到定时时间，则阻塞等待时间，交给schedulerThread来执行，执行完了之后，会手动触发commit offset，从而消费对应partitioner的下一条消息。这里可能性能有问题，不过通过多部署实例和多partitioner来扩展。</p><p>核心的定时消息处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processHandler</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> MessageBody body, <span class="keyword">final</span> ConsumerConnector connector)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (body.getCurrentTime() &gt; now || body.getCurrentTime() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          body.setCurrentTime(now);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> diff = now - body.getCurrentTime() - DELAYED_LEVEL_MS_TIMES.get(key);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (diff &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              MsgProducerUtils.send(body.getTopic(), body.getPartitionNum(), body.getRealPayLoad());</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">              logger.error(<span class="string">&quot;producer params illegal. key:&#123;&#125;,body:&#123;&#125;,e:&quot;</span>, key, body, e);</span><br><span class="line">          &#125;</span><br><span class="line">          connector.commitOffsets();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          schedulerExecutor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  processHandler(key, body, connector);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, -diff, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基于定时消息的定时任务总体设计"><a href="#基于定时消息的定时任务总体设计" class="headerlink" title="基于定时消息的定时任务总体设计"></a><a id="Delayed_Task_Base_Message_Service_Design">基于定时消息的定时任务总体设计</a></h2><p>定时任务，实际上是基于定时消息封装的client客户端。业务方，引入对应的jar包后，调用相关的方法，就可以完成对某个类的某个方法进行调用。</p><p>由于定时任务主要是对调用方屏蔽掉使用生产kafka定时消息以及消费kafka消息带来的额外学习成本，因此，其主要提供两个方面的功能，produce 和 consume kafka消息。</p><p>基于定时消息的定时任务整体交互流程如下：</p><img src="/images/2016/01/dts.png" /><p>从交互图可以显然的看到，我们在client内定义了一个调用方法相关的数据结构，业务代码将该数据结构交给client，client根据该数据结构，构建topic，发送到kafka-dms服务上；然后client 根据业务配置的project.topic 来pull消息，反射执行方法，完成定时任务调用。</p><h2 id="基于定时消息的定时任务具体设计与关键实现"><a href="#基于定时消息的定时任务具体设计与关键实现" class="headerlink" title="基于定时消息的定时任务具体设计与关键实现"></a><a id="Delayed_Task_Base_Message_Service_Implement">基于定时消息的定时任务具体设计与关键实现</a></h2><p>定时任务client实现，其实质就是根据业务级别来封装处理kafka消息。一般的，对于这种需求，显然需要配置的kafka相关设置越少越好，因此为了使用简便，对于很多功能都省去。</p><h3 id="Broker-获取和-partitioner-获取"><a href="#Broker-获取和-partitioner-获取" class="headerlink" title="Broker 获取和 partitioner 获取"></a>Broker 获取和 partitioner 获取</h3><p>一般，对于producer使用中，需要设置broker list来告知kafka的服务地址。在client中，我们不希望业务方去了解设置这些。因此，需要通过代码获取broker地址。由于kafka的获取是scala实现，因此，这里首先使用java来重写，对java来进行调用。</p><p>同样，对于分区逻辑，业务方也不会关心（如果想保证先后顺序，即在一个分区内，可以通过数据结构的key来实现），业务需要根据topic去获取对应的实际分区数来达到分区效果。对于分区，kafka定时消息是根据业务方的key直接push到对应的业务消息分区的。</p><p>获取broker实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaZkUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(KafkaZkUtils.class);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BrokerIdsPath = <span class="string">&quot;/brokers/ids&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BrokerTopicsPath = <span class="string">&quot;/brokers/topics&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TopicConfigPath = <span class="string">&quot;/config/topics&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DeleteTopicsPath = <span class="string">&quot;/admin/delete_topics&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTopicPath</span><span class="params">(String topic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BrokerTopicsPath + <span class="string">&quot;/&quot;</span> + topic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTopicPartitionsPath</span><span class="params">(String topic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getTopicPath(topic) + <span class="string">&quot;/partitions&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取topic 分区. 由于构造CuratorFramework 成功很大,所以请缓存结果,或者使用下面的方法来获取</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zkAddress</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getPartitionsForTopic</span><span class="params">(String zkAddress, String topic)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(zkAddress, <span class="number">6000</span>, <span class="number">6000</span>, <span class="keyword">new</span> RetryForever(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> getPartitionsForTopic(client, topic);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getBrokers</span><span class="params">(String zkAddress)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(zkAddress, <span class="number">6000</span>, <span class="number">6000</span>, <span class="keyword">new</span> RetryForever(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> getBrokers(client);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取某个指定topic 的分区情况.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zkClient 已经start,并且close由其关闭</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getPartitionsForTopic</span><span class="params">(CuratorFramework zkClient, String topic)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> zkClient.getChildren().forPath(getTopicPartitionsPath(topic));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            logger.error(<span class="string">&quot;getPartitionsForTopic error.topic:&#123;&#125;, e:&quot;</span>, topic, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单需求的时候,可以使用,对应broker,一般使用zk的watch保存监听比较好</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zkClient</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getBrokers</span><span class="params">(CuratorFramework zkClient)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            List&lt;String&gt; brokerIds = zkClient.getChildren().forPath(BrokerIdsPath);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brokerIds == <span class="keyword">null</span> || brokerIds.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;String&gt; brokerHostInfo = Lists.newArrayList();</span><br><span class="line">            <span class="keyword">for</span> (String id : brokerIds) &#123;</span><br><span class="line"></span><br><span class="line">                String info = <span class="keyword">new</span> String(zkClient.getData().forPath(BrokerIdsPath + <span class="string">&quot;/&quot;</span> + id));</span><br><span class="line"></span><br><span class="line">                Map&lt;String, Object&gt; data = JsonUtils.decode(info, Map.class);</span><br><span class="line"></span><br><span class="line">                brokerHostInfo.add(data.get(<span class="string">&quot;host&quot;</span>) + <span class="string">&quot;:&quot;</span> + data.get(<span class="string">&quot;port&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> brokerHostInfo;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            logger.error(<span class="string">&quot;getBrokers error. e:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="client-调用业务接口"><a href="#client-调用业务接口" class="headerlink" title="client 调用业务接口"></a>client 调用业务接口</h3><p>在业务调用接口的时候，它需要把定时任务执行的方法和相关参数序列化，然后client pull到消息后，将这些信息通过反射机制来执行。</p><p>首先看一下，业务调用异步任务接口时，需要提供的数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedTaskProperty</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6227226019751603874L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classFullName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] args;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由规则的key,如果不设置,则随机路由到不同的分区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> routeKey;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后根据上面数据结构的信息，client的consumer端就可以来执行相应的方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理的核心逻辑,反射方式调用方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> property</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processHandler</span><span class="params">(DelayedTaskProperty property, ConsumerConnector connector)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = CLASS_MAP.get(property.getClassFullName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    clazz = ClassUtils.getClass(property.getClassFullName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;class reflect error.class:&#123;&#125; not find.e:&quot;</span>, property.getClassFullName(), e);</span><br><span class="line">                    connector.commitOffsets();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                CLASS_MAP.putIfAbsent(property.getClassFullName(), clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> 16/1/2 这里的异常等处理后续需要细化,确保有些额外异常不进行commit?</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Object target = clazz.newInstance();</span><br><span class="line">            Reflection.invokeN(clazz, property.getMethodName(), target, property.getArgs());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;e:&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connector.commitOffsets();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="遗留问题和总结"><a href="#遗留问题和总结" class="headerlink" title="遗留问题和总结"></a><a id="Problem_and_Summary">遗留问题和总结</a></h2><p>显然，这个基于kafka消息队列的定时消息，还可以完成其他一些需求。</p><p>目前的设计，还处在使用kafka完成我们需要的定时消息的功能，以及基于此的定时任务；其性能和设计上的优化，还有很多进步的空间，代码还没有进行优化和统一等等。</p><p>此外，对于client的使用，显然需要封装成jar包，然后给业务方引入。</p><p>具体的代码请参考：<a href="https://github.com/ketao1989/JavaApiUtilsProject/tree/master/src/main/java/io/github/ketao1989/scheduler">https://github.com/ketao1989/JavaApiUtilsProject/tree/master/src/main/java/io/github/ketao1989/scheduler</a></p><p>整体的项目在：<a href="mailto:&#103;&#105;&#116;&#64;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#103;&#105;&#116;&#64;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;</a>:ketao1989/JavaApiUtilsProject.git</p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper 编程指南</title>
      <link href="2015/09/05/2015-09-05-zookeeper-programmer-guide/"/>
      <url>2015/09/05/2015-09-05-zookeeper-programmer-guide/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Introduction">前言</a></h2><p>该文档是提供给期望使用 <code>Zookeeper</code>协作服务功能的开发者创建分布式应用的。文档内部包含了一些概念上和实践应用上的资料信息。</p><p>在指南的前四节主要讨论了 <code>Zookeeper</code> 各方面的概念。这些东西对于理解 <code>Zookeeper</code>如何工作以及如何去使用 <code>Zookeeper</code> 是非常必要的。它虽然没有包含源代码，但是它是假设读者对于分布式计算相关的问题是很熟悉的。它们主要如下介绍：</p><ul><li><a href="#The_ZooKeeper_Data_Model">Zookeeper 数据模型</a></li><li><a href="#ZooKeeper_Sessions">Zookeeper 会话</a></li><li><a href="#ZooKeeper_Watches">Zookeeper 监听</a></li><li><a href="#Consistency_Guarantees">Zookeeper 一致性保证</a></li></ul><p>后面四节主要提供了一些实践编程相关的资料。主要是：</p><ul><li><a href="#A_Guide_to_ZooKeeper_Operations">Zookeeper 操作指南</a></li><li><a href="#Bindings">Zookeeper Bindings</a></li><li><a href="#Program_Structure">Zookeeper 程序结构简单示例（待定）</a></li><li><a href="#Gotchas">Zookeeper 性能和可伸缩性</a></li></ul><p>文档最后的附录部分包含了一些有用的，Zookeeper 相关的链接。</p><p>虽然，该指南中的很多资料在其他一些独立的文章博客中都已经存在了，但是对于开始第一个 <code>Zookeeper</code> 应用的你来说，还是最后阅读完<code>Zookeeper 数据模型</code> 和 <code>Zookeeper 操作指南</code>。</p><h2 id="Zookeeper-数据模型"><a href="#Zookeeper-数据模型" class="headerlink" title="  Zookeeper 数据模型"></a><a id="The_ZooKeeper_Data_Model">  Zookeeper 数据模型</a></h2><p><code>Zookeeper</code> 有一个分级的命名空间，类似于一个分布式的文件系统。唯一不同的是命名空间中每个节点可以有对应的数据关联它，就像孩子一样。这一点类似于文件系统中允许一个文件也可以成为目录一样。到节点的路径常常表示成正则的，绝对的，斜线分隔的路径；它们没有相对的引用。在路径上使用的任何编码需要满足以下限制：</p><ul><li><code>null</code>字符不可以成为路径名字的一部分。</li><li>由于显示的问题，如下字符不能使用：<code>\u0001</code>-<code>\u001F</code> 和 <code>\u007F</code>-<code>\u009F</code>.</li><li>下面字符同样不被允许：<code>\ud800</code>-<code>\u0F8FF</code> 和 <code>\uFFF0</code>-<code>\uFFFF</code>.</li><li><code>.</code>字符可以作为路径名字中某块名的一部分，但是<code>.</code>和<code>..</code>不能单独作为路径的一块，因为在 Zookeeper 中不允许相对路径。因此，如下是非法的：<code>/a/b/./c</code>或者<code>/a/b/../c</code>.</li><li><code>zookeeper</code>字符串保留。</li></ul><span id="more"></span><h3 id="ZNodes"><a href="#ZNodes" class="headerlink" title="ZNodes"></a>ZNodes</h3><p>ZooKeeper 树上的每一个节点都称之为<code>znode</code>。Znodes 维护了一个包含数据变化和acl变化版本号的状态结构体。这个结构体也包含时间戳。因此，版本号和时间戳一起确保Zookeeper验证缓存和协调更新。每一次znode的数据变化，版本号也会对应增长。例如，当一个客户端检索数据时，它也会获得该数据的版本号，然后当一个客户端执行更新或者删除时，它必须提供对应变化的znode的数据版本。如果它提供的版本不能够匹配到实际的数据版本时，更新将会失败。</p><blockquote><blockquote><p>Note:<br>在分布式应用工程中，<code>node</code>常常被看做一个主机，一台服务器，一组中的一个成员等等。在Zookeeper文档中，<code>znodes</code>称为数据节点；<code>Servers</code>则是标记为Zookeeper服务的机器；<code>quorum peers</code>是标记为一个集群的所有服务器；<code>client</code>是任何使用Zookeeper服务的机器或者进程。</p></blockquote></blockquote><p>Znodes是开发者访问的最主要的实体。它们有一些值得去关注的特征：</p><h4 id="Watches"><a href="#Watches" class="headerlink" title="Watches"></a>Watches</h4><p>客户端可以在 znodes 上设置监听。znode 的改变将会触发监听器，然后清理监听。当一个监听器被触发时，Zookeeper 会发送对应客户端一个通知。更新的信息可以参考 <a href="#ZooKeeper_Watches">Zookeeper 监听</a>。</p><h4 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h4><p>保存在一个命名空间里的每个节点上的数据都可以被原子的读和写。读，获取对应znode上所有的数据字节；然后一个写，替换所有的数据。每个节点上的ACL(访问控制列表)可以限制<code>who can do what</code>。</p><p>Zookeeper 不是被设计用来作为一个通用的数据库或者大对象的存储。相反，它是用来管理协调数据的。这个数据来源于配置，状态信息，集结地点等形式中。一般，协调的数据相对来说是很小的：几千字节计算。Zookeeper 客户端和服务器实现的时候会确保znode的数据小于1M，但是通常数据会比那个小得多。操作相对大的数据将会导致一些操作会花费更对的时间，从而一些操作的延迟性，这主要是因为一些额外的时间需要被用来在网络上移动更多的数据，存储起来。如果一定需要大数据的存储，通常的处理方式是将数据存储在大容量存储系统上，比如 NFS 或者 HDFS ，然后再Zookeeper里保持存储位置的指针。</p><h4 id="短暂节点"><a href="#短暂节点" class="headerlink" title="短暂节点"></a>短暂节点</h4><p>Zookeeper 也有短暂节点的概念。在会话创建时，znode存活；当会话结束时，znode删除。由于这个特性，所以其不允许有孩子。</p><h4 id="顺序节点-唯一命名"><a href="#顺序节点-唯一命名" class="headerlink" title="顺序节点-唯一命名"></a>顺序节点-唯一命名</h4><p>当创建一个znode时，你也可以请求Zookeeper在路径的末尾增加一个单调递增的计算器。这个计算器对父节点来说是唯一的。计算器有一个<code>%010d</code>格式化–表示10个数字0补全。比如：<code>&lt;path&gt;0000000001</code>。Notes：计数器用来保存下一个顺序数字是一个有符号整形，由父节点保存，当增长到<code>2147483647</code>将会溢出。</p><h3 id="Zookeeper-中的-Time"><a href="#Zookeeper-中的-Time" class="headerlink" title="Zookeeper 中的 Time"></a>Zookeeper 中的 Time</h3><p>Zookeeper 追踪 time的多种方式如下：</p><ul><li><p>Zxid<br>Zookeeper状态的每次改变，在<code>zxid</code>(ZooKeeper Transaction Id)里都会获取到一个时间戳。这意味着在ZooKeeper中所有都变化都是有序的。每次改变都将会有一个<code>zxid</code>，如果 zxid1 小于 zxid2，则 zxid1 一定在 zxid2 之前发生。</p></li><li><p>版本号<br>一个节点的每次改变都会导致对应节点的其中一个版本号递增。节点对应的三个版本号是：version(znode 数据改变对应的编号)；cversion(znode 的孩子改变对应的编号)；aversion(znode 的ACL改变对应的编号)。</p></li><li><p>Ticks<br>当使用多服务器的 ZooKeeper 时，服务器使用 <code>ticks</code> 来定义事件的时间，比如，状态上传，会话超时，连接超时等。tick 时间只能间接地表示最小的会话超时（每tick时间内2次）；如果一个客户端请求的会话超时小于最小的会话超时，则服务器将会告诉客户端它请求的会话超时实际上是最小的会话超时。</p></li><li><p>真实时间<br>ZooKeeper 不使用真实时间或者时钟时间，即使在所有我们期望把时间戳放入znode创建和修改的状态结构体里面。</p></li></ul><h3 id="ZooKeeper-状态结构体"><a href="#ZooKeeper-状态结构体" class="headerlink" title="ZooKeeper 状态结构体"></a>ZooKeeper 状态结构体</h3><p>ZooKeeper 里每个 znode 的状态结构体都包括下面这些字段：</p><ul><li>czxid<br>导致znode被创建的zxid。</li><li>mzxid<br>对应znode最后一次改变的zxid。</li><li>ctime<br>当该znode创建开始的毫秒数。</li><li>mtime<br>当该znode最后一次更改开始的毫秒数。</li><li>version<br>znode数据改变的编号。</li><li>cversion  </li><li>aversion  </li><li>ephemeralOwner<br>如果该znode是临时节点，则为该节点owner的 会话id；如果不是临时节点，则为0。</li><li>dataLength<br>znode 数据字段的长度。</li><li>numChildren<br>znode对应孩子的个数。</li></ul><h2 id="Zookeeper-会话"><a href="#Zookeeper-会话" class="headerlink" title="  Zookeeper 会话"></a><a id="ZooKeeper_Sessions">  Zookeeper 会话</a></h2><p>ZooKeeper 客户端通过绑定的编程语言创建一个 <code>handle</code>从而和ZooKeeper服务建立会话。一旦创建完成，<code>handle</code>开始处在  <code>CONNECTING</code> 状态，然后客户端将会和ZooKeeper服务中某个服务器连接上，然后其会切换到 <code>CONNECTED</code>状态。在通常的操作过程中，会处在这两张状态中的一种。如果发生了一个不可恢复的错误，比如会话过期或者认证失败，再或者如果应用显示地关闭 <code>handle</code>，则该 <code>handle</code> 将会转变为 <code>CLOSE</code> 状态。</p><p>下面的图展示了一个 ZooKeeper 客户端可能的状态流转情形：</p><img src="/images/2015/09/zookeeper_stat.png" /><p>为了创建一个客户端会话，应用代码必须提供一个连接字符串，包含一个以逗号分隔的 <code>host:pair</code>列表, 每个<code>host:pair</code> 对应的是一台 ZooKeeper服务器（比如，”127.0.0.1:4545” 或者 “127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002”）。ZooKeeper 客户端会挑选任务的服务器，然后尝试去连接它。如果这个连接失败，或者这个客户端因为任何原因导致和这个服务器断开连接，客户端都将会自动尝试列表中的下一台服务器，知道一个连接被(重新)建立起来。</p><p><em>3.2.0 新特性</em>：一个可选择的”chroot”后缀也可能会添加到连接字符串中。和linux中的<code>chroot</code>命令相似，运行客户端的所有命令中的路径都是相对这个root来确定的。比如我们如果使用：”127.0.0.1:4545/app/a” 或者 “127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a”，则客户端将会以”/app/a” 为root，然后所有路径都是相对这个root而言的–例如，我们获取 “/foo/bar” 下面的文件，则实际上将会在 “app/a/foo/bar” 下面执行。这个特性对于多租户环境下是很有用的，这样每个用户在 ZooKeeper服务上其root都可以不同。因此，对于每个用户如果编码他们的应用中以”/“为root情况下，重复使用ZooKeeper服务将非常简单。</p><p>当一个客户端获取到ZooKeeper服务的一个<code>handle</code>，ZooKeeper 创建一个ZooKeeper 会话，以 64位数字表示。如果客户端连接到一台不同的 ZooKeeper服务器，它将会发送一个会话id作为连接握手的一部分。作为一个安全手段，服务器为该会话id创建一个任何ZooKeeper服务器都可以验证的password。当客户端建立完会话之后，password 将会和会话id一起发送给客户端。当客户端需要和新的服务器重新建立连接时，则发送该password 和 会话id。</p><p>ZooKeeper 客户端库调用创建一个ZooKeeper会话时，其中有一个参数是毫秒数的会话超时。客户端发送一个请求超时，服务器将响应从客户端获取的超时。当前的时候要求超时时间最小为 2 个 tckTime，并且最大为 20 个 tickTime。ZooKeeper 客户端API 运行访问协商的超时。</p><p>当一个客户端（会话）从ZK服务集群里分隔开，它将会开始搜素我们在创建会话时候指定的服务器列表。最后，当客户端和至少服务器中的一台重新建立连接后，会话将会要么转化为 <code>connected</code>状态（如果会话重连接在超时值之内），要么转化为<code>expired</code>状态（如果重连在会话超时之后）。为断开连接的客户端创建一个新的会话对象是不明智的。ZK 客户端库将会为你处理重连。在实践中，我们在客户端库中会有一些启发式的算法构建来处理像”羊群效应”等事情。只有在收到会话过期通过时，才会去创建一个新的会话。</p><p>会话过期由ZooKeeper集群自己管理，而不是客户端。当ZK客户端和集群建立会话时，其提供一个超时值。集群使用这个值来决定客户端会话是否超时。当集群没有在超时时间内收到返回，则发送会话过期。在会话过期的时候，集群将会删除该会话拥有的所有的临时节点，然后立即通知监听该变化的所有连接状态的客户端。在这个时间点，超时会话的客户端仍然和集群断开连接，在重新和集群建立连接之前，它将不会收到会话超时的通知。客户端将会一直带着断开连接的状态，知道TCP连接被重新建立起来，然后 超时会话的<code>watcher</code>将会接收到”会话超时”的通知。</p><p>一个超时的会话状态流转的过程示例：</p><ol><li>connected：会话建立连接，客户端和集群处于通信中。</li><li>客户端从集群中分割开…</li><li>disconnected：客户端丢失和集群之间的连接</li><li>… 时间过去了，在 超时区间之后，集群过期了会话，客户端由于和集群断开了所以看不到任何东西。</li><li>… 时间进行走着，客户端恢复了和集群的网络层连接、</li><li>expired：最终，客户端重新连接上集群，然后被通知过期。</li></ol><p>ZooKeeper 建立会话调用的另一个蚕食是默认的 <code>watcher</code>。当在客户端上的状态发送变更，watcher 将会被通知到。例如，如果一个客户端丢失了和服务器之间的连接，则客户端将会收到通知，或者如果客户端会话过期了。watcher 应该认为初始状态是 断开连接的。在一个新连接的case里面，发送给 watcher 的第一个通知就是会话连接事件。</p><p>会话通过客户端发送请求保持alive。如果会话空闲了会话超时时间段时，客户端将会发送 <code>PING</code>请求来保持会话alive。<code>PING</code>请求不仅允许 ZooKeeper服务器知道 客户端仍然活跃，也允许客户端通过连接验证 ZooKeeper服务器仍然活跃。<code>PING</code>的时间很充足，从而确保有在检测到死连接，然后重新连接到新的server的操作有足够的时间。</p><p>一旦一个到服务器的连接成功的建立了，客户端 lib 有两个基本的case 导致 连接丢失，当执行一个同步或者异步操作，然后出现如下情况：</p><ol><li>在一个不再活跃/有效的会话上调用一个操作。</li><li>当ZooKeeper客户端挂起一个操作时，断开和服务器之间的连接。</li></ol><p><em>3.2.0 新特性–SessionMovedException</em>：这是一个内部的异常。这个异常一般发生在一个会话和不同的服务器重新建立连接后接收到请求的时候。正常导致这个错误的原因是一个哭护短发生一个请求给一个服务器，但是网络包延迟，所以客户端超时，然后和新的服务器建立间接。当延迟的包被第一台服务器收到时，老的服务器检测到会话已经被移开，然后关闭客户端连接。客户端正常下不会看着这个错误，因为他不会从老的连接中读数据。出现这种情况的一个条件是当两个客户端尝试使用 password 和 会话id 重新建立相同的连接，其中一个客户端将重新建立连接，第二个客户端将会断开连接。</p><p><em>更新服务器列表</em>：我们允许客户端通过提供一组新的逗号分隔的<code>host:port</code>对列表来更新连接字符串。这个函数调用一个基于概率的负载均衡算法导致客户端断开和当前host的连接，从而达到服务器列表中连接的平均数。万一当前客户端连接的host不在新的列表中，这个调用将会导致连接被丢弃。另外，决定服务器数量的增加或者减少以及多少。</p><p>例如：如果前面的连接字符串包含 3 host，然后现在列表包含这 3 个 host和 2 个新加的 host，40%的客户端原来对应的连接将会迁移到新的hosts中的一个来确保均衡负载。这个方案将会导致客户端丢弃他的连接，然后0.4的概率连接到其他2台机器，在这种情况下，导致客户端随机选择连接 2 个新的host中的一台。</p><p>另一个例子–假设我们有5 台host，现在我们更新服务器列表移走 2 台host，然后客户端连接剩下 3 台host的依然连接，然后 移除的2台 host上的连接将被移动到剩下 3 台host的其中一台。如果连接丢弃，客户端移动到指定的模式，其可以选择一个新的服务器去根据概率算法连接服务器，而不是 RR。</p><p>在第一个例子中，每个客户端决定以0.4的概率来断开连接，但是一旦做完决定，它将尝试随机连接到一个新的服务器，仅仅在不能连接到新的服务器中的任何一台时，它才会尝试连接老的服务器。在找到一个服务器，或者尝试列表中所有的服务器，仍然连接失败的时候，客户端回退到正常的操作模式(从概率模式回到轮询RR模式)，即从连接字符串中选择任意的服务器，然后尝试连接它。如果失败，它将以RR模式尝试不同随机服务器。</p><h2 id="Zookeeper-监听"><a href="#Zookeeper-监听" class="headerlink" title="  Zookeeper 监听"></a><a id="ZooKeeper_Watches">  Zookeeper 监听</a></h2><p>在 ZooKeeper 里所有的读操作（getData()，getChildren()和 exists()）都可以将设置一个 <code>watch</code> 作为附加功能。ZooKeeper 对 <code>watch</code>的定义是：一个监听事件是一次性的 <code>trigger</code>，当监听的数据发送变化的时候，发送给设置监听的客户端们。对于这个定义，有三个关键点：</p><ul><li><p>One-time trigger<br>当监听数据发送变化的时候，一个监听事件将会发送给客户端。例如，一个客户端使用 <code>getData(&quot;/znode1&quot;, true)</code>，然后<code>/znode1</code>的数据发送变化或者删除，客户端将会获得一个对应 <code>/znode1</code>的监听事件。<em>但是，如果<code>/znode1</code>再次改变，就不会再有监听事件发送出去，除非客户端通过另一个读操作来设置监听watch</em></p></li><li><p>Sent to client<br>这意味着一个正发送给客户端的事件，可能在发送修改操作的客户端完成操作返回成功 code 之前不会到达客户端。监听事件是异步发送给监听客户端的。ZooKeeper 提供一个有序的保证：一个客户端永远只有在看到一个watch事件之后才会看到这个watch对应的改变。网络延迟或者其他原因可能导致不同的客户端看到watch和更新返回code的时间不同。其关键之处在于不同客户端看到的所有事情都是有一致性的顺序的。</p></li><li><p>The data for which the watch was set<br>这指的是节点改变的不同方式。你可以认为 ZooKeeper 维护 watch的两个列表：数据watch 和 孩子watch。<code>getData()</code>和<code>exists()</code>设置数据watch；<code>getChildren()</code> 设置child监听。此外，你也可以认为 watch 可以根据数据返回的类型来设置。<code>getData()</code>和<code>exists()</code> 返回节点数据的信息，然而<code>getChildren()</code> 返回 孩子列表。因此，<code>setData()</code>将触发节点的数据watch 设置。一个成功的<code>create()</code>将会触发znode的数据watch 以及 父节点的child watch。一个成功的 <code>delete()</code>将会触发节点的数据watch和child watch（因为将不会再有children了）。</p></li></ul><p>watch 由与对应client连接的ZooKeeper服务器负责维护。因此，这可以使得 watch 可以轻量级地设置，维护和分发。当一个客户端连接到一个新的server，watch将会出现会话时间。当和server断开连接后，将不会收到watch。当一个客户端重新连接，任务先前注册的watch将会被重新注册，然后当需要的时候触发。一般情况下，这都是显示地发生的。有一个case就是一个watch可能被丢失：一个人还未创建的znode的 existence watch 将会被丢失，如果这个znode 创建，然后当断开连接的时候又被删除了。</p><h3 id="watch-语义"><a href="#watch-语义" class="headerlink" title="watch 语义"></a>watch 语义</h3><p>我们可以通过读ZooKeeper的三种状态来设置 watch：exists, getData, 和<br>getChildren。下面的列表展示了一个watch 触发和调用激活的方式：</p><ul><li>Created event:<br>通过 exist调用激活。</li><li>Deleted event:<br>通过调用 exists, getData, 和 getChildren 激活</li><li>Changed event:<br>通过调用 exists, getData 激活。</li><li>Child event:<br>通过调用 getChildren 激活。</li></ul><h3 id="watch-移除"><a href="#watch-移除" class="headerlink" title="watch 移除"></a>watch 移除</h3><p>我们可以调用 removeWatches 方法移除在 znode 注册的 watch。一个客户端可以本地移除watch操作，即使没有连接ZooKeeper服务器，只是本地设置标识为true。下面的列表详细说明了在成功移除watch 之后会触发什么事件：</p><ul><li>Child Remove event:<br>在调用getChildren的时候添加 watcher。</li><li>Data Remove event:<br>在调用 exists 或者 getData 的时候添加 watcher。</li></ul><h3 id="关于-watch-需要记住的事情"><a href="#关于-watch-需要记住的事情" class="headerlink" title="关于 watch 需要记住的事情"></a>关于 watch 需要记住的事情</h3><ul><li>Watches 是一次性触发器。如果你获取了一个 watch 事件，然后你还想在未来更改的时候也获得通知，则你必须要设置另外的watch。</li><li>由于watch是一次性的触发器，并且在获取时间和发送新的请求去获取watch 这段之间的延迟，所看到的发生在 ZooKeeper Znode 上的所有改变都是不可信的。需要准备好处理在获取事件和设置watch之间znode改变多次的case。</li><li>一个watch对象，或者 function/context对，对于给定的通知只会被触发一次。例如，如果一个相同的watch对象被一个<code>exists 或者 getData</code> 文件file调用操作注册，然后这个文件file被删除了，这个watch对象将和这个文件file的删除通知一起，仅仅被调用一次。</li><li>当你从服务器上断开连接，你将不能获得任何watch 直到连接被重新建立起来。基于这个原因，会话事件将被发生给所有突出的watch处理器。使用会话事件会进入一个安全模式：你将不能接收事件指导断开连接，所以你的处理处理这种模式下需要谨慎。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
          <category> Translation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 反向代理配置和工作原理</title>
      <link href="2015/08/30/2015-08-30-nginx-proxy-configure-and-sduty/"/>
      <url>2015/08/30/2015-08-30-nginx-proxy-configure-and-sduty/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p><code>Nginx</code>是一款面向性能设计的HTTP服务器,其性能相对于其他服务器表现优异。内部使用异步的事件处理模型，比如linux平台的<code>epoll</code>事件模型，unix平台的<code>kqueue</code>事件模型等。在Nginx源码的<code>src/event/modules</code>目录下，其对各个平台不同的异步模型进行了二次封装。此外，Nginx在代码实现的时候，会考虑到众多细节优化。比如：根据CPU亲缘性来分配进程和事件，避免CPU级的缓存失效；比如字符串比较时，四字节转换为整数来进行快速指令级比较，等等。</p><p>本博文主要目的不是Nginx源码分析，所以，对源码及其独特优秀的代码设计不会去详细介绍。</p><p>在最近的一些项目中，涉及到nginx的反向代理配置，然后花了一些时间了解下关于Nginx的整体请求处理流程和返现代理的实现机制。</p><p>Nginx虽然代码整洁，模块清晰，但是代码量毕竟还是很多，而且注释实在是太少，所以把一些学习的资料和心得整理一下，以便以后查看。</p><h2 id="Nginx-反向代理配置说明"><a href="#Nginx-反向代理配置说明" class="headerlink" title="Nginx 反向代理配置说明"></a><a id="Proxy">Nginx 反向代理配置说明</a></h2><p>反向代理指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接到客户端，此时代理服务器对外就表现为一个服务器，而此种工作模式类似于LVS-NET模型。</p><p>反向代理也可以理解为web服务器加速，它是一种通过在繁忙的web服务器和外部网络之间增加的 一个高速web缓冲服务器，用来降低实际的web服务器的负载的一种技术。反向代理是针对web服务器提高加速功能，所有外部网络要访问服务器时的所有请求都要通过它，这样反向代理服务器负责接收客户端的请求，然后到源服务器上获取内容，把内容返回给用户，并把内容保存在本地，以便日后再收到同样的信息请求时，它会将本地缓存里的内容直接发给用户，已减少后端web服务器的压力，提高响应速度。因此Nginx还具有缓存功能。</p><span id="more"></span><p>了解nginx的反向代理如何实现之前，先看看我们一般配置nginx反向代理的设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">upstream cc_001 &#123;</span><br><span class="line">    server 192.168.1.101:80;</span><br><span class="line">    server 192.168.1.102:80;</span><br><span class="line"></span><br><span class="line">    healthcheck_enabled;</span><br><span class="line">    healthcheck_delay 3000;</span><br><span class="line">    healthcheck_timeout 1000;</span><br><span class="line">    healthcheck_failcount 2;</span><br><span class="line">    healthcheck_send &#x27;GET /healthcheck.html HTTP/1.0&#x27; &#x27;Host: local.com&#x27; &#x27;Connection: close&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    listen       192.168.1.100:80;</span><br><span class="line">    server_name  cc.local.com;</span><br><span class="line"></span><br><span class="line">    proxy_buffers 64 4k;</span><br><span class="line"></span><br><span class="line">    location = / &#123;</span><br><span class="line">        proxy_pass http://cc_001/bm/index.htm;</span><br><span class="line">        proxy_set_header   Host             $host;</span><br><span class="line">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://cc_001;</span><br><span class="line">        proxy_set_header   Host             $host;</span><br><span class="line">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的code主要列出来nginx 反向代理基本配置。</p><blockquote><blockquote><p>Tips：上面的配置选项都是最最基本的，一般涉及到反向代理都会使用到这些配置。对于其中的设置项，理解起来也很简单。</p></blockquote></blockquote><p><em>upstream配置块</em></p><p>其实在nginx中，<code>upstream</code>是一个非常重要的配置。nginx所有对于动态请求的处理，基本上都需要使用<code>upstream</code>配置模块。nginx的两个很重要的功能，反向代理和负载均衡，都需要通过配置对应的<code>upstream</code>来完成。</p><blockquote><blockquote><p>其实在nginx中，有一个基础模块叫handler，这个模块可以接受来自客户端/用户端的请求，然后处理并产生对应的响应内容返回过去。因此，我们那些静态资源，前端页面什么的，都是使用handler模块来完成响应的。但是，众所知周，一般的核心服务都是后台动态产生的，这些资源就不可以方便使用handler去完成内容的生成和响应动作（当然也是可以使用开发自定义handler来完成的，比如各种xxxcgi之流，但是一般还是用来处理静态资源）。</p><p>那么，upstream就出现了。其接收到用户的请求，然后转发到后端服务器拿到对应的响应资源，再返回给请求端。在整个处理过程中，其本身不会产生自己的响应内容，这是和<code>handler</code>模块唯一的区别。</p><p>upstream的特性，决定了在其配置块中，设置一些后端服务器的地址和端口，就ok了。</p></blockquote></blockquote><p>配置项说明：</p><ul><li><p> upstream中的server项：表明后台的一台服务器地址和端口。当客户端有请求到<code>nginx</code>服务器的时候，upstream模块根据这里配置的server，该对应的请求转发到这些server服务上，由这些server来处理请求，然后把响应结果告知upstream模块。</p></li><li><p> healthcheck_enabled项：healthcheck健康监控功能，并不是原生nginx自带的。所以如果使用这个功能，必须要安装第三方插件：<code>ngx_http_healthcheck_module</code>。healthcheck_enabled表示启动健康检查模块功能。</p></li><li><p> healthcheck_delay项：对同一台后端服务器两次检测之间的时间间隔，单位毫秒，默认为1000。</p></li><li><p> healthcheck_timeout项：进行一次健康检测的超时时间，单位为毫秒，默认值2000。</p></li><li><p> healthcheck_failcount项：对一台后端服务器检测成功或失败多少次之后方才确定其为成功或失败，并实现启用或禁用此服务器。</p></li><li><p> healthcheck_send项：为了检测后端服务器的健康状态所发送的检测请求。然后根据各个服务器的响应情况来判断服务器是否存活。上面的配置表面，各个后台服务器上都存在<code>healthcheck.html</code>静态页面，然后nginx会get这个页面，根据是否status为200来判断是否服务器存活。</p></li></ul><p><em>server配置块</em></p><p>在nginx中，不管怎么样的配置，都会有一个server配置块。http服务上支持若干虚拟主机。每个虚拟主机会有一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server.每个server通过监听的地址来区分。</p><blockquote><blockquote><p>Server其实就是一个虚拟主机。因为在nginx中可以配置多个server，这样就使得nginx可以在一台服务器上配置多个域名。</p><p>在nginx的Server虚拟主机中，它只会处理与之对应的域名请求。并且，如果在listen中设置了ip地址，则该虚拟主机只会处理从该服务器的指定ip端口进来的请求，才会去处理。关于一台服务器设置多个别名ip地址的方式，可以参考博客<a href="http://www.cnblogs.com/mchina/archive/2012/05/21/2511824.html">在Nginx中部署基于IP的虚拟主机</a></p></blockquote></blockquote><p>配置项说明：</p><ul><li><p> listen项：监听ip和端口。当nginx服务器的该ip端口有请求访问，则调用该server的配置来处理该请求。</p></li><li><p> server_name项：域名。nginx对进入该虚拟主机的请求，检查其请求Host头是否匹配设置的server_name，如果是，则继续处理该请求。</p></li><li><p> location块选项：Location在nginx中是一个非常重要的指令。对于HTTP请求，其被用来详细匹配URI和设置的location path。一般这个uri path会是字符串或者正则表达式形式。</p></li></ul><blockquote><blockquote><p>: 关于location匹配，存在一些语法规则，如下：</p><pre><code>  location [=|~|~*|^~|@] /uri/ &#123; ... &#125;   =：表示精确匹配，如果找到，立即停止搜索并立即处理此请求。   ~：表示区分大小写匹配。   ~*：表示不区分大小写匹配。   ^~：表示只匹配字符，串不查询正则表达式。   @：指定一个命名的location，一般只用于内部重定向请求。</code></pre></blockquote></blockquote><ul><li><p> location中proxy_pass项：代理转发。配置了该项，当匹配location path的请求进来后，会根据upstream设置，请求后台服务器上的proxy_pass的请求。例如，上面的配置，当有请求<code>cc.local.com</code>时，由于精确匹配<code>=/</code>，则根据proxy_pass配置，则会反向代理，请求<code>192.168.1.101:80/bm/index.htm</code>。</p></li><li><p> location中proxy_set_header项：设置代理请求头。由于经过了反向代理服务器，所以后台服务器不能获取真正的客户端请求地址等信息，这样，就需要把这些ip地址，设置回请求头部中。然后，我们在后台服务上，可以使用<code>request.get(&quot;X-Real-IP&quot;)</code>或者<code>request.get(&quot;X-Forwarded-For&quot;)</code>获取真实的请求ip地址。获取host也是如此。具体可以参考博文：<a href="http://gong1208.iteye.com/blog/1559835"> 使用nginx后如何在web应用中获取用户ip及原理解释</a>.</p></li></ul><h2 id="Nginx-架构和请求处理流程"><a href="#Nginx-架构和请求处理流程" class="headerlink" title="Nginx 架构和请求处理流程"></a><a id="ProcessRequest">Nginx 架构和请求处理流程</a></h2><p>Nginx架构，在taobao的<a href="http://tengine.taobao.org/book/chapter_02.html">《Nginx开发从入门到精通》</a>电子书中，写的比较详细。这里记录一些核心的细节。</p><p>Nginx在启动会以daemon形式在后台运行，采用<code>多进程+异步非阻塞IO事件模型</code>来处理各种连接请求。</p><p>Nginx主要包含一个master进行和多个worker进行，一般worker进程个数是根据服务器CPU核数来决定的。如下图：</p><img src="/images/2015/08/nginx_process.png" /><blockquote><blockquote><p>Notes：从上图中可以很明显地看到，4个worker进程的父进程都是master进程，表明worker进程都是从父进程fork出来的，并且父进程的ppid为1，表示其为daemon进程。</p><p>需要说明的是，在nginx多进程中，每个worker都是平等的，因此每个进程处理外部请求的机会权重都是一致的。</p></blockquote></blockquote><p>下面来介绍一个请求进来，进程模型的处理方式。</p><p><em>首先</em>，master进程一开始就会根据我们的配置，来建立需要listen的网络socket fd，然后fork出多个worker进程。</p><p><em>其次</em>，根据进程的特性，新建立的worker进程，也会和master进程一样，具有相同的设置。因此，其也会去监听相同ip端口的套接字socket fd。</p><p><em>然后</em>，这个时候有多个worker进程都在监听同样设置的socket fd，意味着当有一个请求进来的时候，所有的worker都会感知到。这样就会产生所谓的<code>惊群现象</code>。为了保证只会有一个进程成功注册到listenfd的读事件，nginx中实现了一个<code>accept_mutex</code>类似互斥锁，只有获取到这个锁的进程，才可以去注册读事件。其他进程全部accept 失败。</p><p><em>最后</em>，注册成功的worker进程，读取请求，解析处理，响应数据返回给客户端，断开连接，结束。因此，一个request请求，只需要worker进程就可以完成。</p><blockquote><blockquote><p>进程模型的处理方式带来的一些好处就是：进程之间是独立的，也就是一个worker进程出现异常退出，其他worker进程是不会受到影响的；此外，独立进程也会避免一些不需要的锁操作，这样子会提高处理效率，并且开发调试也更容易。</p><p>如前文所述，<code>多进程模型+异步非阻塞模型</code>才是胜出的方案。单纯的多进程模型会导致连接并发数量的降低，而采用异步非阻塞IO模型很好的解决了这个问题；并且还因此避免的多线程的上下文切换导致的性能损失。</p><p>关于异步非阻塞IO模型：linux的epoll介绍，可以参考：<a href="http://www.cppblog.com/deane/articles/165218.html">深入了解epoll </a></p></blockquote></blockquote><h3 id="Nginx-连接和请求处理"><a href="#Nginx-连接和请求处理" class="headerlink" title="Nginx 连接和请求处理"></a>Nginx 连接和请求处理</h3><p>上一节介绍了，worker进程会竞争客户端的连接请求，这种方式可能会带来一个问题，就是可能所有的请求都被一个worker进程给竞争获取了，导致其他进程都比较空闲，而某一个进程会处于忙碌的状态，这种状态可能还会导致无法及时响应连接而丢弃discard掉本有能力处理的请求。这种不公平的现象，是需要避免的，尤其是在高可靠web服务器环境下。</p><p>针对这种现象，Nginx采用了一个是否打开accept_mutex选项的值<code>ngx_accept_disabled</code>。标识控制一个worker进程是否需要去竞争获取accept_mutex选项，进而获取accept事件。</p><blockquote><blockquote><p>ngx_accept_disabled值，nginx单进程的所有连接总数的八分之一，减去剩下的空闲连接数量，得到的这个ngx_accept_disabled。</p><p>当ngx_accept_disabled大于0时，不会去尝试获取accept_mutex锁，并且将ngx_accept_disabled减1，于是，每次执行到此处时，都会去减1，直到小于0。不去获取accept_mutex锁，就是等于让出获取连接的机会，很显然可以看出，当空余连接越少时，ngx_accept_disable越大，于是让出的机会就越多，这样其它进程获取锁的机会也就越大。不去accept，自己的连接就控制下来了，其它进程的连接池就会得到利用，这样，nginx就控制了多进程间连接的平衡了。</p></blockquote></blockquote><p>接下来，看看连接处理流程（来自tengine.taobao.org）：</p><img src="/images/2015/08/request_process.png" /><blockquote><blockquote><p>关于处理流程的说明，参考: <a href="http://tengine.taobao.org/book/chapter_02.html">http://tengine.taobao.org/book/chapter_02.html</a></p></blockquote></blockquote><h2 id="Nginx-Upstream模块和Location配置"><a href="#Nginx-Upstream模块和Location配置" class="headerlink" title="Nginx Upstream模块和Location配置"></a><a id="ImplementationStudy">Nginx Upstream模块和Location配置</a></h2><p><em>Nginx Upstream</em></p><p>upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。</p><p>从本质上说，upstream属于handler，只是他不产生自己的内容，而是通过请求后端服务器得到内容，所以才称为upstream（上游）。请求并取得响应内容的整个过程已经被封装到nginx内部，所以upstream模块只需要开发若干回调函数，完成构造请求和解析响应等具体的工作。</p><p><code>upstream</code>模块逻辑实现的十分复杂，对于其具体实现，不分析。</p><p><code>upstream</code>模块主要做两件事情：</p><ul><li><p>当外部的客户端发送一个http请求后，如果涉及更后台服务，则会创建一个到后端服务的request请求；</p></li><li><p>请求到达后端，然后处理完成后，则upstream会将返回的数据接收过来，然后发送给外部请求的客户端。</p></li></ul><p><em>Nginx Location</em></p><p>首先，介绍下存在的几种Location配置方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">location  = / &#123;</span><br><span class="line">  # matches the query / only.</span><br><span class="line">  [ configuration A ] </span><br><span class="line">&#125;</span><br><span class="line">location  / &#123;</span><br><span class="line">  # matches any query, since all queries begin with /, but regular</span><br><span class="line">  # expressions and any longer conventional blocks will be</span><br><span class="line">  # matched first.</span><br><span class="line">  [ configuration B ] </span><br><span class="line">&#125;</span><br><span class="line">location /documents/ &#123;</span><br><span class="line">  # matches any query beginning with /documents/ and continues searching,</span><br><span class="line">  # so regular expressions will be checked. This will be matched only if</span><br><span class="line">  # regular expressions don&#x27;t find a match.</span><br><span class="line">  [ configuration C ] </span><br><span class="line">&#125;</span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">  # matches any query beginning with /images/ and halts searching,</span><br><span class="line">  # so regular expressions will not be checked.</span><br><span class="line">  [ configuration D ] </span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">  # matches any request ending in gif, jpg, or jpeg. However, all</span><br><span class="line">  # requests to the /images/ directory will be handled by</span><br><span class="line">  # Configuration D.   </span><br><span class="line">  [ configuration E ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例请求：</p><ul><li><pre><code> / -&gt; configuration A</code></pre></li><li><pre><code>/index.html -&gt; configuration B</code></pre></li><li><pre><code>/documents/document.html -&gt; configuration C</code></pre></li><li><pre><code>/images/1.gif -&gt; configuration D</code></pre></li><li><pre><code>/documents/1.jpg -&gt; configuration E </code></pre></li></ul><p>解析匹配规则为：</p><ol><li><p>字符串精确匹配到一个带 “=” 号前缀的location，则停止，且使用这个location的配置；</p></li><li><p>字符串匹配剩下的非正则和非特殊location，如果匹配到某个带 “^~” 前缀的location，则停止；</p></li><li><p>正则匹配，匹配顺序为location在配置文件中出现的顺序。如果匹配到某个正则location，则停止，并使用这个location的配置；否则，使用步骤2中得到的具有最大字符串匹配的location配置。</p></li></ol><blockquote><blockquote><p>Notes：需要注意的是：<code>~ 开头</code>表示区分大小写的正则匹配；而<code>~*  开头</code>表示不区分大小写的正则匹配。<code>!~和!~*</code>分别为区分大小写不匹配及不区分大小写不匹配的正则</p></blockquote></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a><a id="End">后记</a></h2><p>Nginx 是一个十分优秀的服务器软件，其内部相当多的设计和实现都非常巧妙和高效。</p><p>关于Nginx的一些好的站点有：</p><ul><li><a href="http://tengine.taobao.org/book/">http://tengine.taobao.org/book/</a></li><li><a href="http://www.pagefault.info/?cat=7">http://www.pagefault.info/?cat=7</a></li><li><a href="http://nginx.org/en/docs/">http://nginx.org/en/docs/</a></li><li><a href="http://kxcoder.github.io/images/2015/08/nginx_stream.png">http://kxcoder.github.io/images/2015/08/nginx_stream.png</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
          <category> Script </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Slf4j MDC 使用和 基于 Logback 的实现分析</title>
      <link href="2015/04/29/2015-04-29-LogBack-Implemention-And-Slf4j-Mdc/"/>
      <url>2015/04/29/2015-04-29-LogBack-Implemention-And-Slf4j-Mdc/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>如今,在 Java 开发中，日志的打印输出是必不可少的，<code>Slf4j + LogBack</code> 的组合是最通用的方式。</p><p>关于 <code>Slf4j</code> 的介绍,请参考本博客<a href="http://ketao1989.github.io/posts/Java-slf4j-Introduce.html">http://ketao1989.github.io/posts/Java-slf4j-Introduce.html</a></p><p>有了日志之后，我们就可以追踪各种线上问题。但是，在分布式系统中，各种无关日志穿行其中，导致我们可能无法直接定位整个操作流程。因此，我们可能需要对一个用户的操作流程进行归类标记，比如使用<code>线程+时间戳</code>，或者用户身份标识等；如此，我们可以从大量日志信息中grep出某个用户的操作流程，或者某个时间的流转记录。</p><p>因此，这就有了 <code>Slf4j MDC</code> 方法。</p><h2 id="Slf4j-MDC-介绍"><a href="#Slf4j-MDC-介绍" class="headerlink" title="Slf4j MDC 介绍"></a><a id="MdcIntroduce">Slf4j MDC 介绍</a></h2><p>MDC ( Mapped Diagnostic Contexts )，顾名思义，其目的是为了便于我们诊断线上问题而出现的方法工具类。虽然，Slf4j 是用来适配其他的日志具体实现包的，但是针对 MDC功能，目前只有logback 以及 log4j 支持，或者说由于该功能的重要性，slf4j 专门为logback系列包装接口提供外部调用(玩笑～：）)。</p><blockquote><p>logback 和 log4j 的作者为同一人，所以这里统称logback系列。</p></blockquote><p>先来看看 MDC 对外提高的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MDC</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Put a context value as identified by key</span></span><br><span class="line">  <span class="comment">//into the current thread&#x27;s context map.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String val)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Get the context identified by the key parameter.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Remove the context identified by the key parameter.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Clear all entries in the MDC.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>接口定义非常简单，此外，其使用也非常简单。</p></blockquote><span id="more"></span><p>如上代码所示，一般，我们在代码中，只需要将指定的值put到线程上下文的Map中，然后，在对应的地方使用 get方法获取对应的值。此外，对于一些线程池使用的应用场景，可能我们在最后使用结束时，需要调用clear方法来清洗将要丢弃的数据。</p><p>然后，看看一个MDC使用的简单示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(LogTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MDC.put(<span class="string">&quot;THREAD_ID&quot;</span>, String.valueOf(Thread.currentThread().getId()));</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;纯字符串信息的info级别日志&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看看logback的输出模板配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.base&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;catalina.base&#125;/logs&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextListener</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.jul.LevelChangePropagator&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resetJUL</span>&gt;</span>true<span class="tag">&lt;/<span class="name">resetJUL</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contextListener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss&#125; %highlight(%-5p) %logger.%M\(%F:%L\)] %X&#123;THREAD_ID&#125; %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>于是，就有了输出：</p><pre><code>[2015-04-30 15:34:35 INFO  io.github.ketao1989.log4j.LogTest.main(LogTest.java:29)] 1 纯字符串信息的info级别日志</code></pre><blockquote><p>当我们在web应用中，对服务的所有请求前进行filter拦截，然后加上自定义的唯一标识到MDC中，就可以在所有日志输出中，清楚看到某用户的操作流程。关于web MDC，会单独一遍博客介绍。</p><p>此外，关于logback 是如何将模板中的变量替换成具体的值，会在下一节分析。</p><p>在日志模板logback.xml 中，使用 <code>%X&#123; &#125;</code>来占位，替换到对应的 MDC 中 key 的值。</p></blockquote><h2 id="前置知识介绍"><a href="#前置知识介绍" class="headerlink" title="前置知识介绍"></a><a id="PrepareKnowledge">前置知识介绍</a></h2><h3 id="InheritableThreadLocal-介绍"><a href="#InheritableThreadLocal-介绍" class="headerlink" title="InheritableThreadLocal 介绍"></a>InheritableThreadLocal 介绍</h3><p>在代码开发中，经常使用 <code>ThreadLocal</code>来保证在同一个线程中共享变量。在 <code>ThreadLocal</code> 中，每个线程都拥有了自己独立的一个变量，线程间不存在共享竞争发生，并且它们也能最大限度的由CPU调度，并发执行。显然这是一种以空间来换取线程安全性的策略。</p><p>但是，<code>ThreadLocal</code>有一个问题，就是它只保证在同一个线程间共享变量，也就是说如果这个线程起了一个新线程，那么新线程是不会得到父线程的变量信息的。因此，为了保证子线程可以拥有父线程的某些变量视图，JDK提供了一个数据结构，<code>InheritableThreadLocal</code>。</p><p>javadoc 文档对 InheritableThreadLocal 说明：</p><blockquote><p> 该类扩展了 ThreadLocal，为子线程提供从父线程那里继承的值：在创建子线程时，子线程会接收所有可继承的线程局部变量的初始值，以获得父线程所具有的值。通常，子线程的值与父线程的值是一致的；但是，通过重写这个类中的 childValue 方法，子线程的值可以作为父线程值的一个任意函数。</p></blockquote><blockquote><p>当必须将变量（如用户 ID 和 事务 ID）中维护的每线程属性（per-thread-attribute）自动传送给创建的所有子线程时，应尽可能地采用可继承的线程局部变量，而不是采用普通的线程局部变量。</p></blockquote><p>代码对比可以看出两者区别：</p><blockquote><p>ThreadLocal:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Method childValue is visibly defined in subclass</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal, but is internally defined here for the</span></span><br><span class="line"><span class="comment">     * sake of providing createInheritedMap factory method without</span></span><br><span class="line"><span class="comment">     * needing to subclass the map class in InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">     * This technique is preferable to the alternative of embedding</span></span><br><span class="line"><span class="comment">     * instanceof tests in methods.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>InheritableThreadLocal:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes the child&#x27;s initial value for this inheritable thread-local</span></span><br><span class="line"><span class="comment">     * variable as a function of the parent&#x27;s value at the time the child</span></span><br><span class="line"><span class="comment">     * thread is created.  This method is called from within the parent</span></span><br><span class="line"><span class="comment">     * thread before the child is started.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method merely returns its input argument, and should be overridden</span></span><br><span class="line"><span class="comment">     * if a different behavior is desired.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentValue the parent thread&#x27;s value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the child thread&#x27;s initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the map associated with a ThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the map associated with a ThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the table.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map the map to store.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是开发时一般使用的类，直接copy父线程的变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnInheritThreadLocal</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">    <span class="title">InheritableThreadLocal</span>&lt;<span class="title">HashMap</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Child threads should get a copy of the parent&#x27;s hashmap.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> HashMap&lt;String, String&gt; <span class="title">childValue</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      HashMap&lt;String, String&gt; parentValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parentValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;String, String&gt;(parentValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>为了支持InheritableThreadLocal的父子线程传递变量，JDK在Thread中，定义了<code>ThreadLocal.ThreadLocalMap inheritableThreadLocals</code> 属性。该属性变量在线程初始化的时候，如果父线程的该变量不为null，则会把其值复制到ThreadLocal。</p></blockquote><blockquote><p>从上面的代码实现，还可以看到，如果我们使用原生的 <code>InheritableThreadLocal</code>类则在子线程中修改变量，可能会影响到父线程的变量值，及其他子线程的值。因此，一般我们推荐没有特殊情况，最好使用<code>CopyOnInheritThreadLocal</code>类，该实现是新建一个map来保持值，而不是直接使用父线程的引用。</p></blockquote><h2 id="Log-MDC-实现分析"><a href="#Log-MDC-实现分析" class="headerlink" title="Log MDC 实现分析"></a><a id="Slf4jMdc">Log MDC 实现分析</a></h2><h3 id="Slf4j-MDC-实现分析"><a href="#Slf4j-MDC-实现分析" class="headerlink" title="Slf4j MDC 实现分析"></a>Slf4j MDC 实现分析</h3><p>Slf4j 的实现原则就是调用底层具体实现类，比如logback,logging等包；而不会去实现具体的输出打印等操作。因此，除了前文中介绍的门面(Facade)模式外，提供这种功能的还有适配器(Adapter)模式和装饰(Decorator)模式。</p><p>MDC 使用的就是<code>Decorator</code>模式，虽然，其类命名为M <code>MDCAdapter</code>。</p><p>Slf4j MDC 内部实现很简单。实现一个单例对应实例，获取具体的MDC实现类，然后其对外接口，就是对参数进行校验，然后调用 MDCAdapter 的方法实现。</p><p>实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MDC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> MDCAdapter mdcAdapter;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">MDC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      mdcAdapter = StaticMDCBinder.SINGLETON.getMDCA();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError ncde) &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String val)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;key parameter cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mdcAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;MDCAdapter cannot be null. See also &quot;</span></span><br><span class="line">          + NULL_MDCA_URL);</span><br><span class="line">    &#125;</span><br><span class="line">    mdcAdapter.put(key, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;key parameter cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mdcAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;MDCAdapter cannot be null. See also &quot;</span></span><br><span class="line">          + NULL_MDCA_URL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mdcAdapter.get(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>对于Slf4j的MDC 部分非常简单，MDC的核心实现是在logback方法中的。</p><p>在 logback 中，提供了 <code>LogbackMDCAdapter</code>类，其实现了<code>MDCAdapter</code>接口。基于性能的考虑，logback 对于InheritableThreadLocal的使用做了一些优化工作。</p></blockquote><h3 id="Logback-MDC-实现分析"><a href="#Logback-MDC-实现分析" class="headerlink" title="Logback MDC 实现分析"></a>Logback MDC 实现分析</h3><p>Logback 中基于 MDC 实现了<code>LogbackMDCAdapter</code> 类，其 get 方法实现很简单，但是 put 方法会做一些优化操作。</p><p>关于 put 方法，主要有：</p><ul><li><p>使用原始的<code>InheritableThreadLocal&lt;Map&lt;String, String&gt;&gt;</code>类，而不是使用子线程复制类 <code>CopyOnInheritThreadLocal</code>。这样，运行时可以大量避免不必要的copy操作，节省CPU消耗，毕竟在大量log操作中，子线程会很少去修改父线程中的<code>key-value</code>值。</p></li><li><p>由于上一条的优化，所以代码实现上实现了一个<code>写时复制版本的 InheritableThreadLocal</code>。实现会根据上一次操作来确定是否需要copy一份新的引用map，而不是去修改老的父线程的map引用。</p></li><li><p>此外，和 log4j 不同，其map中的val可以为null。</p></li></ul><p>下面给出，get 和 put 的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LogbackMDCAdapter</span> <span class="keyword">implements</span> <span class="title">MDCAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> InheritableThreadLocal&lt;Map&lt;String, String&gt;&gt; copyOnInheritThreadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;Map&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITE_OPERATION = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READ_OPERATION = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keeps track of the last operation performed</span></span><br><span class="line">  <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; lastOperation = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Integer <span class="title">getAndSetLastOperation</span><span class="params">(<span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    Integer lastOp = lastOperation.get();</span><br><span class="line">    lastOperation.set(op);</span><br><span class="line">    <span class="keyword">return</span> lastOp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">wasLastOpReadOrNull</span><span class="params">(Integer lastOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lastOp == <span class="keyword">null</span> || lastOp.intValue() == READ_OPERATION;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">duplicateAndInsertNewMap</span><span class="params">(Map&lt;String, String&gt; oldMap)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; newMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">    <span class="keyword">if</span> (oldMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// we don&#x27;t want the parent thread modifying oldMap while we are</span></span><br><span class="line">        <span class="comment">// iterating over it</span></span><br><span class="line">        <span class="keyword">synchronized</span> (oldMap) &#123;</span><br><span class="line">          newMap.putAll(oldMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    copyOnInheritThreadLocal.set(newMap);</span><br><span class="line">    <span class="keyword">return</span> newMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String val)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;key cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; oldMap = copyOnInheritThreadLocal.get();</span><br><span class="line">    Integer lastOp = getAndSetLastOperation(WRITE_OPERATION);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wasLastOpReadOrNull(lastOp) || oldMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 当上一次操作是read时，这次write，则需要new</span></span><br><span class="line">      Map&lt;String, String&gt; newMap = duplicateAndInsertNewMap(oldMap);</span><br><span class="line">      newMap.put(key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 写的话，已经new了就不需要再new</span></span><br><span class="line">      oldMap.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the context identified by the &lt;code&gt;key&lt;/code&gt; parameter.</span></span><br><span class="line"><span class="comment">   * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = getPropertyMap();</span><br><span class="line">    <span class="keyword">if</span> ((map != <span class="keyword">null</span>) &amp;&amp; (key != <span class="keyword">null</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>需要注意，在上面的代码中，write操作即put会去修改 <code>lastOperation</code> ，而get操作则不会。这样就保证了，只会在第一次写时复制。</p></blockquote><h3 id="MDC-clear-操作"><a href="#MDC-clear-操作" class="headerlink" title="MDC clear 操作"></a>MDC clear 操作</h3><blockquote><p>Notes：对于涉及到ThreadLocal相关使用的接口，都需要去考虑在使用完上下文对象时，清除掉对应的数据，以避免内存泄露问题。</p></blockquote><pre><code>因此，下面来分析下在MDC中如何清除掉不在需要的对象。</code></pre><p>在MDC中提供了<code>clear</code>方法，该方法完成对象的清除工作，使用logback时，则调用的是<code>LogbackMDCAdapter#clear()</code>方法，继而调用<code>copyOnInheritThreadLocal.remove()</code>。</p><p>在ThreadLocal中，实现<code>remove()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里，就是调用<code>ThreadLocal#remove</code>方法完成对象清理工作。</p><p>所有线程的ThreadLocal都是以<code>ThreadLocalMap</code>来维护的，也就是，我们获取threadLocal对象时，实际上是根据当前线程去该Map中获取之前的设置。在清除的时候，从这个Map中获取对应的对象，然后移除map.</p></blockquote><h2 id="Logback-日志输出实现"><a href="#Logback-日志输出实现" class="headerlink" title="Logback 日志输出实现"></a><a id="LogbackPrint">Logback 日志输出实现</a></h2><p>MDC 的功能实现很简单，就是在线程上下文中，维护一个 <code>Map&lt;String,String&gt;</code> 属性来支持日志输出的时候，当我们在配置文件<code>logback.xml</code> 中配置了<code>%X&#123;key&#125;</code>，则后台日志打印出对应的 key 的值。</p><p>同样，<code>logback.xml</code>配置文件支持了多种格式的日志输出，比如<code>%highlight</code>、<code>%d</code>等等，这些标志，在<code>PatternLayout.java</code>中维护。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatternLayout</span> <span class="keyword">extends</span> <span class="title">PatternLayoutBase</span>&lt;<span class="title">ILoggingEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, String&gt; defaultConverterMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADER_PREFIX = <span class="string">&quot;#logback.classic pattern: &quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    defaultConverterMap.putAll(Parser.DEFAULT_COMPOSITE_CONVERTER_MAP);</span><br><span class="line">    <span class="comment">// 按照&#123;&#125;配置输出时间</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;d&quot;</span>, DateConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;date&quot;</span>, DateConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出应用启动到日志时间触发时候的毫秒数</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;r&quot;</span>, RelativeTimeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;relative&quot;</span>, RelativeTimeConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出日志级别的信息</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;level&quot;</span>, LevelConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;le&quot;</span>, LevelConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;p&quot;</span>, LevelConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出产生日志事件的线程名</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;t&quot;</span>, ThreadConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;thread&quot;</span>, ThreadConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出产生log事件的原点的日志名=我们创建logger的时候设置的</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;lo&quot;</span>, LoggerConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;logger&quot;</span>, LoggerConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;c&quot;</span>, LoggerConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出 提供日志事件的对应的应用信息</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;m&quot;</span>, MessageConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;msg&quot;</span>, MessageConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;message&quot;</span>, MessageConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出调用方发布日志事件的完整类名</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;C&quot;</span>, ClassOfCallerConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;class&quot;</span>, ClassOfCallerConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出发布日志请求的方法名</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;M&quot;</span>, MethodOfCallerConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;method&quot;</span>, MethodOfCallerConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出log请求的行数</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;L&quot;</span>, LineOfCallerConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;line&quot;</span>, LineOfCallerConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出发布日志请求的java源码的文件名</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;F&quot;</span>, FileOfCallerConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;file&quot;</span>, FileOfCallerConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出和发布日志事件关联的线程的MDC</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;X&quot;</span>, MDCConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;mdc&quot;</span>, MDCConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出和日志事件关联的异常的堆栈信息</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;ex&quot;</span>, ThrowableProxyConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;exception&quot;</span>, ThrowableProxyConverter.class</span><br><span class="line">        .getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;rEx&quot;</span>, RootCauseFirstThrowableProxyConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;rootException&quot;</span>, RootCauseFirstThrowableProxyConverter.class</span><br><span class="line">        .getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;throwable&quot;</span>, ThrowableProxyConverter.class</span><br><span class="line">        .getName());</span><br><span class="line">    <span class="comment">// 和上面一样，此外增加类的包信息</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;xEx&quot;</span>, ExtendedThrowableProxyConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;xException&quot;</span>, ExtendedThrowableProxyConverter.class</span><br><span class="line">        .getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;xThrowable&quot;</span>, ExtendedThrowableProxyConverter.class</span><br><span class="line">        .getName());</span><br><span class="line">    <span class="comment">// 当我们想不输出异常信息时，使用这个。其假装处理异常，其实无任何输出</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;nopex&quot;</span>, NopThrowableInformationConverter.class</span><br><span class="line">        .getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;nopexception&quot;</span>,</span><br><span class="line">        NopThrowableInformationConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出在类附加到日志上的上下文名字. </span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;cn&quot;</span>, ContextNameConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;contextName&quot;</span>, ContextNameConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出产生日志事件的调用者的位置信息</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;caller&quot;</span>, CallerDataConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出和日志请求关联的marker</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;marker&quot;</span>, MarkerConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出属性对应的值，一般为System.properties中的属性</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;property&quot;</span>, PropertyConverter.class.getName());</span><br><span class="line">    <span class="comment">// 输出依赖系统的行分隔符</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;n&quot;</span>, LineSeparatorConverter.class.getName());</span><br><span class="line">    <span class="comment">// 相关的颜色格式设置</span></span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;black&quot;</span>, BlackCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;red&quot;</span>, RedCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;green&quot;</span>, GreenCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;yellow&quot;</span>, YellowCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;blue&quot;</span>, BlueCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;magenta&quot;</span>, MagentaCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;cyan&quot;</span>, CyanCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;white&quot;</span>, WhiteCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;gray&quot;</span>, GrayCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;boldRed&quot;</span>, BoldRedCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;boldGreen&quot;</span>, BoldGreenCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;boldYellow&quot;</span>, BoldYellowCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;boldBlue&quot;</span>, BoldBlueCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;boldMagenta&quot;</span>, BoldMagentaCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;boldCyan&quot;</span>, BoldCyanCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;boldWhite&quot;</span>, BoldWhiteCompositeConverter.class.getName());</span><br><span class="line">    defaultConverterMap.put(<span class="string">&quot;highlight&quot;</span>, HighlightingCompositeConverter.class.getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Notes：日志模板配置，使用 <code>%</code>为前缀让解析器识别特殊输出模式，然后以<code>&#123;&#125;</code>后缀结尾，内部指定相应的参数设置。</p></blockquote><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>所谓初始化，就是我们构建<code>logger</code>的时候。在<code>LoggerFactory.getLogger()</code>，调用的是 slf4j 的方法，而底层使用的是<code>logback</code>的实现。因此，初始化的重点就是找到底层具体的实现接口，然后构建具体类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    ILoggerFactory iLoggerFactory = getILoggerFactory();</span><br><span class="line">    <span class="keyword">return</span> iLoggerFactory.getLogger(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ILoggerFactory <span class="title">getILoggerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</span><br><span class="line">      INITIALIZATION_STATE = ONGOING_INITIALIZATION;</span><br><span class="line">      performInitialization();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (INITIALIZATION_STATE) &#123;</span><br><span class="line">      <span class="keyword">case</span> SUCCESSFUL_INITIALIZATION:</span><br><span class="line">        <span class="keyword">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();</span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">      <span class="keyword">case</span> ONGOING_INITIALIZATION:</span><br><span class="line">        <span class="comment">// support re-entrant behavior.</span></span><br><span class="line">        <span class="comment">// See also http://bugzilla.slf4j.org/show_bug.cgi?id=106</span></span><br><span class="line">        <span class="keyword">return</span> TEMP_FACTORY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Set staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();</span><br><span class="line">      <span class="comment">// the next line does the binding</span></span><br><span class="line">      <span class="comment">// 这里并没有使用上面的返回set进行反射构建类，这里实际上才是各种初始化的地方</span></span><br><span class="line">      StaticLoggerBinder.getSingleton();</span><br><span class="line">      INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;</span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Set <span class="title">findPossibleStaticLoggerBinderPathSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// use Set instead of list in order to deal with  bug #138</span></span><br><span class="line">    <span class="comment">// LinkedHashSet appropriate here because it preserves insertion order during iteration</span></span><br><span class="line">    Set staticLoggerBinderPathSet = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ClassLoader loggerFactoryClassLoader = LoggerFactory.class</span><br><span class="line">              .getClassLoader();</span><br><span class="line">      Enumeration paths;</span><br><span class="line">      <span class="keyword">if</span> (loggerFactoryClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        paths = loggerFactoryClassLoader</span><br><span class="line">                .getResources(STATIC_LOGGER_BINDER_PATH);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (paths.hasMoreElements()) &#123;</span><br><span class="line">        URL path = (URL) paths.nextElement();</span><br><span class="line">        staticLoggerBinderPathSet.add(path);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">      Util.report(<span class="string">&quot;Error getting resources from path&quot;</span>, ioe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> staticLoggerBinderPathSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上面的部分代码，可以很明显看出，slf4j 会去调用classloader获取当前加载的类中，实现了指定的接口<code>org/slf4j/impl/StaticLoggerBinder.class</code>的类，如果多余1个，则会抛出异常。</p><p>以上，依然可以从代码中看出这个只是检测是否存在符合接口的实现类，而没有像正常情况那样，通过反射构建类，返回给调用方。如何实现呢？</p><p>直接在自己的包中实现一个和 <code>slf4j</code>要求路径一样的类，实现对应的接口，然后就可以调用了。不明白，看代码吧。:)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.slf4j.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.status.StatusUtil;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.ILoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.helpers.Util;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.spi.LoggerFactoryBinder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.LoggerContext;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.util.ContextInitializer;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.util.ContextSelectorStaticBinder;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.core.CoreConstants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticLoggerBinder</span> <span class="keyword">implements</span> <span class="title">LoggerFactoryBinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> StaticLoggerBinder SINGLETON = <span class="keyword">new</span> StaticLoggerBinder();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    SINGLETON.init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里就是创建logback的LoggerContext实例， 包含了log所需的环境配置</span></span><br><span class="line">  <span class="keyword">private</span> LoggerContext defaultLoggerContext = <span class="keyword">new</span> LoggerContext();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ContextSelectorStaticBinder contextSelectorBinder = ContextSelectorStaticBinder</span><br><span class="line">      .getSingleton();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">StaticLoggerBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    defaultLoggerContext.setName(CoreConstants.DEFAULT_CONTEXT_NAME);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticLoggerBinder <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SINGLETON;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里会初始化配置文件和对应的模板，logback.xml解析</span></span><br><span class="line">        <span class="keyword">new</span> ContextInitializer(defaultLoggerContext).autoConfig();</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从 package 和 import 的信息，可以看出，logback 中实现了一个 <code>org.slf4j.impl.StaticLoggerBinder</code> 类，而这个类，在slf4j 的 API 包中直接使用，所以使用slf4j时，必须还要引入其他具体的第三方包来实现相应的接口方法。</p><p>此外，接下来的核心逻辑就是解析logback下各种配置文件信息，以及初始化配置。</p></blockquote><h3 id="输出日志模板解析"><a href="#输出日志模板解析" class="headerlink" title="输出日志模板解析"></a>输出日志模板解析</h3><p>如上所见，其实关于logback.xml的解析工作，也是在初始化的时候完成的。但是，由于其重要性，所以这里重点介绍下。</p><p>在 logback 中，解析xml的工作，都是交给 Action 和其继承类来完成。在 Action 类中提供了三个方法<code>begin</code>、<code>body</code>和<code>end</code>三个方法，这三个抽象方法中：</p><ul><li>begin 方法负责处理ElementSelector元素的解析；</li><li>body 方法，一般为空，处理文本的；</li><li>end 方法则是处理模板解析的，所以我们的logback.xml的模板解析实在end方法中。具体是在 <code>NestedComplexPropertyIA</code>类中来解析。其继承Action类，并且其会调用具体的模板解析工具类：<code>PatternLayoutEncoder</code>类和<code>PatternLayout</code>类。</li></ul><p><code>PatternLayoutEncoder</code>会创建一个<code>PatternLayout</code>对象，然后获取到logback.xml中配置的模板字符串，即<code>[%d&#123;yyyy-MM-dd HH:mm:ss&#125; %highlight(%-5p) %logger.%M\(%F:%L\)] %X&#123;THREAD_ID&#125; %msg%n</code>，如配置的节点名一样，其在代码中同样赋值给pattern变量。</p><p>接下来，PatternLayoutEncoder 会调用相关方法对pattern进行解析，然后构建一个节点链表，保存这个链表会在日志输出的时使用到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Parser</span><span class="params">(String pattern, IEscapeUtil escapeUtil)</span> <span class="keyword">throws</span> ScanException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TokenStream ts = <span class="keyword">new</span> TokenStream(pattern, escapeUtil);</span><br><span class="line">      <span class="keyword">this</span>.tokenList = ts.tokenize();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException npe) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ScanException(<span class="string">&quot;Failed to initialize Parser&quot;</span>, npe);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">TokenizerState</span> </span>&#123; LITERAL_STATE,  FORMAT_MODIFIER_STATE, KEYWORD_STATE, OPTION_STATE,  RIGHT_PARENTHESIS_STATE&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function">List <span class="title">tokenize</span><span class="params">()</span> <span class="keyword">throws</span> ScanException </span>&#123;</span><br><span class="line">    List&lt;Token&gt; tokenList = <span class="keyword">new</span> ArrayList&lt;Token&gt;();</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pointer &lt; patternLength) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = pattern.charAt(pointer);</span><br><span class="line">      pointer++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> LITERAL_STATE:</span><br><span class="line">          handleLiteralState(c, tokenList, buf);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FORMAT_MODIFIER_STATE:</span><br><span class="line">          handleFormatModifierState(c, tokenList, buf);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EOS</span></span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">      <span class="keyword">case</span> LITERAL_STATE:</span><br><span class="line">        addValuedToken(Token.LITERAL, buf, tokenList);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FORMAT_MODIFIER_STATE:</span><br><span class="line">      <span class="keyword">case</span> OPTION_STATE:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ScanException(<span class="string">&quot;Unexpected end of pattern string&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tokenList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建head链表</span></span><br><span class="line">  <span class="function">Converter&lt;E&gt; <span class="title">compile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node n = top; n != <span class="keyword">null</span>; n = n.next) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (n.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> Node.LITERAL:</span><br><span class="line">          addToList(<span class="keyword">new</span> LiteralConverter&lt;E&gt;((String) n.getValue()));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Node.COMPOSITE_KEYWORD:</span><br><span class="line">          CompositeNode cn = (CompositeNode) n;</span><br><span class="line">          CompositeConverter&lt;E&gt; compositeConverter = createCompositeConverter(cn);</span><br><span class="line">          <span class="keyword">if</span>(compositeConverter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            addError(<span class="string">&quot;Failed to create converter for [%&quot;</span>+cn.getValue()+<span class="string">&quot;] keyword&quot;</span>);</span><br><span class="line">            addToList(<span class="keyword">new</span> LiteralConverter&lt;E&gt;(<span class="string">&quot;%PARSER_ERROR[&quot;</span>+cn.getValue()+<span class="string">&quot;]&quot;</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          compositeConverter.setFormattingInfo(cn.getFormatInfo());</span><br><span class="line">          compositeConverter.setOptionList(cn.getOptions());</span><br><span class="line">          Compiler&lt;E&gt; childCompiler = <span class="keyword">new</span> Compiler&lt;E&gt;(cn.getChildNode(),</span><br><span class="line">                  converterMap);</span><br><span class="line">          childCompiler.setContext(context);</span><br><span class="line">          Converter&lt;E&gt; childConverter = childCompiler.compile();</span><br><span class="line">          compositeConverter.setChildConverter(childConverter);</span><br><span class="line">          addToList(compositeConverter);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Node.SIMPLE_KEYWORD:</span><br><span class="line">          SimpleKeywordNode kn = (SimpleKeywordNode) n;</span><br><span class="line">          DynamicConverter&lt;E&gt; dynaConverter = createConverter(kn);</span><br><span class="line">          <span class="keyword">if</span> (dynaConverter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dynaConverter.setFormattingInfo(kn.getFormatInfo());</span><br><span class="line">            dynaConverter.setOptionList(kn.getOptions());</span><br><span class="line">            addToList(dynaConverter);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if the appropriate dynaconverter cannot be found, then replace</span></span><br><span class="line">            <span class="comment">// it with a dummy LiteralConverter indicating an error.</span></span><br><span class="line">            Converter&lt;E&gt; errConveter = <span class="keyword">new</span> LiteralConverter&lt;E&gt;(<span class="string">&quot;%PARSER_ERROR[&quot;</span></span><br><span class="line">                    + kn.getValue() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            addStatus(<span class="keyword">new</span> ErrorStatus(<span class="string">&quot;[&quot;</span> + kn.getValue()</span><br><span class="line">                    + <span class="string">&quot;] is not a valid conversion word&quot;</span>, <span class="keyword">this</span>));</span><br><span class="line">            addToList(errConveter);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码很简单，就是依次遍历pattern字符串，然后把符合要求的字符串放进tokenList中，这个list就维护了我们最终需要输出的模板的格式化模式了。</p><p>在每个case里面，都会对字符串进行特定的处理，匹配具体的字符。</p><p>在随后的处理中，会将这个tokenList进行转换，成为我们需要的Node类型的拥有head 和 tail 的链表。</p></blockquote><h3 id="日志输出分析"><a href="#日志输出分析" class="headerlink" title="日志输出分析"></a>日志输出分析</h3><p>构建了各种需要的环境参数，打印日志就很简单了。在需要输出日志的时候，根据初始化得到的Node链表head来解析，遇到%X的时候，从MDC中获取对应的key值，然后append到日志字符串中，然后输出。</p><blockquote><p>在配置文件中，我们使用Appender模式，在日志输出类中，显然会调用append类似的方法了。:)</p><p>其调用流程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamAppender</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">UnsynchronizedAppenderBase</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(E eventObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isStarted()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subAppend(eventObject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里就是日志输出实际的操作，一般如果有需要，可以重写这个方法。</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subAppend</span><span class="params">(E event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isStarted()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// this step avoids LBCLASSIC-139</span></span><br><span class="line">      <span class="keyword">if</span> (event <span class="keyword">instanceof</span> DeferredProcessingAware) &#123;</span><br><span class="line">        <span class="comment">// 这里虽然是为输出准备，在检查的同时，把把必要的信息解析出来放到变量中</span></span><br><span class="line">        ((DeferredProcessingAware) event).prepareForDeferredProcessing();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// the synchronization prevents the OutputStream from being closed while we</span></span><br><span class="line">      <span class="comment">// are writing. It also prevents multiple threads from entering the same</span></span><br><span class="line">      <span class="comment">// converter. Converters assume that they are in a synchronized block.</span></span><br><span class="line">      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 避免多线程的问题，这里加了锁。而写日志的核心也是在这里</span></span><br><span class="line">        writeOut(event);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">      <span class="comment">// as soon as an exception occurs, move to non-started state</span></span><br><span class="line">      <span class="comment">// and add a single ErrorStatus to the SM.</span></span><br><span class="line">      <span class="keyword">this</span>.started = <span class="keyword">false</span>;</span><br><span class="line">      addStatus(<span class="keyword">new</span> ErrorStatus(<span class="string">&quot;IO failure in appender&quot;</span>, <span class="keyword">this</span>, ioe));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里将会调用前面我们提到过的模板类，有该类对解析出来的模板按照当前环境进行输出</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeOut</span><span class="params">(E event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.encoder.doEncode(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Notes：在<code>prepareForDeferredProcessing</code>中，查询了一些常用值，比如当前线程名，比如mdc设置赋值到Map中。而这些信息，当准备结束没有出现问题时，则会给后面的输出日志时公用。</p><p>这种方式，其实在我们的代码中，也可以参考。一般我们可能对当前上下文的入参检查会去查询数据库等耗费CPU或者IO的操作，然后check ok的时候，又会在正常的业务中再次做相同的重复工作，导致不必要的性能损失。</p></blockquote><p>接下来看看，针对模板进行按需获取属性值，然后输出日志的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这里的逻辑就是按照模板获取值然后转换成字节流输出到后台</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doEncode</span><span class="params">(E event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  String txt = layout.doLayout(event);</span><br><span class="line">  outputStream.write(convertToBytes(txt));</span><br><span class="line">  <span class="keyword">if</span> (immediateFlush)</span><br><span class="line">    outputStream.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doLayout</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isStarted()) &#123;</span><br><span class="line">    <span class="keyword">return</span> CoreConstants.EMPTY_STRING;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> writeLoopOnConverters(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化的时候，就介绍过最后会构建一个head链表，</span></span><br><span class="line"><span class="comment">// 这里输出就是按照解析后的链表进行分析输出的。然后根据c类型不同，获取字符串方法也不同</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">writeLoopOnConverters</span><span class="params">(E event)</span> </span>&#123;</span><br><span class="line">  StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">  Converter&lt;E&gt; c = head;</span><br><span class="line">  <span class="keyword">while</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">    c.write(buf, event);</span><br><span class="line">    c = c.getNext();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在<code>writeLoopOnConverters</code>方法中，获取对应字符串是不同的，其根据不同的Converter，输出也不同。而Converter的判断，时就是根据我们配置的map映射来的，在初始化一节的时候，介绍的<code>PatternLayout</code>就包含各种映射关系。至于具体的convert方法，看看mdc的实现：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MDCConverter</span> <span class="keyword">extends</span> <span class="title">ClassicConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String key;</span><br><span class="line">  <span class="keyword">private</span> String defaultValue = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] keyInfo = extractDefaultReplacement(getFirstOption());</span><br><span class="line">    key = keyInfo[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (keyInfo[<span class="number">1</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">      defaultValue = keyInfo[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    key = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.stop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; mdcPropertyMap = event.getMDCPropertyMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mdcPropertyMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> outputMDCForAllKeys(mdcPropertyMap);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      String value = event.getMDCPropertyMap().get(key);<span class="comment">//获取key的值</span></span><br><span class="line">      <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * if no key is specified, return all the values present in the MDC, in the format &quot;k1=v1, k2=v2, ...&quot;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">outputMDCForAllKeys</span><span class="params">(Map&lt;String, String&gt; mdcPropertyMap)</span> </span>&#123;</span><br><span class="line">    StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : mdcPropertyMap.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        first = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//format: key0=value0, key1=value1</span></span><br><span class="line">      buf.append(entry.getKey()).append(<span class="string">&#x27;=&#x27;</span>).append(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>我们在MDC实现的时候看到的get方法，在这里就使用了。我们将key:value键值对存放到MDC之后，在logback.xml中配置%X{key}，没有直接调用get方法，logback会根据<code>X</code>判断是MDC类型，然后根据<code>key</code>拿到MDC中对应的value，然后返回给buf中，最后append到后台日志上。</p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a><a id="End">后记</a></h2><p>其实，本身的 MDC 使用很简单，实现原理也很简单。但是，这里为了分析从将 key:value put 进MDC，然后怎么获取，怎么打印到后台的逻辑，对整个从 SLF4J 到 logback 的运行流程进场了大体解析。而对不影响理解的一些枝节，进行了删减。因此，如果需要完全弄清楚整个逻辑，还需要进行详细分析源码。</p><p>在目前的代码中，我们在web.xml 中配置了 filter 来将一些用户个人访问特征存入了MDC中，这样可以获取一个用户的操作流程，根据某一个访问特征去grep的话。</p><p>下一次，将分享下这种实现细节背后的一些技术。虽然实现很简单，但是想深入分析下filter机制和web = tomcat + spring mvc 的请求处理流程，这些技术细节，是如何使一个MDC信息可以保存一个用户依次的访问流水记录。</p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 教程学习之 Python 面向对象编程</title>
      <link href="2015/02/26/2015-02-26-Python-Tutoril-Python-Object-Oriented-Programming/"/>
      <url>2015/02/26/2015-02-26-Python-Tutoril-Python-Object-Oriented-Programming/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>在之前的学习中,基本上都是使用类似于面对过程的方式来写代码,学习各种 Python 的基础知识，接下来，我们需要继续学习面向对象的Python，也就是类对象继承等概念。</p><p>对象和属性，这些概念在任务编程语言中，其定义都是一致的。我们通过一个对象来表示一个物体，而这个物体的一些特征，就是对象中的属性。比如，一个人，作为一个对象 Person，则会有<code>姓名，身高，体重，性别，出生日期</code>等属性，这些属性就是这个人的对外特性了。</p><h2 id="Python-面向对象编程介绍"><a href="#Python-面向对象编程介绍" class="headerlink" title="Python 面向对象编程介绍"></a><a id="BasicGuide">Python 面向对象编程介绍</a></h2><p>类，就是对一类物体进行抽象的表示，比如上面的 Person；而实例，则是具体化了每一个类的属性值，其可以决定某一个物体特征的对象。</p><p>在 Python 中，可以如下来定义一个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;docstring for Person&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Person, self).__init__()</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><p><code>class</code> 用来表示这是一个类，<code>object</code> 表示该类继承的父类，默认是 object，但是推荐是写上父类，即使其继承 <code>object</code>类。</p><blockquote><p>Tips：Python 中，默认规定，类下面的第一行注释，是该类的 doc 说明。</p><p>此外，<code>__xx__</code>形式的属性和方法，在Python中都是有特殊用途的，比如 <strong>len</strong> 方法返回长度，再比如 <strong>init</strong> 方法是类对象初始化时调用的，<strong>new</strong> 方法则是构造对象的时候调用的，即在 <code>__init__</code> 之前调用。</p></blockquote><p>接下来，需要说明的是，Python 的权限控制。</p><p>和 Java 完全不一样，Python 没有关键字来说明该变量属性或者方法是 私有的 还是受保护的，亦或者是公共的。</p><p>Python 使用一种约定的方式来，声明访问限制的粒度。</p><ul><li><p>xx ：这种方式命名的变量或者方法，都是 <code>public</code>粒度的；</p></li><li><p>_xx ：这种方式命名的变量或者方法，都是 <code>protected</code>粒度的；</p></li><li><p> __xx ：私有属性的变量或者方法，外部调用会报错的。</p></li></ul><p>Python 中拥有的一些特殊功能的方法：</p><ul><li><p>type() ：获取对象的类型，比如，type(‘abc’)会返回 <code>&lt;type &#39;str&#39;&gt;</code> .</p></li><li><p>isinstance()：type 方法不能很好的判断拥有继承关系的对象，而 <code>isinstance</code> 则可以。例如：<code>isinstance(person,object) #person是Person的实例</code>.</p></li><li><p>dir()：想要获取一个类下面所有的方法吗？使用 dir 就可以了，比如<code>dir(&#39;abc&#39;)</code></p></li><li><p>hasattr/getattr/setattr()：依次是判断一个对象是否有指定属性，获取该属性，设置某个属性</p></li></ul><h2 id="Python-面向对象编程技巧"><a href="#Python-面向对象编程技巧" class="headerlink" title="Python 面向对象编程技巧"></a><a id="AdvancedTech">Python 面向对象编程技巧</a></h2><p>Python 中还有一些比较高大上的技巧。</p><p><em><code>@property</code>装饰器</em></p><p>装饰器概念，在 <code>Python 函数式编程</code> 中已经介绍了。我们在类的代码 coding 中，有一些可能想要把方法使用如同属性使用般方便，则可以使用<code>@property</code>装饰器。</p><p>注解方式，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@age.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self, value</span>):</span></span><br><span class="line">    self.__age = value</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>metaclass 元类</em></p><p>Python 中，元类是一个很神奇的东西，由于其涉及到了底层的类结构构造，所以全部深入理解起来，可能会比较复杂。</p><p>关于元类的资料，可以参考<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a>，第一个 answer 回答的特别棒。</p><p>当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。</p><p>但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。</p><p>连接起来就是：先定义metaclass，就可以创建类，最后创建实例。</p><p>所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。</p><p>现在，一个简单的示例，就是，对于该类所有的自定义属性，其name都大写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Female</span>(<span class="params">Person.Person</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;docstring for Female&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log_construct</span>(<span class="params">class_name, class_parent, class_attr</span>):</span></span><br><span class="line">        logging.info(<span class="string">&#x27;==----==---contruct---===---&#x27;</span>)</span><br><span class="line">        upper_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> class_attr.items():</span><br><span class="line">            <span class="keyword">if</span> key.startswith(<span class="string">&#x27;__&#x27;</span>):  <span class="comment"># 不能改变class自带的属性</span></span><br><span class="line">                upper_attr[key] = value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                upper_attr[key.upper()] = value</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(class_name, class_parent, upper_attr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, married</span>):</span></span><br><span class="line">        Person.Person.__init__(self, name)</span><br><span class="line">        self.__married = married</span><br><span class="line"></span><br><span class="line">    __metaclass__ = log_construct</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    felame = Female(<span class="string">&#x27;ketao1989&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">    felame.age = <span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span> felame</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hasattr</span>(Female, <span class="string">&#x27;MARRIED&#x27;</span>) <span class="comment"># 返回Ture</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Python-面向对象编程代码示例"><a href="#Python-面向对象编程代码示例" class="headerlink" title="Python 面向对象编程代码示例"></a><a id="SourceCode">Python 面向对象编程代码示例</a></h2><p>这里主要是两个类，涉及到继承，和一些面向对象的使用方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Date    : 2015-02-22 19:49:20</span></span><br><span class="line"><span class="comment"># @Author  : ketao1989</span></span><br><span class="line"><span class="comment"># @Version : $Id$</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;docstring for Person&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Person, self).__init__()</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__name = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__tranform_name(self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__tranform_name</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;_test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__age</span><br><span class="line">        <span class="keyword">except</span> Exception, e:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__age = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;%s &#x27;s age is : %s&quot;</span> % (self.get_name(), self.age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    person = Person(<span class="string">&#x27;ketao1989&#x27;</span>)</span><br><span class="line">    person.age = <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span> person.name</span><br><span class="line">    <span class="built_in">print</span> person</span><br><span class="line">    <span class="built_in">print</span> os.uname()</span><br><span class="line">    <span class="built_in">print</span> os.getenv(<span class="string">&#x27;PATH&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">dir</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Date    : 2015-02-22 20:34:46</span></span><br><span class="line"><span class="comment"># @Author  : ketao1989</span></span><br><span class="line"><span class="comment"># @Version : $Id$</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> Person</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Female</span>(<span class="params">Person.Person</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;docstring for Female&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log_construct</span>(<span class="params">class_name, class_parent, class_attr</span>):</span></span><br><span class="line">        logging.info(<span class="string">&#x27;==----==---contruct---===---&#x27;</span>)</span><br><span class="line">        upper_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> class_attr.items():</span><br><span class="line">            <span class="keyword">if</span> key.startswith(<span class="string">&#x27;__&#x27;</span>):  <span class="comment"># 不能改变class自带的属性</span></span><br><span class="line">                upper_attr[key] = value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                upper_attr[key.upper()] = value</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(class_name, class_parent, upper_attr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, married</span>):</span></span><br><span class="line">        Person.Person.__init__(self, name)</span><br><span class="line">        self.__married = married</span><br><span class="line"></span><br><span class="line">    __metaclass__ = log_construct</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">married</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__married</span><br><span class="line"></span><br><span class="line"><span class="meta">    @married.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">married</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__married = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name + <span class="string">&quot;_Female____&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        prefix = Person.Person.__str__(self)</span><br><span class="line">        <span class="keyword">return</span> prefix + <span class="string">&quot;,married is : %s&quot;</span> % <span class="built_in">str</span>(self.MARRIED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    felame = Female(<span class="string">&#x27;ketao1989&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">    felame.age = <span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span> felame</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hasattr</span>(Female, <span class="string">&#x27;MARRIED&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> Female</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hasattr</span>(Female, <span class="string">&#x27;job&#x27;</span>)</span><br><span class="line">    felame.job = <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hasattr</span>(felame, <span class="string">&#x27;job&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> felame.name</span><br><span class="line"></span><br><span class="line">    felame1 = Female(<span class="string">&#x27;ketao&#x27;</span>, <span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hasattr</span>(Female, <span class="string">&#x27;job&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hasattr</span>(felame1, <span class="string">&#x27;job&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hasattr</span>(felame, <span class="string">&#x27;job&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> felame.__class__.__class__</span><br><span class="line">    <span class="built_in">print</span> json.dumps(felame, default=<span class="keyword">lambda</span> obj: obj.__dict__)</span><br><span class="line">    json_str = <span class="string">&#x27;&#123;&quot;_Person__name&quot;: &quot;ketao1989&quot;, &quot;_Person__age&quot;: 100, &quot;job&quot;: &quot;dev&quot;, &quot;_Female__married&quot;: false&#125;&#x27;</span></span><br><span class="line">    felame2 = json.loads(json_str)</span><br><span class="line">    <span class="built_in">print</span> felame2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes : 在Female类中，继承需要写成<code>Person.Person</code>的形式，前面的<code>Person</code>是module,后面的 <code>Person</code>才是类。</p><p>此外，使用metaClass方式更改属性时，只会修改该类自己的属性，而不会更改其继承的父类的属性名。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 教程学习之 Python 函数式编程</title>
      <link href="2015/02/17/2015-02-17-Python-Tutoril-Python-Functional-Programing/"/>
      <url>2015/02/17/2015-02-17-Python-Tutoril-Python-Functional-Programing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>函数式编程是一种比较抽象的编程范式,其将各种指令计算运行作为数学中函数计算一样,尽量避免状态和变量的概念,因此函数式编程,一大特点就是无副作用,这对于并发编程大行其道的今天,是非常优良的特点.</p><p>Python 作为一个动态脚本语言，其很早就支持了函数式编程范式。</p><h2 id="Python-函数式编程"><a href="#Python-函数式编程" class="headerlink" title="Python 函数式编程"></a><a id="FunctionalProgram">Python 函数式编程</a></h2><p>Python 函数式编程，涉及太多的内容。简单介绍几个点。</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>所谓高阶函数，和数学上的高阶函数定义基本一样，就是对函数进行计算处理的函数。其处理对象是另一个函数。</p><p><em>Map 和 Reduce 函数</em></p><p>云计算中，关于 MapReduce 的并行计算框架，在其他很多编程语言中，都会提供 API 方法。即使在Java这种笨重的语言中，也已经提供了相关的方法给开发者使用。</p><p>Python 的 map 方法，表示分别对列表中的元素独立处理；Reduce 方法，则表示对map处理完的结果，按照指定的方式进行聚合处理。</p><span id="more"></span><p>看看示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowerLetter</span>(<span class="params">c</span>):</span></span><br><span class="line">    <span class="keyword">if</span> c &gt;= <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> c &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstUpper</span>(<span class="params">s</span>):</span></span><br><span class="line">    ss = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> lowerLetter(s[i]):</span><br><span class="line">                ss = ss + <span class="built_in">chr</span>(<span class="built_in">ord</span>(s[i]) + <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ss = ss + s[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> lowerLetter(s[i]):</span><br><span class="line">                ss = ss + s[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ss = ss + <span class="built_in">chr</span>(<span class="built_in">ord</span>(s[i]) + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> ss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeWords</span>(<span class="params">strA, strB</span>):</span></span><br><span class="line">    <span class="keyword">return</span> strA + <span class="string">&#x27;-&#x27;</span> + strB</span><br><span class="line"></span><br><span class="line">mm = <span class="built_in">map</span>(firstUpper, [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;zfc&#x27;</span>, <span class="string">&#x27;Azc&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> mm</span><br><span class="line"></span><br><span class="line">rr = reduce(mergeWords, mm)</span><br><span class="line"><span class="built_in">print</span> rr</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes ：  </p><ul><li><p>map 方法，对每个列表的元素处理，开头字符大写，其他字母都小写。代码中使用了最简单的原始字符处理方式处理，主要是学习下python的字节操作方法。</p></li><li><p>Reduce方法，则把所有的单词都聚合在一起，使用<code>-</code>相连。reduce 方法会自动依次取出上一次的reduce结果和接下来的元素，再调用reduce处理。</p></li></ul></blockquote><p><em>filter 函数</em></p><p>filter 函数用来按照我们的要求，过滤队列。我们首先，给出一个过滤条件来依次判断列表的元素是否满足，根据返回的<code>True</code>或则<code>False</code>来决定去留。</p><p>看看示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contains</span>(<span class="params">ss, subStr=<span class="string">&#x27;z&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> ss.find(subStr) != -<span class="number">1</span></span><br><span class="line"><span class="comment"># [&#x27;zfc&#x27;, &#x27;Azc&#x27;]</span></span><br><span class="line">ff = <span class="built_in">filter</span>(contains, [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;zfc&#x27;</span>, <span class="string">&#x27;Azc&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> ff</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>sorted 函数</em></p><p>排序方法，对列表按照比较函数的返回结果，进行排序，返回排序完之后的列表。</p><p>看看示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;Azc&#x27;, &#x27;abc&#x27;, &#x27;zfc&#x27;]</span></span><br><span class="line">sl = <span class="built_in">sorted</span>([<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;zfc&#x27;</span>, <span class="string">&#x27;Azc&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> sl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">revertSortCmp</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; y:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> x == y:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;zfc&#x27;, &#x27;abc&#x27;, &#x27;Azc&#x27;]</span></span><br><span class="line">rsl = <span class="built_in">sorted</span>([<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;zfc&#x27;</span>, <span class="string">&#x27;Azc&#x27;</span>], revertSortCmp)</span><br><span class="line"><span class="built_in">print</span> rsl</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h3><p>所谓返回函数，其实这也是函数式编程的核心之一。因为有了返回函数，我们可以确保函数式编程方法在获取结果的时候，才会执行；而不是，赋值函数的时候，立即执行。</p><p>这种延迟计算的特性，使得很多时候，可以获得更好的计算性能。</p><p>看看示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_tranform</span>(<span class="params">ll</span>):</span></span><br><span class="line">    resTotal = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tranform</span>():</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> ll:</span><br><span class="line">            xf = x + <span class="string">&#x27;-tranform&#x27;</span></span><br><span class="line">            res.append(xf)</span><br><span class="line">            resTotal.append(xf)</span><br><span class="line">        <span class="keyword">return</span> res, resTotal</span><br><span class="line">    <span class="keyword">return</span> tranform</span><br><span class="line"></span><br><span class="line">lf = lazy_tranform([<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;zfc&#x27;</span>, <span class="string">&#x27;Azc&#x27;</span>])</span><br><span class="line"><span class="comment">#&lt;function tranform at 0x1006309b0&gt;</span></span><br><span class="line"><span class="built_in">print</span> lf</span><br><span class="line"><span class="comment">#([&#x27;abc-tranform&#x27;, &#x27;zfc-tranform&#x27;, &#x27;Azc-tranform&#x27;], [&#x27;abc-tranform&#x27;, &#x27;zfc-tranform&#x27;, &#x27;Azc-tranform&#x27;])</span></span><br><span class="line"><span class="built_in">print</span> lf()</span><br><span class="line"><span class="comment">#([&#x27;abc-tranform&#x27;, &#x27;zfc-tranform&#x27;, &#x27;Azc-tranform&#x27;], [&#x27;abc-tranform&#x27;, &#x27;zfc-tranform&#x27;, &#x27;Azc-tranform&#x27;, &#x27;abc-tranform&#x27;, &#x27;zfc-tranform&#x27;, &#x27;Azc-tranform&#x27;])</span></span><br><span class="line"><span class="built_in">print</span> lf()</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes ：可以看到上面，对于<code>resTotal</code>变量，当函数多次运行，结果会重复 append 到列表中。 也就是说，对于返回函数，这种变量<code>resTotal</code>定义相对于是全局的，所有使用该函数的地方，都会这个变量进行变更。</p><p>上面的代码，如果不了解，是很难定位到错误的。下面的代码，告诉你，如果你非要这样子写，应该如何处理这种涉及到<code>闭包</code>的问题。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closure_tranform</span>(<span class="params">ll</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> ll:</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tranform</span>():</span></span><br><span class="line">            xf = x + <span class="string">&#x27;-tranform&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> xf</span><br><span class="line">        res.append(tranform)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;function tranform at 0x100630aa0&gt; &lt;function tranform at 0x100630b18&gt; &lt;function tranform at 0x100630b90&gt;</span></span><br><span class="line"><span class="comment"># Azc-tranform Azc-tranform Azc-tranform</span></span><br><span class="line">lf1, lf2, lf3 = closure_tranform([<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;zfc&#x27;</span>, <span class="string">&#x27;Azc&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> lf1, lf2, lf3</span><br><span class="line"><span class="built_in">print</span> lf1(), lf2(), lf3()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closure_tranform_opz</span>(<span class="params">ll</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> ll:</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tranform</span>(<span class="params">y</span>):</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">tranform_closure</span>():</span></span><br><span class="line">                xf = y + <span class="string">&#x27;-tranform&#x27;</span></span><br><span class="line">                <span class="keyword">return</span> xf</span><br><span class="line">            <span class="keyword">return</span> tranform_closure</span><br><span class="line">        res.append(tranform(x))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># &lt;function tranform_closure at 0x100630cf8&gt; &lt;function tranform_closure at 0x100630c80&gt; &lt;function tranform_closure at 0x100630d70&gt;</span></span><br><span class="line"><span class="comment"># abc-tranform zfc-tranform Azc-tranform</span></span><br><span class="line">lfo1, lfo2, lfo3 = closure_tranform_opz([<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;zfc&#x27;</span>, <span class="string">&#x27;Azc&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> lfo1, lfo2, lfo3</span><br><span class="line"><span class="built_in">print</span> lfo1(), lfo2(), lfo3()</span><br></pre></td></tr></table></figure><blockquote><p>Notes ：出现这种现象，就是因为我们的方法都是延迟加载，也就是说，最后的变量已经变更了，上面的代码中<code>i</code>就像<code>resTotal</code> 一样，是个全局变量，所以会在多次调用函数中彼此影响。</p></blockquote><h2 id="Python-装饰器"><a href="#Python-装饰器" class="headerlink" title="Python 装饰器"></a><a id="Decorator">Python 装饰器</a></h2><p>熟悉 AOP 面向方面编程的同学，都了解切点，切面等概念。重要的是，使用 AOP 编程，可以让核心的业务代码和运维调试等代码切分开，也可以让老代码在一定程度上更容易升级。比如最通用的场景：日志记录，事务管理，权限拦截，自定义数据管理等。</p><p>在 Python 中，完成 AOP 编码范式的就是<code>Python 装饰器</code>。使用 <code>@</code>标记，就可以完成 AOP 简单功能了。</p><p>看看示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span>(<span class="params">user_name=<span class="string">&#x27;ketao1989&#x27;</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kv</span>):</span></span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;Welcome,&#x27;</span>, user_name, func.__name__</span><br><span class="line">            func(*args, **kv)</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;Goodbye,&#x27;</span>, user_name, func.__name__</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(func, <span class="built_in">str</span>):</span><br><span class="line">        <span class="keyword">return</span> logger(func)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kv</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Welcome,&#x27;</span>, func.__name__</span><br><span class="line">        func(*args, **kv)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Goodbye,&#x27;</span>, func.__name__</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#@log(&#x27;ketao1989&#x27;)</span></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger_test</span>(<span class="params">params</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;execute core function (%s) ......&#x27;</span> % params</span><br><span class="line"></span><br><span class="line">logger_test([<span class="string">&#x27;test_param1&#x27;</span>, <span class="string">&#x27;test_param2&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes：代码示例中，标记<code>@functools.wraps(func)</code>，是因为在装饰器中可能原始的函数的<code>__name__</code>等被覆盖，而该标注，可以保证原始携带的func的内置属性依然保持。</p><p>此外，在代码的开始，需要<code>import functools</code>引入模块。</p></blockquote><p>关于 Python 装饰器参考：<a href="http://www.cnblogs.com/huxi/archive/2011/03/01/1967600.html">http://www.cnblogs.com/huxi/archive/2011/03/01/1967600.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 教程学习之 Python 函数和高级特性</title>
      <link href="2015/02/15/2015-02-15-Python-Tutoril-Python-Function-And-Advances/"/>
      <url>2015/02/15/2015-02-15-Python-Tutoril-Python-Function-And-Advances/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>上一篇博客简单介绍了 Python 基本的概念和操作方法。但是，和其他编程语言一样，是缺少不了函数的。有了函数，代码才会被多次复用，程序才会简洁和易读。</p><p>同样，也是为了开发的简洁，Python 还为提供了 Slice切片等高级特性。切片可让我们更方便的操作列表数据结构，也使得代码更易开发和阅读。</p><h2 id="Python-函数"><a href="#Python-函数" class="headerlink" title="Python 函数"></a><a id="Function">Python 函数</a></h2><p>Python 函数和数学中函数的概念是一致的，都是对逻辑的一种抽象表示。在 Python 中，我们通过def来定义一个函数方法。</p><span id="more"></span><p>Python 的一些函数方法使用，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Date    : 2015-02-14 11:08:03</span></span><br><span class="line"><span class="comment"># @Author  : ketao1989</span></span><br><span class="line"><span class="comment"># @Version : $Id$</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funTypeCheck</span>(<span class="params">x</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, <span class="built_in">int</span>):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;类型不一致&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;x is my number&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;x is not my number&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moreReturns</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; y:</span><br><span class="line">        y = <span class="number">101</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x = <span class="number">101</span></span><br><span class="line">    <span class="keyword">return</span> x, y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">defaultParams</span>(<span class="params">x, n=<span class="number">2</span>, extra=<span class="number">0</span></span>):</span></span><br><span class="line">    multiply = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        multiply = multiply * x</span><br><span class="line">    <span class="keyword">return</span> multiply + extra</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variableParams</span>(<span class="params">*numbers</span>):</span></span><br><span class="line">    sum1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">        sum1 += num</span><br><span class="line">    <span class="keyword">return</span> sum1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variableDictParams</span>(<span class="params">name, **kw</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;----&#x27;</span>, name, <span class="string">&#x27;----&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> kw</span><br><span class="line"></span><br><span class="line"><span class="comment"># @tail_call_optimized</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factFunction</span>(<span class="params">s, n</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">return</span> factFunction(s * n, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    funTypeCheck(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    x, y = moreReturns(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="built_in">print</span> x, y</span><br><span class="line"></span><br><span class="line">    multiply = defaultParams(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span> multiply</span><br><span class="line">    multiply = defaultParams(<span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span> multiply</span><br><span class="line">    multiply = defaultParams(<span class="number">5</span>, extra=<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span> multiply</span><br><span class="line"></span><br><span class="line">    sum1 = variableParams(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span> sum1</span><br><span class="line"></span><br><span class="line">    variableDictParams(<span class="string">&#x27;ketao1989&#x27;</span>, web=<span class="string">&#x27;ketao1989.github.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> factFunction(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------&#x27;</span>)</span><br><span class="line">    funTypeCheck(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes：<code>isinstance</code> 方法判断是否是指定类型。</p><ul><li><p><code>moreReturns(x, y)</code> 函数，返回多个结果。其本质上，就是返回一个tuple.</p></li><li><p><code>defaultParams(x, n=2, extra=0)</code> 函数，设置默认的参数值。在调用的时候，我们可以替换任意一个默认的参数，比如extra，可以：<code>defaultParams(5, extra=2)</code></p></li><li><p><code>variableParams(*numbers)</code> 函数，设置可变个值。</p></li><li><p><code>variableDictParams(name, **kv)</code>函数，设置可变你的参数。其实，其类似Map来根据调用方确定参数。</p></li></ul></blockquote><h2 id="Python-高级特性"><a href="#Python-高级特性" class="headerlink" title="Python 高级特性"></a><a id="Advanced">Python 高级特性</a></h2><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片，很简单。就是我们日常对列表进行sub操作的时候，一般需要<code>for</code>循环操作，而 Python 提供了一个更简单的方法来处理这些问题，就是切片。其，表示形式为:<code>[i:j:k]</code>，其中，i表示列表的开始位置索引，j表示列表的结束位置索引（不包含该文章）,k表示循环步长。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ll = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [4, 6],开始:结束:步长</span></span><br><span class="line"><span class="built_in">print</span> ll[<span class="number">1</span>:<span class="number">3</span>:<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># (1, 3, 5)</span></span><br><span class="line"><span class="built_in">print</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,)[<span class="number">0</span>::<span class="number">2</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>Python 的迭代，相对于 C 语言的迭代语法，有了很大的进步。使用 <code>for ... in</code> 方式来遍历一个集合或者 Map 数据，方便快捷。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ll = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">24</span>, <span class="number">23</span>, <span class="number">56</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> ll:</span><br><span class="line">    <span class="built_in">print</span> x</span><br><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(ll):</span><br><span class="line">    <span class="built_in">print</span> i, value</span><br><span class="line"></span><br><span class="line">lt = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> lt:</span><br><span class="line">    <span class="built_in">print</span> x, y</span><br><span class="line"></span><br><span class="line">dd = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;d&#x27;</span>: <span class="string">&#x27;D&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dd:</span><br><span class="line">    <span class="built_in">print</span> key</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dd.itervalues():</span><br><span class="line">    <span class="built_in">print</span> value</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> dd.iteritems():</span><br><span class="line">    <span class="built_in">print</span> key, value</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="列表生成器"><a href="#列表生成器" class="headerlink" title="列表生成器"></a>列表生成器</h3><p>迭代对于列表的优化还不够，Python 还提供了更牛逼的特性：让我们一行代码生成一个列表。</p><p>比如，生成一个 1 到 10 数字的平方数，组成一个列表，使用列表生成器，可以如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lg = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span> lg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生偶数的平方数</span></span><br><span class="line">lo = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span> lo</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes ：由于列表生成器，是一次生成所有的列表元素，对于很大的列表，如果一次生成完成，然后全部放在内存里，肯定是不好的，因此，Python 还提供了 <code>生成器</code>。</p></blockquote><p>生成器，可以根据生成规则，在使用的时候，才会构造元素。构造简单的生成器，和列表生成器一样，只需要把<code>[ ]</code> 替换成<code>( )</code>即可。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x107de44b0&gt;</span></span><br><span class="line">lg = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span> lg</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Tips：如果需要打印，可以使用for，单个使用.next()方法依次调用，直到出现异常。</p></blockquote><p>对于复杂一点的生成器，则需要使用 <code>yield</code> 关键字来完成。比如，在我们的一些函数中，某一个变量连续产生的数组，可以使用<code>yield x</code>来完成生成器设置。</p><p>例如，构造一个通俗的生成器，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateFun</span>():</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="keyword">yield</span> x * x</span><br><span class="line"><span class="comment"># &lt;generator object generateFun at 0x102f5a5a0&gt;</span></span><br><span class="line">gf = generateFun()</span><br><span class="line"><span class="built_in">print</span> gf</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> gf:</span><br><span class="line">    <span class="built_in">print</span> x</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 教程学习之Python基础知识</title>
      <link href="2015/02/13/2015-02-13-Python-Tutoril-Python-Basic-Knowledge/"/>
      <url>2015/02/13/2015-02-13-Python-Tutoril-Python-Basic-Knowledge/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>2015年春节临近，提前请假回家，闲下来的功夫，系统学习下 python 语言，倒是也好。</p><p>Python 在日常工作中，主要是脚本语言的开发，由于开发快捷容易，并且在所有 Linux 版本都会安装 Python 的语言环境，不需要额外的配置工作。</p><h2 id="Sublime-Python-插件安装"><a href="#Sublime-Python-插件安装" class="headerlink" title="Sublime Python 插件安装"></a><a id="Sublime">Sublime Python 插件安装</a></h2><p>对于 Python 的基础知识的学习，已经工作中脚本语言的开发，使用 Sublime 编辑器可以非常好的满足我们的需求，并且 Sublime 提供了丰富的插件供使用，非常便捷。</p><p>开发 Python(Django) 语言，一般推荐安装 :</p><ul><li><p><code>SublimeCodeIntel</code> 插件：一款代码自动提示的插件。</p></li><li><p><code>Python PEP8 Autoformat</code> 插件：一款针对 Python 的代码格式化插件，快捷键为<code>Ctrl + Shift + R</code>。</p></li><li><p><code>SublimeTmpl</code> 插件：一款自定义文件模板的插件，可以跟进我们的配置在创建文件时，跟进模板完成初始化填充。关于 Python 的代码模板如下所示：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Date    : $&#123;date&#125;</span></span><br><span class="line"><span class="comment"># @Author  : $&#123;author&#125;</span></span><br><span class="line"><span class="comment"># @Version : \$Id\$</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">$&#123;<span class="number">1</span>:<span class="keyword">import</span> os&#125;</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">$<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes：打开 <code>preferences --&gt; pachages</code>，在打开的目录下依次找到<code>sublimeTmpl --&gt; templates --&gt; python.tmpl</code>，直接修改就好了。</p></blockquote><span id="more"></span><h2 id="Python-基础知识"><a href="#Python-基础知识" class="headerlink" title="Python 基础知识"></a><a id="BasicKnowledge">Python 基础知识</a></h2><p>基础知识都非常简单，这里贴一下学习的测试代码，就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 100</span></span><br><span class="line">a = -<span class="number">100</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span> a</span><br><span class="line"><span class="keyword">elif</span> a == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中文</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">u&#x27;中文&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line">names = [<span class="string">&#x27;zhang&#x27;</span>, <span class="string">&#x27;li&#x27;</span>, <span class="string">&#x27;wang&#x27;</span>, <span class="string">&#x27;er&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">len</span>(names)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line">names.append(<span class="string">&#x27;ma&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">len</span>(names)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;zhang&#x27;, &#x27;li&#x27;, &#x27;wang&#x27;, &#x27;zi&#x27;, &#x27;er&#x27;, &#x27;ma&#x27;]</span></span><br><span class="line">names.insert(<span class="number">3</span>, <span class="string">&#x27;zi&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> names</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;zhang&#x27;, &#x27;li&#x27;, &#x27;wang&#x27;, &#x27;zi&#x27;, &#x27;er&#x27;]</span></span><br><span class="line">names.pop()</span><br><span class="line"><span class="built_in">print</span> names</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;ma&#x27;, &#x27;li&#x27;, &#x27;wang&#x27;, &#x27;zi&#x27;, &#x27;er&#x27;]</span></span><br><span class="line">names[<span class="number">0</span>] = <span class="string">&#x27;ma&#x27;</span></span><br><span class="line"><span class="built_in">print</span> names</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;ma&#x27;, &#x27;li&#x27;, &#x27;wang&#x27;, &#x27;zi&#x27;, &#x27;er&#x27;, [&#x27;subzhang&#x27;, &#x27;subwang&#x27;]]</span></span><br><span class="line">names.append([<span class="string">&#x27;subzhang&#x27;</span>, <span class="string">&#x27;subwang&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> names</span><br><span class="line"></span><br><span class="line"><span class="comment"># (&#x27;ma&#x27;, &#x27;li&#x27;, &#x27;wang&#x27;, &#x27;zi&#x27;, &#x27;er&#x27;, [&#x27;subzhang&#x27;, &#x27;subwang&#x27;])</span></span><br><span class="line">tumples = <span class="built_in">tuple</span>(names)</span><br><span class="line"><span class="built_in">print</span> tumples</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;ma&#x27;, &#x27;li&#x27;, &#x27;wang&#x27;, &#x27;zi&#x27;, &#x27;er&#x27;, [&#x27;subzhang&#x27;, &#x27;subwang&#x27;]]</span></span><br><span class="line">names = <span class="built_in">list</span>(tumples)</span><br><span class="line"><span class="built_in">print</span> names</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别打印元素，[&#x27;subzhang&#x27;, &#x27;subwang&#x27;]是一体的</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> tumples:</span><br><span class="line">    <span class="built_in">print</span> x</span><br><span class="line"><span class="comment"># dict字典，ketao</span></span><br><span class="line">maps = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;ketao&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;dev&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span> maps[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#x27;job&#x27;: &#x27;dev&#x27;, &#x27;age&#x27;: 25, &#x27;program&#x27;: &#x27;python&#x27;, &#x27;name&#x27;: &#x27;ketao&#x27;&#125;</span></span><br><span class="line">maps[<span class="string">&#x27;program&#x27;</span>] = <span class="string">&#x27;python&#x27;</span></span><br><span class="line"><span class="built_in">print</span> maps</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#x27;job&#x27;: &#x27;dev&#x27;, &#x27;gender&#x27;: &#x27;male&#x27;, &#x27;age&#x27;: 25, &#x27;program&#x27;: &#x27;python&#x27;, &#x27;name&#x27;: &#x27;ketao&#x27;&#125;</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;gender&#x27;</span> <span class="keyword">in</span> maps:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    maps[<span class="string">&#x27;gender&#x27;</span>] = <span class="string">&#x27;male&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> maps.get(<span class="string">&#x27;gender&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span> maps</span><br><span class="line"></span><br><span class="line"><span class="comment"># set([&#x27;wang&#x27;, 14, &#x27;zhang&#x27;])</span></span><br><span class="line">sets = <span class="built_in">set</span>([<span class="string">&#x27;zhang&#x27;</span>, <span class="string">&quot;wang&quot;</span>, <span class="number">14</span>])</span><br><span class="line"><span class="built_in">print</span> sets</span><br><span class="line"></span><br><span class="line"><span class="comment"># set([&#x27;li&#x27;, &#x27;wang&#x27;, 14, &#x27;zhang&#x27;])</span></span><br><span class="line">sets.add(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> sets</span><br><span class="line"></span><br><span class="line"><span class="comment"># set([14, &#x27;zhang&#x27;]); set([&#x27;ma&#x27;, &#x27;wang&#x27;, &#x27;zhang&#x27;, 14, &#x27;li&#x27;])</span></span><br><span class="line">setss = <span class="built_in">set</span>([<span class="string">&#x27;zhang&#x27;</span>, <span class="number">14</span>, <span class="string">&#x27;ma&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> setss &amp; sets</span><br><span class="line"><span class="built_in">print</span> setss | sets</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes : 需要说明的是，必须在python 脚本中，注入 utf-8 相关配置，不然会出现下面的编码问题。如果使用模板，请参考上一节。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/ketao/python/test.py&quot;, line 20, in &lt;module&gt;</span><br><span class="line">    print u&#x27;中文&#x27;</span><br><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 0-1: ordinal not in range(128)</span><br><span class="line">[Finished in 0.0s with exit code 1]</span><br><span class="line">[shell_cmd: python -u &quot;/Users/ketao/python/test.py&quot;]</span><br><span class="line">[dir: /Users/ketao/python]</span><br><span class="line">[path: /usr/bin:/bin:/usr/sbin:/sbin]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jackson 自定义反序列化Java对象实现</title>
      <link href="2015/02/10/2015-02-10-Jackson-Deserialize-Java-Object-Implementation/"/>
      <url>2015/02/10/2015-02-10-Jackson-Deserialize-Java-Object-Implementation/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>上一篇博客，介绍了关于<a href="http://ketao1989.github.io/posts/Jackson-Serialize-Java-Object-Implementation.html">Jackson 自定义序列化</a>，本文将介绍关于 Jackson 自定义反序列化。</p><p>反序列化，Jackson 工具包中已经支持了开发中常用的 Java 类型的解析功能；但是还是会遇到一些我们需要自定义的解析转换工作。比如外部的一些非主流时间格式转换，再比如说对于一些类型转换，做一些额外数据校验和默认容错处理工作，再比如说前端的某种格式的字符串，我们想直接使用自定义反序列化类来完成到 Java Object 的转换工作等等，都需要我们去自己实现 Jackson 反序列化类。</p><p>和<code>Jackson 自定义序列化</code>相似，Jackson 为自定义的反序列化扩展，也提供了简单易用的接口。</p><h2 id="Jackson-自定义反序列化方法"><a href="#Jackson-自定义反序列化方法" class="headerlink" title="Jackson 自定义反序列化方法"></a><a id="CustomizeDeserialize">Jackson 自定义反序列化方法</a></h2><p>在 Jackson 自定义序列化中提供了两种接口，但是在反序列的时候，只有一个接口使用。不过，和序列化一样，反序列化的扩展也很简单，接口为：<code>org.codehaus.jackson.map.JsonDeserializer</code>，Jackson还提供了一个通用的扩展子类<code>com.fasterxml.jackson.databind.deser.std.StdDeserializer</code>。</p><p>一般，我们可以直接继承<code>JsonDeserializer</code>抽象类就已经足够满足我们的自定义反序列化需求了。</p><h3 id="JsonDeserializer-接口"><a href="#JsonDeserializer-接口" class="headerlink" title="JsonDeserializer 接口"></a>JsonDeserializer 接口</h3><p>和序列化很像，这里我们也只需要实现一个反序列化方法<code>deserialize</code> 就足够了。当然，如果你有其他的更高的需求，可以进一步 override 其他的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Abstract class that defines API used by &#123;<span class="doctag">@link</span> ObjectMapper&#125; (and</span></span><br><span class="line"><span class="comment"> * other chained &#123;<span class="doctag">@link</span> JsonDeserializer&#125;s too) to deserialize Objects of</span></span><br><span class="line"><span class="comment"> * arbitrary types from JSON, using provided &#123;<span class="doctag">@link</span> JsonParser&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当请求将JSON内容反序列成java类型对象的时候，该方法将会被调用。然后，会返回一个</span></span><br><span class="line"><span class="comment">     * 由方法自己构造的对象实例。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 需要注意的是，当JSON为null的时候，该方法该不会被调用，因此，方法不需要去</span></span><br><span class="line"><span class="comment">     * check 该值是否为null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">deserialize</span><span class="params">(JsonParser jp, DeserializationContext ctxt)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, JsonProcessingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和上面常用的方法不同，这个方法带有一个初始化的对象实例，该实例由反序列类配置的。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 当然，这个方法是不必须实现的。一般的，我们转换一个JSON为集合或者Map的时候，可以把</span></span><br><span class="line"><span class="comment">     * 通用的元素put到集合中，这样返回的时候，就不需要再操作了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">deserialize</span><span class="params">(JsonParser jp, DeserializationContext ctxt,</span></span></span><br><span class="line"><span class="params"><span class="function">                         T intoValue)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, JsonProcessingException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Can not update object of type &quot;</span></span><br><span class="line">                +intoValue.getClass().getName()+<span class="string">&quot; (by deserializer of type &quot;</span>+getClass().getName()+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法主要是用来支持兼容老的代码，编码编译错误。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 也就是说，当我们使用新的代码和反序列化工具的时候，可能还需要去兼容老的代码数据</span></span><br><span class="line"><span class="comment">     * 反序列化，这样子就可以尝试使用老的反序列化类进行解析工作。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserializeWithType</span><span class="params">(JsonParser jp, DeserializationContext ctxt,</span></span></span><br><span class="line"><span class="params"><span class="function">            TypeDeserializer typeDeserializer)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, JsonProcessingException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// We could try calling </span></span><br><span class="line">        <span class="keyword">return</span> (T) typeDeserializer.deserializeTypedFromAny(jp, ctxt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips：这个反序列化方法实现起来很简单，只需要实现核心的<code>deserialize</code>方法，使用<code>jp.getText</code>获取 value 然后对字符串进行我们需要的各种操作转换，赋值给创建的对象实例，就 OK 了。</p></blockquote><span id="more"></span><h2 id="自定义反序列化方法注册到Jackson"><a href="#自定义反序列化方法注册到Jackson" class="headerlink" title="自定义反序列化方法注册到Jackson"></a><a id="RegisterDeserializer">自定义反序列化方法注册到Jackson</a></h2><p>和序列化一样，Jackson 也提供了三种方法来注册到 <code>ObjectMapper</code> 上。根据官方推荐，这里只介绍两种方式：</p><ul><li><p>使用 <code>Module Interface</code>模式来注册反序列化方法（全局）</p></li><li><p>使用注解，细粒度到具体模型对象的属性。</p></li></ul><h3 id="SimpleModule-类注册"><a href="#SimpleModule-类注册" class="headerlink" title="SimpleModule 类注册"></a>SimpleModule 类注册</h3><p><code>SimpleModule</code>类是1.8版本才提供的注册类，当我们想在全局的反序列环境下，对指定类型的每一次反序列化都会按照这个类方法进行解析，就可以在<code>SimpleModule</code>中添加指定的自定义反序列类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleModule</span> <span class="keyword">extends</span> <span class="title">Module</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String _name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Version _version;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> SimpleSerializers _serializers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> SimpleDeserializers _deserializers = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">SimpleModule <span class="title">addDeserializer</span><span class="params">(Class&lt;T&gt; type, JsonDeserializer&lt;? extends T&gt; deser)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_deserializers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            _deserializers = <span class="keyword">new</span> SimpleDeserializers();</span><br><span class="line">        &#125;</span><br><span class="line">        _deserializers.addDeserializer(type, deser);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleModule <span class="title">addKeyDeserializer</span><span class="params">(Class&lt;?&gt; type, KeyDeserializer deser)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_keyDeserializers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            _keyDeserializers = <span class="keyword">new</span> SimpleKeyDeserializers();</span><br><span class="line">        &#125;</span><br><span class="line">        _keyDeserializers.addDeserializer(type, deser);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips：显然，我们在<code>objectMapper.registerModule</code>中注册构造的simpleModule对象实例，这个实例调用<code>addDeserializer</code>把我们自定义的反序列化方法添加进去就可以了。</p></blockquote><h3 id="JsonDeserialize-注解"><a href="#JsonDeserialize-注解" class="headerlink" title="@JsonDeserialize 注解"></a>@JsonDeserialize 注解</h3><p>使用注解的方式来注册自定义的反序列化方法，可以把自定义粒度控制到某一个类型对象属性上，但是这对于想全局反序列化某个类型，这种方式都会很繁琐。</p><p><code>@JsonDeserialize</code>和序列化注解，完全一样。使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@JsonDeserialize(using = CustomizeJsonDeserializer.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(TypeB b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Java对象反序列化自定义示例"><a href="#Java对象反序列化自定义示例" class="headerlink" title="Java对象反序列化自定义示例"></a><a id="JacksonCustomizeSample">Java对象反序列化自定义示例</a></h2><p>和 Jackson 自定义序列化一样，这里主要把实现继承反序列化接口的代码和 mapper 注册贴出来，参考下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizeJsonDeserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">TypeB</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TypeB <span class="title">deserialize</span><span class="params">(JsonParser jp, DeserializationContext ctxt)</span> <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String value = jp.getText();</span><br><span class="line">        Map&lt;String, String&gt; properities = Splitter.on(<span class="string">&quot;,&quot;</span>).trimResults().withKeyValueSeparator(<span class="string">&quot;=&quot;</span>).split(StringUtils.substringBetween(value, <span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(JsonUtils.encode(properities));</span><br><span class="line"></span><br><span class="line">        TypeB typeB = <span class="keyword">new</span> TypeB(properities.get(<span class="string">&quot;address&quot;</span>), Integer.valueOf(properities.get(<span class="string">&quot;code&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> typeB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(JsonUtils.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.INTERN_FIELD_NAMES, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.CANONICALIZE_FIELD_NAMES, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">        objectMapper.setSerializationInclusion(JsonSerialize.Inclusion.NON_NULL);<span class="comment">// JSON节点不包含属性值为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">decode</span><span class="params">(String json, Class&lt;T&gt; valueType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            SimpleModule deserializeModule = <span class="keyword">new</span> SimpleModule(<span class="string">&quot;DeserializeModule&quot;</span>, <span class="keyword">new</span> Version(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>));</span><br><span class="line">            deserializeModule.addDeserializer(TypeB.class,<span class="keyword">new</span> CustomizeJsonDeserializer()); <span class="comment">// assuming serializer declares correct class to bind to</span></span><br><span class="line">            objectMapper.registerModule(deserializeModule);</span><br><span class="line">            <span class="keyword">return</span> objectMapper.readValue(json, valueType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonParseException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;decode(String, Class&lt;T&gt;)&quot;</span>, e); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonMappingException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;decode(String, Class&lt;T&gt;)&quot;</span>, e); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;decode(String, Class&lt;T&gt;)&quot;</span>, e); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a id="End">总结</a></h2><ul><li><p>官方序列化简要介绍：<a href="http://wiki.fasterxml.com/JacksonHowToCustomDeserializers">http://wiki.fasterxml.com/JacksonHowToCustomDeserializers</a></p></li><li><p>测试代码git地址:<a href="https://github.com/ketao1989/JavaApiUtilsProject">https://github.com/ketao1989/JavaApiUtilsProject</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Json </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jackson 自定义序列化Java对象实现</title>
      <link href="2015/02/07/2015-02-07-Jackson-Serialize-Java-Object-Implementation/"/>
      <url>2015/02/07/2015-02-07-Jackson-Serialize-Java-Object-Implementation/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>关于Jackson工具类的相关学习和研究,先前已经写过一篇博文;但是,后来由于工作事情就草草结尾.此外,虽然对Jackson序列化和反序列化的实现机制进行了初步学习,但是现在看看,那时候的博客经验和技术水平决定了整篇博文结构并不是清晰明了,并且反序列化的整个简单的解析,对日常开发并没有直接帮助.对于Jackson这种模块化设计,轻巧灵活的扩展方法,多维度的性能效率优化,导致了最后博文的质量非常不好.因此,接下来几篇博文,将会以日常开发使用的一些API为入口,来分别介绍其使用方式和内部实现,然后在此基础上,对此博文进行分拆.</p><p>在开发中，前后端交互的项目，现在一般都是基于JSON文本格式给出API接口，因此对于java对象的序列化就是十分重要的了。基于Spring MVC的配置中，我们配置<code>org.springframework.http.converter.json.MappingJacksonHttpMessageConverter</code> bean时，就是需要配置<code>messageConverters</code>转换器。而针对json的转换器，就可以使用Jackson的<code>objectMapper</code>对象了。</p><p>返回给前端的<code>Response Body</code>一般需要良好的可读性，不能因为后端处理方便，就直接破坏前端展示。比如，我们后端使用枚举处理一些情况，但是如果把枚举英文或者数字返回给前端页面，对用户来说是非常不友好的。因此，这里就是涉及到了java对象自定义序列化的问题了。Jackson工具为我们提供了非常多的常见默认的序列化方法，以及一些扩展的接口；参考系统的序列化方法，我们就可以实现自定义的了。</p><h2 id="Jackson自定义序列化方法"><a href="#Jackson自定义序列化方法" class="headerlink" title="Jackson自定义序列化方法"></a><a id="CustomizeSerialize">Jackson自定义序列化方法</a></h2><p>在Jackson中，提供了多种方式去实现自定义的序列化方法。例如，<code>org.codehaus.jackson.map.JsonSerializableWithType</code>接口以及<code>org.codehaus.jackson.map.JsonSerializer</code>接口。</p><span id="more"></span><h3 id="JsonSerializableWithType-接口"><a href="#JsonSerializableWithType-接口" class="headerlink" title="JsonSerializableWithType 接口"></a>JsonSerializableWithType 接口</h3><p>JsonSerializableWithType 接口主要提供了两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface that is to replace &#123;<span class="doctag">@link</span> JsonSerializable&#125; to</span></span><br><span class="line"><span class="comment"> * allow for dynamic type information embedding.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tatu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JsonSerializableWithType</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">JsonSerializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serializeWithType</span><span class="params">(JsonGenerator jgen, SerializerProvider provider,</span></span></span><br><span class="line"><span class="params"><span class="function">            TypeSerializer typeSer)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, JsonProcessingException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JsonSerializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(JsonGenerator jgen, SerializerProvider provider)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, JsonProcessingException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在早期还没有<code>JsonSerializableWithType</code>接口的时候，官方推荐使用<code>JsonSerializable</code>接口。但是，从version 1.5之后，Jackson提供了JsonSerializableWithType来替换JsonSerializable，因为JsonSerializable接口不支持处理某些额外的类型信息。</p><p>但是，由于实现JsonSerializableWithType接口的方法比较麻烦，所以，Jackson对外提供了其他可以自定义序列化的抽象类<code>SerializerBase</code>和<code>ScalarSerializerBase</code>。其中ScalarSerializerBase是对SerializerBase的再次封装，它只针对输出了JSON 字符串，boolean或者数字类型才有用。</p><p>继承<code>SerializerBase</code>抽象类，主要实现<code>serialize(TypeB value, JsonGenerator jgen, SerializerProvider provider)</code>方法即可，实现起来非常简单。此外,Jackson还提供了另一种简单易用的自定义序列化方法，给开发者使用，这就是<code>JsonSerializer</code>接口。</p><h3 id="JsonSerializer-接口"><a href="#JsonSerializer-接口" class="headerlink" title="JsonSerializer 接口"></a>JsonSerializer 接口</h3><p>JsonSerializer类就是一个抽象类，我们只需要简单实现其中的抽象方法就可以完成自定义的序列化工作。</p><p>先来看看<code>JsonSerializer</code>抽象类的主要方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ObjectMapper类定义的抽象API类来给JsonGenerator类完成序列化任意对象到JSON功能。</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 需要说明的是，官方推荐使用继承SerializerBase类完成自定义序列化工作，替代使用本类。</span></span><br><span class="line"><span class="comment"> * 主要是因为，SerializerBase类提供了更多的可选择的方法给开发者去定制会。</span></span><br><span class="line"><span class="comment"> * 当然，如果你只需要简单的序列化功能，则继承这个类足够了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonSerializer</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(T value, JsonGenerator jgen, SerializerProvider provider)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, JsonProcessingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Method that can be called to ask implementation to serialize</span></span><br><span class="line"><span class="comment">     * values of type this serializer handles, using specified type serializer</span></span><br><span class="line"><span class="comment">     * for embedding necessary type information.</span></span><br><span class="line"><span class="comment">     *&lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Default implementation will ignore serialization of type information,</span></span><br><span class="line"><span class="comment">     * and just calls &#123;<span class="doctag">@link</span> #serialize&#125;: serializers that can embed</span></span><br><span class="line"><span class="comment">     * type information should override this to implement actual handling.</span></span><br><span class="line"><span class="comment">     * Most common such handling is done by something like:</span></span><br><span class="line"><span class="comment">     *&lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *  // note: method to call depends on whether this type is serialized as JSON scalar, object or Array!</span></span><br><span class="line"><span class="comment">     *  typeSer.writeTypePrefixForScalar(value, jgen);</span></span><br><span class="line"><span class="comment">     *  serialize(value, jgen, provider);</span></span><br><span class="line"><span class="comment">     *  typeSer.writeTypeSuffixForScalar(value, jgen);</span></span><br><span class="line"><span class="comment">     *&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serializeWithType</span><span class="params">(T value, JsonGenerator jgen, SerializerProvider provider,</span></span></span><br><span class="line"><span class="params"><span class="function">            TypeSerializer typeSer)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, JsonProcessingException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        serialize(value, jgen, provider);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，继承<code>JsonSerializer</code>类，实现serialize方法，就可以完成自定义序列化工作了。其实，和第一种方法相比，其本质上都是一样的，就是实现serialize序列化方法。</p><h2 id="自定义序列化方法注册到Jackson"><a href="#自定义序列化方法注册到Jackson" class="headerlink" title="自定义序列化方法注册到Jackson"></a><a id="RegisterSerializer">自定义序列化方法注册到Jackson</a></h2><p>Jackson提供了多种方式注册自定义序列化类，虽然官方指出第一种继承JsonSerializableWithType的方式不需要注册，但是测试了下，发现貌似不起作用。</p><p>虽然注册的方式很多，但是主要是三种，并且最后一种在1.8版本以后已经标记为过时状态：</p><ul><li><p>继承 <code>Module interface</code>接口，官方推荐使用模块接口来完成注册功能；</p></li><li><p>使用注解方式<code>@JsonSerialize</code>在方法或field上标记；</p></li><li><p>继承<code>CustomSerializerFactory</code>接口，通过addXxxMapping来自定义SerializerFactory。</p></li></ul><h3 id="Module-interface接口"><a href="#Module-interface接口" class="headerlink" title="Module interface接口"></a>Module interface接口</h3><p>模块接口，是Jackson在1.7以后的版本中给出的。Module接口，是Jackson专门提供了自定义序列化方法类注册到ObjectMapper实例上的接口，比如我们新增了一个数据类型。</p><p>在开发过程中，我们只需要直接使用<code>SimpleModule</code>类就可以完成注册了，一般没有必要去实现<code>Module</code>抽象类。</p><blockquote><p>Tips：其实Module也提供了反序列化来完成自定义类的注册工作，其他博文会再介绍。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple &#123;<span class="doctag">@link</span> Module&#125; implementation that allows registration</span></span><br><span class="line"><span class="comment"> * of serializers and deserializers, and bean serializer</span></span><br><span class="line"><span class="comment"> * and deserializer modifiers.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleModule</span> <span class="keyword">extends</span> <span class="title">Module</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String _name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Version _version;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// ........</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleModule</span><span class="params">(String name, Version version)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _version = version;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SimpleModule <span class="title">addSerializer</span><span class="params">(JsonSerializer&lt;?&gt; ser)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_serializers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            _serializers = <span class="keyword">new</span> SimpleSerializers();</span><br><span class="line">        &#125;</span><br><span class="line">        _serializers.addSerializer(ser);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JsonSerialize-注解"><a href="#JsonSerialize-注解" class="headerlink" title="@JsonSerialize 注解"></a>@JsonSerialize 注解</h3><p>通过注解的方式注册序列化方法，对使用体验来说非常友好。但是会存在两个问题：首先，提供的序列化类的功能比较简单，然后，就是提供的粒度比较小，然后你想在全局的某个类型上都是有自定义序列化，则需要对每个对象类型上都需要标记注解。</p><p><code>@JsonSerialize</code> 注解的配置参数有很多种，但是我们只需要using这种来指明具体的自定义序列化类就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation used for configuring serialization aspects, by attaching</span></span><br><span class="line"><span class="comment"> * to &quot;getter&quot; methods or fields, or to value classes.</span></span><br><span class="line"><span class="comment"> * When annotating value classes, configuration is used for instances</span></span><br><span class="line"><span class="comment"> * of the value class but can be overridden by more specific annotations</span></span><br><span class="line"><span class="comment"> * (ones that attach to methods or fields).</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * An example annotation would be:</span></span><br><span class="line"><span class="comment"> *&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *  &amp;#64;JsonSerialize(using=MySerializer.class,</span></span><br><span class="line"><span class="comment"> *    as=MySubClass.class,</span></span><br><span class="line"><span class="comment"> *    include=JsonSerialize.Inclusion.NON_NULL,</span></span><br><span class="line"><span class="comment"> *    typing=JsonSerialize.Typing.STATIC</span></span><br><span class="line"><span class="comment"> *  )</span></span><br><span class="line"><span class="comment"> *&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * (which would be redundant, since some properties block others:</span></span><br><span class="line"><span class="comment"> * specifically, &#x27;using&#x27; has precedence over &#x27;as&#x27;, which has precedence</span></span><br><span class="line"><span class="comment"> * over &#x27;typing&#x27; setting)</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> since version 1.2, annotation has also been applicable</span></span><br><span class="line"><span class="comment"> * to (constructor) parameters</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@JacksonAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JsonSerialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// // // Annotations for explicitly specifying deserializer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Serializer class to use for</span></span><br><span class="line"><span class="comment">     * serializing associated value. Depending on what is annotated,</span></span><br><span class="line"><span class="comment">     * value is either an instance of annotated class (used globablly</span></span><br><span class="line"><span class="comment">     * anywhere where class serializer is needed); or only used for</span></span><br><span class="line"><span class="comment">     * serializing property access via a getter method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? extends JsonSerializer&lt;?&gt;&gt; using() <span class="keyword">default</span> JsonSerializer.None.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="CustomSerializerFactory接口"><a href="#CustomSerializerFactory接口" class="headerlink" title="CustomSerializerFactory接口"></a>CustomSerializerFactory接口</h3><p>最后一种注册自定义序列化类的方法就是通过使用自定义序列化factory工厂，也就是继承SerializerFactory类。</p><p>首先，我们使用或者扩展已经存在的<code>CustomSerializerFactory</code>。然后调用实例对象实现的<code>addSpecificMapping</code>或者<code>addGenericMapping</code>方法增加mapping关系，把自定义的序列化方法add到序列化列表中。最后，我们可以把这个工厂set到ObjectMapper实例对象上。</p><h2 id="Java对象序列化自定义示例"><a href="#Java对象序列化自定义示例" class="headerlink" title="Java对象序列化自定义示例"></a><a id="JacksonCustomizeSample">Java对象序列化自定义示例</a></h2><p>下面给出使用自定义序列化类来完成Java对象到JSON的转换工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(JsonUtils.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.INTERN_FIELD_NAMES, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.CANONICALIZE_FIELD_NAMES, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">        objectMapper.setSerializationInclusion(JsonSerialize.Inclusion.NON_NULL);<span class="comment">// JSON节点不包含属性值为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encode</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            SimpleModule SerializeModule = new SimpleModule(&quot;SerializeModule&quot;, new Version(1, 0, 0, null));</span></span><br><span class="line"><span class="comment">//            SerializeModule.addSerializer(new CustomizeJsonSerializerBaser(TypeB.class)); // assuming serializer declares correct class to bind to</span></span><br><span class="line"><span class="comment">//            objectMapper.registerModule(SerializeModule);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            CustomSerializerFactory customSerializerFactory = new CustomSerializerFactory();</span></span><br><span class="line"><span class="comment">//            customSerializerFactory.addSpecificMapping(TypeB.class,new CustomizeJsonSerializerBaser(TypeB.class));</span></span><br><span class="line"><span class="comment">//            objectMapper.setSerializerFactory(customSerializerFactory);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> objectMapper.writeValueAsString(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonGenerationException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;encode(Object)&quot;</span>, e); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonMappingException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;encode(Object)&quot;</span>, e); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;encode(Object)&quot;</span>, e); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes：JsonUtils类封装了Jackson序列化操作。代码中，提供了通过Module接口方式和创建<code>CustomSerializerFactory</code>对象来完成注册加载。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizeJsonSerializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">List</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(List value, JsonGenerator jgen, SerializerProvider provider)</span> <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">        jgen.writeStartArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object va :value)&#123;</span><br><span class="line">            jgen.writeString(va.toString()+<span class="string">&quot;TestSerialize&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jgen.writeString(Joiner.on(&quot;;&quot;).join(value));</span></span><br><span class="line">        jgen.writeEndArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizeJsonSerializerBaser</span> <span class="keyword">extends</span> <span class="title">SerializerBase</span>&lt;<span class="title">TypeB</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解必须有默认构造韩式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomizeJsonSerializerBaser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(TypeB.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">CustomizeJsonSerializerBaser</span><span class="params">(Class&lt;TypeB&gt; t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">CustomizeJsonSerializerBaser</span><span class="params">(JavaType type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">CustomizeJsonSerializerBaser</span><span class="params">(Class&lt;?&gt; t, <span class="keyword">boolean</span> dummy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(t, dummy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TypeB value, JsonGenerator jgen, SerializerProvider provider)</span> <span class="keyword">throws</span> IOException, JsonGenerationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        jgen.writeString(value.toString());</span><br><span class="line">       <span class="comment">// System.out.println(&quot;======================&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes：这里提供了两种不同的方式开发自定义序列化方法。目前，从1.8开始，官方推荐使用第二种方式实现自定义序列化类，但是如果只需要简单的序列化功能，使用第一种完全可以满足需求。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; hobby;</span><br><span class="line"></span><br><span class="line">    TypeB b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonSerialize(using = CustomizeJsonSerializerBaser.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TypeB <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(TypeB b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonSerialize(using = CustomizeJsonSerializer.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getHobby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobby</span><span class="params">(List&lt;String&gt; hobby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ClassA&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, hobby=&quot;</span> + hobby +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TypeB</span><span class="params">(String address, <span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;TypeB&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, code=&quot;</span> + code +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonSerializeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassA a = <span class="keyword">new</span> ClassA();</span><br><span class="line"></span><br><span class="line">        a.setAge(<span class="number">10</span>);</span><br><span class="line">        a.setName(<span class="string">&quot;ketao1989&quot;</span>);</span><br><span class="line">        a.setHobby(Lists.newArrayList(<span class="string">&quot;dinner&quot;</span>,<span class="string">&quot;swimming&quot;</span>,<span class="string">&quot;music&quot;</span>,<span class="string">&quot;programming&quot;</span>));</span><br><span class="line">        a.setB(<span class="keyword">new</span> TypeB(<span class="string">&quot;jiangxi&quot;</span>,<span class="number">320000</span>));</span><br><span class="line"></span><br><span class="line">        String aJsonStr = JsonUtils.encode(a);</span><br><span class="line">        System.out.println(aJsonStr);</span><br><span class="line"></span><br><span class="line">        ClassA aa = <span class="keyword">new</span> ClassA();</span><br><span class="line"></span><br><span class="line">        aa.setAge(<span class="number">19</span>);</span><br><span class="line">        aa.setName(<span class="string">&quot;kexiaoxiaoxi&quot;</span>);</span><br><span class="line">        aa.setHobby(Lists.newArrayList(<span class="string">&quot;MacOs&quot;</span>, <span class="string">&quot;Linux&quot;</span>, <span class="string">&quot;Windows&quot;</span>, <span class="string">&quot;Unknown&quot;</span>));</span><br><span class="line">        aa.setB(<span class="keyword">new</span> TypeB(<span class="string">&quot;beijing&quot;</span>, <span class="number">100000</span>));</span><br><span class="line"></span><br><span class="line">        String aaJsonStr = JsonUtils.encode(aa);</span><br><span class="line">        System.out.println(aaJsonStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String bb = JsonUtils.encode(<span class="keyword">new</span> TypeB(<span class="string">&quot;beijing&quot;</span>,<span class="number">100000</span>));</span><br><span class="line">        System.out.println(bb);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes：测试相关类。目前都是通过注解的方式，可以把相关的注释取消，测试其他实现方式完成自定义序列化功能。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a id="End">总结</a></h2><ul><li><p>官方序列化简要介绍：<a href="http://wiki.fasterxml.com/JacksonHowToCustomSerializers">http://wiki.fasterxml.com/JacksonHowToCustomSerializers</a></p></li><li><p>测试代码svn地址:<a href="http://code.taobao.org/svn/dubbocli/trunk">http://code.taobao.org/svn/dubbocli/trunk</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Json </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git工具回滚线上错误提交</title>
      <link href="2015/01/27/2015-01-27-Git-Reset-Operate/"/>
      <url>2015/01/27/2015-01-27-Git-Reset-Operate/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>应用场景：自动部署系统发布后发现问题，需要回滚到某一个commit，再重新发布</p><p>原理：先将本地分支退回到某个commit，删除远程分支，再重新push本地分支</p><p>操作步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. git checkout the_branch</span><br><span class="line"></span><br><span class="line">2. git pull</span><br><span class="line"></span><br><span class="line">3. git branch the_branch_backup <span class="comment"># 备份一下这个分支当前的情况</span></span><br><span class="line"></span><br><span class="line">4. git reset --hard the_commit_id <span class="comment"># 把the_branch本地回滚到the_commit_id</span></span><br><span class="line"></span><br><span class="line">5. git push origin :the_branch <span class="comment"># 删除远程 the_branch</span></span><br><span class="line"></span><br><span class="line">6. git push origin the_branch <span class="comment"># 用回滚后的本地分支重新建立远程分支</span></span><br><span class="line"></span><br><span class="line">7. git push origin :the_branch_backup <span class="comment"># 如果前面都成功了，删除这个备份分支</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Tips：获取<code>the_commit_id</code> 使用<code>git log</code>，然后找到需要回滚到的那个提交的id hash值。</p></blockquote><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring 中实现动态数据源</title>
      <link href="2015/01/12/2015-01-12-Spring-Dynamic-Data-Source-Guide/"/>
      <url>2015/01/12/2015-01-12-Spring-Dynamic-Data-Source-Guide/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>前段时间业务上有一个需求,这个需求需要查询数据库,由于单表数据比较大，导致出现超过5s的慢查询。随后，为了快速修复慢查询对整个系统带来的影响，将查询的数据源通过简单粗暴的修改配置切换到从库上。此后，增加了memcached来缓存一些case下的查询数据，但是对从库配置实现方式，并没有去调整。</p><p>最近，有其他业务的数据查询也需要切换到从库上，因此对上述简单的配置实现进行了思考。</p><p>动态数据源，其实就是根据我们的代码实现和配置来选择不同的数据源进行sql操作。一般地，我们会把读操作移到从库中，从而减轻主库的压力，也就是所谓的读写分离。</p><p>当然，对于一些使用数据库中间件来完成读写分离，而不需要业务层来做。这种方式，在大互联网公司中大量使用，比如360基于mysql-proxy的Atlas，阿里的DRDS(基于淘宝之前开源的TDDL）以及网易的分布式数据库中间件DDB等等。</p><p>对于一些未使用部署数据库中间件的公司，简单的方法就是在代码里面使用AOP方式通过对每个DAO层sql请求进行配置，来完成自定义的动态数据源。</p><h2 id="Spring动态数据源接口"><a href="#Spring动态数据源接口" class="headerlink" title="Spring动态数据源接口"></a><a id="AbstractRoutingDataSource">Spring动态数据源接口</a></h2><p>Spring提供了一个抽象类<code>AbstractRoutingDataSource</code>，该类可以让开发人员快速实现数据源路由完成根据不同请求使用不同数据源的需求。</p><p><code>AbstractRoutingDataSource</code>抽象类，继承关系如下图：</p><img src="/images/2015/01/ards.png" /><blockquote><p>Notes: 抽象类最终继承<code>javax.sql.DataSource</code>类，该数据源类提供的一些接口就是我们最终需要实现的。</p></blockquote><p>DataSource接口主要提供了两个方法给开发者实现，因此实现动态数据源，我们只需要把这两个方法的实现，在调用数据库查询的时候，告知执行上下文，运行环境拿到对应的数据库连接，就可以连接到对应的数据库进行查询更新等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataSource</span>  <span class="keyword">extends</span> <span class="title">CommonDataSource</span>,<span class="title">Wrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><p>解析来，需要分析Spring提供给我们的抽象数据源路由类。既然<code>AbstractRoutingDataSource</code>简化了大家实现动态数据源功能的开发工作，那么该类必然会实现DataSource的两个接口方法。其需要决定，在什么情况下，使用哪个数据源的Connection连接。</p><blockquote><p><code>AbstractRoutingDataSource</code>怎样来获取数据源连接呢？</p></blockquote><p>使用Map数据结构存放所有配置中使用的数据源，value是数据源DataSource对象，key则是根据我们自己的爱好来取名的，比如：master，slave等。这样，我们可以根据具体Dao方法配置的数据源key来获取对应的DataSource对象，从而告知运行环境该sql查询使用哪一个connection连接。</p><p>下面给出<code>AbstractRoutingDataSource</code>的部分实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象的javax.sql.DataSource实现，可以完成基于一个查找key来路由 #getConnection()到某些特性目标DataSourcesd的一个。</span></span><br><span class="line"><span class="comment"> * 一般通过绑定线程事务上下文来决定。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRoutingDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;Object, Object&gt; targetDataSources;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object defaultTargetDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lenientFallback = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DataSourceLookup dataSourceLookup = <span class="keyword">new</span> JndiDataSourceLookup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, DataSource&gt; resolvedDataSources;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DataSource resolvedDefaultDataSource;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置目标DataSources的map映射，其中查找key作为 map的key。</span></span><br><span class="line"><span class="comment">     * 这个映射的value可以是对象的DataSource实例，或者是一个数据源 name的字符串（可以被DataSourceLookup解析）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * key可以是任意的类型，只要实现了普通的查找处理。</span></span><br><span class="line"><span class="comment">     * 具体的key表示形式，将会被resolveSpecifiedLookupKey和determineCurrentLookupKey处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTargetDataSources</span><span class="params">(Map&lt;Object, Object&gt; targetDataSources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetDataSources = targetDataSources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置默认目标数据源。如果我们在map中找不到对应的key时，则会使用这里设置的默认数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultTargetDataSource</span><span class="params">(Object defaultTargetDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultTargetDataSource = defaultTargetDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定默认的DataSource，当通过指定的查找key不能找到对应的DataSource。</span></span><br><span class="line"><span class="comment">     * 如果为false，则直接返回失败，如果为true，则使用默认的数据源。默认为true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLenientFallback</span><span class="params">(<span class="keyword">boolean</span> lenientFallback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lenientFallback = lenientFallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置DataSourceLookup的实现类，该实现类可以把字符串配置的数据源，解析成我们需要的DataSource类.默认使用JndiDataSourceLookup。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * JndiDataSourceLookup方法使用ref bean方式获取配置文件中配置的dataSource数据源，也就是我们一般使用xml中配置datasource的方式就是jndi。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSourceLookup</span><span class="params">(DataSourceLookup dataSourceLookup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSourceLookup = (dataSourceLookup != <span class="keyword">null</span> ? dataSourceLookup : <span class="keyword">new</span> JndiDataSourceLookup());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.targetDataSources == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Property &#x27;targetDataSources&#x27; is required&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.resolvedDataSources = <span class="keyword">new</span> HashMap&lt;Object, DataSource&gt;(<span class="keyword">this</span>.targetDataSources.size());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry entry : <span class="keyword">this</span>.targetDataSources.entrySet()) &#123;</span><br><span class="line">            Object lookupKey = resolveSpecifiedLookupKey(entry.getKey());</span><br><span class="line">            DataSource dataSource = resolveSpecifiedDataSource(entry.getValue());</span><br><span class="line">            <span class="keyword">this</span>.resolvedDataSources.put(lookupKey, dataSource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.defaultTargetDataSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.resolvedDefaultDataSource = resolveSpecifiedDataSource(<span class="keyword">this</span>.defaultTargetDataSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据lookupKey获取map中存放的key值，一般无特性情况，两者是一样的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">resolveSpecifiedLookupKey</span><span class="params">(Object lookupKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lookupKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转换从获取map中存放的dataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DataSource <span class="title">resolveSpecifiedDataSource</span><span class="params">(Object dataSource)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> DataSource) &#123;</span><br><span class="line">            <span class="keyword">return</span> (DataSource) dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.dataSourceLookup.getDataSource((String) dataSource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;Illegal data source value - only [javax.sql.DataSource] and String supported: &quot;</span> + dataSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就是抽象类给我们实现的接口方法，根据我们的配置上下文，抽象类决定实现哪个连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> determineTargetDataSource().getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> determineTargetDataSource().getConnection(username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DataSource <span class="title">determineTargetDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">&quot;DataSource router not initialized&quot;</span>);</span><br><span class="line">        Object lookupKey = determineCurrentLookupKey();</span><br><span class="line">        DataSource dataSource = <span class="keyword">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot determine target DataSource for lookup key [&quot;</span> + lookupKey + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是我们使用这个抽象类需要实现的方法，主要就是告诉该抽象类，当前需要使用的数据源的key是什么，这样抽象类就可以知道使用哪个数据库连接</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于Spring动态数据源实现"><a href="#基于Spring动态数据源实现" class="headerlink" title="基于Spring动态数据源实现"></a><a id="Implementation">基于Spring动态数据源实现</a></h2><h3 id="3-1-实现抽象路由数据源类"><a href="#3-1-实现抽象路由数据源类" class="headerlink" title="3.1 实现抽象路由数据源类"></a>3.1 实现抽象路由数据源类</h3><p>上一节介绍了抽象类<code>AbstractRoutingDataSource</code>，继承这个抽象类，我们实现动态数据源，只需要告诉抽象类，当前使用哪个key去获取数据源（determineCurrentLookupKey）。</p><p>在项目中，我们一般会指定哪些数据库操作需要使用哪个数据源，这个设置会存放在上下文中。也就是，我们可以使用ThreadLocal来存放当前数据操作使用的key。</p><p>因此，可以实现两个类，一个类实现<code>AbstractRoutingDataSource</code>抽象接口；一个来获取当前上下文中对应的key值。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DynamicDataSourceHolder.getDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; dsHolder = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dsHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putDataSource</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        dsHolder.set(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dsHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面两个类，我们就可以从上下文中获取当前操作需要使用的key值，然后通过实现的抽象路由数据源类来找到配置的DataSource，这样spring上下文就知道具体使用哪个connection连接来操作数据库sql了。</p><blockquote><p>Tips: 这里需要注意ThreadLocal类中实现了clear方法，主要是在一个线程中会存在多个sql操作，可能设计不同的数据源，如果不清除当前sql的数据源，可能接下来的sql操作也会使用前一个操作设置的数据源连接，导致错误。</p></blockquote><h3 id="3-2-实现AOP简化配置"><a href="#3-2-实现AOP简化配置" class="headerlink" title="3.2 实现AOP简化配置"></a>3.2 实现AOP简化配置</h3><p>上一小节完成了怎样从上下文中获取设置的key，从而使用哪个数据源连接。但是，如何告知哪些操作使用哪个数据源key。</p><p>我们可以在每个需要使用动态数据源的地方，在具体业务代码的开始，把key值put到线程上下文中；然后在业务代码结束的地方，把上下文的设置清除掉。这样可以完成我们的需求，但是，对业务代码的侵入程度有点大哦。</p><p>上述这种场景，非常适合使用AOP技术完成。关于AOP介绍，可以参考：<a href="http://oss.org.cn/ossdocs/framework/spring/zh-cn/aop.html">http://oss.org.cn/ossdocs/framework/spring/zh-cn/aop.html</a></p><p>采用AOP技术，我们需要在配置文件（或注解方式）中设置切点pointCut，然后我们需要实现切点前调用的方法（threadLocal中存入数据源key），和切点后调用的方法（清除threadLocal数据）。</p><p>为了使用方便，我们使用注解的方式配置数据源key。注解的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBSource &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定数据源使用哪个配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，看看怎样实现AOP的before和after通知方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DataSourceAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint point)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object target = point.getTarget();</span><br><span class="line">        String method = point.getSignature().getName();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt;[] classz = target.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = ((MethodSignature) point.getSignature()).getMethod().getParameterTypes();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method m = classz[<span class="number">0</span>].getMethod(method, parameterTypes);</span><br><span class="line">            <span class="keyword">if</span> (m != <span class="keyword">null</span> &amp;&amp; m.isAnnotationPresent(DBSource.class)) &#123;</span><br><span class="line">                DBSource data = m.getAnnotation(DBSource.class);</span><br><span class="line">                DynamicDataSourceHolder.putDataSource(data.value());</span><br><span class="line">                logger.info(<span class="string">&quot;-------数据源：&#123;&#125;------&quot;</span>,data.value());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;=======================AOP注册拦截失败了！&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint point)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Object target = point.getTarget();</span><br><span class="line">        String method = point.getSignature().getName();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt;[] classz = target.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = ((MethodSignature) point.getSignature()).getMethod().getParameterTypes();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method m = classz[<span class="number">0</span>].getMethod(method, parameterTypes);</span><br><span class="line">            <span class="keyword">if</span> (m != <span class="keyword">null</span> &amp;&amp; m.isAnnotationPresent(DBSource.class)) &#123;</span><br><span class="line">                DynamicDataSourceHolder.clear();</span><br><span class="line">                logger.info(<span class="string">&quot;-------清除ThreadLocal------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;=======================AOP注册拦截失败了！&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样，我们接下来，只需要在xml文件中配置相关切点和通知方法，即完成了整个动态数据源功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置数据库注解aop --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 配置数据库注解aop --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSourceAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.github.ketao1989.simple.service.dataSource.DataSourceAspect&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;dsa&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSourceAspect&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pc&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* io.github.ketao1989.dao.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc&quot;</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc&quot;</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a><a id="End">后记</a></h2><p>本文的代码和spring源码注释可以在github上查看：</p><p>Spring源码注释：<a href="https://github.com/ketao1989/cnSpring">https://github.com/ketao1989/cnSpring</a></p><p>spring 动态数据源项目：<a href="https://github.com/ketao1989/simpleSpringProject">https://github.com/ketao1989/simpleSpringProject</a></p><p>最后，本文借鉴参考了博客园中的一篇博客：<a href="http://www.cnblogs.com/xiyangyang/p/3580625.html">spring实现数据库读写分离</a>。感谢！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis Cookbook 之 基于Redis 实现倒序索引全文搜索</title>
      <link href="2014/12/28/2014-12-28-Redis-Cookbook-Inverted-Index-Text-Search/"/>
      <url>2014/12/28/2014-12-28-Redis-Cookbook-Inverted-Index-Text-Search/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a id="Problem">问题</a></h2><p>倒序索引是一种索引数据结构，该索引存储单词（或者其他内容）到它们位于文件，档案或者数据库等位置之间的映射关系。这个通常被用来实现全文搜素服务，但是这要求在搜索之前这些文档的相关倒序索引就必须建立好。</p><p>因此，我们想要事业Redis来作为背后的存储系统来实现全文搜索服务。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><a id="Solution">解决方法</a></h2><p>我们的实现，将为每一个单词，准备一个set集合，这些集合包含对应的文档的ID。为了允许快速搜索，我们将在开始之前为所有的文档建立索引。</p><p>搜索服务本身先分割请求为各个单词，然后获取每个单词匹配的集合set的交集，最后就可以返回包含所有我们搜索的单词的文档ID集。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a><a id="Discussion">讨论</a></h2><h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><p>首先，让我们假设我们有一百个允许我们搜索的文档或者网页，因此需要对它们建立倒序索引。为了建立索引，我们必须分割文本为分开的单词（分词操作），在此过程中，可能需要排除<code>stop word</code>以及长度小于3的单词。使用Ruby脚本，如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">id_for_document</span><span class="params">(filename)</span></span></span><br><span class="line">    doc_id = <span class="variable">$redis</span>.hget(<span class="string">&quot;documents&quot;</span>, filename) </span><br><span class="line">    <span class="keyword">if</span> doc_id.<span class="literal">nil</span>?</span><br><span class="line">        doc_id = <span class="variable">$redis</span>.incr(<span class="string">&quot;next_document_id&quot;</span>) </span><br><span class="line">        <span class="variable">$redis</span>.hset(<span class="string">&quot;documents&quot;</span>, filename, doc_id) </span><br><span class="line">        <span class="variable">$redis</span>.hset(<span class="string">&quot;filenames&quot;</span>, doc_id, filename)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    doc_id </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">STOP_WORDS = [<span class="string">&quot;the&quot;</span>, <span class="string">&quot;of&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;in&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;it&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;that&quot;</span>] f = File.open(filename)</span><br><span class="line">doc_id = id_for_document(filename)</span><br><span class="line">f.each_line <span class="keyword">do</span> <span class="params">|l|</span></span><br><span class="line">    l.strip.split(<span class="regexp">/ |,|\)|\(|\;|\./</span>).each <span class="keyword">do</span> <span class="params">|word|</span></span><br><span class="line">        continue <span class="keyword">if</span> word.size &lt;= <span class="number">3</span> <span class="params">||</span> STOP_WORDS.<span class="keyword">include</span>?(word) </span><br><span class="line">        add_word(word, doc_id)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以，我们将过滤掉这些已经被加入到索引的单词，然后为我们的文档生成唯一的ID。此外，我们仍然需要完成上面的索引方法：</p><span id="more"></span><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_word</span><span class="params">(word, doc_id)</span></span> </span><br><span class="line">    <span class="variable">$redis</span>.sadd(<span class="string">&quot;word:<span class="subst">#&#123;word&#125;</span>&quot;</span>, doc_id)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此，对于每一个我们在文档中发现的单词，我们都已经创建了一个新的集合set，该set包含被发现单词的文档ID集。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>倒序索引的优势是查找的时候真的非常的快，因为绝大部分的工作在文档建索引的时候就已经完成了。为了搜索，我们仅仅需要，找到我们搜索查询里面单词对应的集合set的交集。下面的代码使用<code>redis-rb</code>接口完成查询redis服务器命令。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(*terms)</span></span></span><br><span class="line">    <span class="comment"># 对每一查询单词求对应的id集合，然后求集合的交集</span></span><br><span class="line">    document_ids = <span class="variable">$redis</span>.sinter(*terms.map&#123;<span class="params">|t|</span> <span class="string">&quot;word:<span class="subst">#&#123;t&#125;</span>&quot;</span>&#125;) </span><br><span class="line">    <span class="comment"># 根据id集合，查找对应文件名集合</span></span><br><span class="line">    <span class="variable">$redis</span>.hmget(<span class="string">&quot;filenames&quot;</span>, *document_ids)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes: <code>sinter方法</code>：求指定多个集合的交集</p></blockquote><h3 id="排序计分"><a href="#排序计分" class="headerlink" title="排序计分"></a>排序计分</h3><p>虽然前面的方法某种程度上是有限制的，并且非常简单；但是也是很容易扩展的。其中一件我们可以做的事情就是，当返回搜索结果的时候排序我们的文档，我们可以考虑计算一种分数：高分表示和我们搜索的查询更相关（比如查询单词位于文档的主题或者标题中）或者只是单纯地以为出现更高的次数。因此，我们将该索引方法如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_word</span><span class="params">(word, doc_id)</span></span> </span><br><span class="line">    <span class="variable">$redis</span>.zincrby(<span class="string">&quot;word:<span class="subst">#&#123;word&#125;</span>&quot;</span>, <span class="number">1</span>, doc_id)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>搜索的结构会变得更加复杂一点点：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(*terms)</span></span></span><br><span class="line">    document_ids = <span class="variable">$redis</span>.multi <span class="keyword">do</span></span><br><span class="line">        <span class="variable">$redis</span>.zinterstore(<span class="string">&quot;temp_set&quot;</span>, terms.map&#123;<span class="params">|t|</span> <span class="string">&quot;word:<span class="subst">#&#123;t&#125;</span>&quot;</span>&#125;)</span><br><span class="line">        <span class="variable">$redis</span>.zrevrange(<span class="string">&quot;temp_set&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>) </span><br><span class="line">    <span class="keyword">end</span>.last</span><br><span class="line">    <span class="variable">$redis</span>.hmget(<span class="string">&quot;filenames&quot;</span>, *document_ids) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes: 这里使用了前面代码中多个方法，这是因为我们在有序的<code>temp_set</code>集合中有一个潜在的竞争条件。当你必须在任务其他人也尝试访问他们改变的数据之前，都使用这两个或者更多命令（在<code>ZREVRANGE</code>命令之前完成<code>ZINTERSTORE</code>命令），就会有潜在的竞争条件存在。</p></blockquote><p>为了避免在运行的时候出现竞争条件，当我们执行并发的搜索查询的时候，我们必须要么使用Redis的<code>MULTI/EXEC</code>命令，要么可能为每一个查询搜索产生一个唯一键。（在上例中，我们必须在我们自己之后清除并且删除临时的排序set集合）。</p><p><code>MULTI 和 EXEC</code>命令运行Redis中得事务行为。在<code>MULTI/EXEC</code>块中得命令保证运行的时候序列化串行，这意味着在块长度期间，没有其他的Redis客户端获取服务。在先前的例子里，它排除了在<code>temp_set</code>中的竞争条件，因为其他客户端不可能在<code>ZINTERSTORE</code>和<code>ZREVRANGE</code>操作之间修改值。在事务内部使用<code>DISCARD</code>就会放弃事务，丢弃所有的命令，然后返回一个正常状态。</p><p>由于命令只会在<code>EXEC</code>之后才会被调用执行，因此只有在那个时刻你才会接收事务内部所有命令做出的回答响应。因此，不可能会使用同一个事务的事务内部一个命令运行的响应结果。为了达到这点，你将需要使用<code>WATCH</code>.</p><p><code>redis-rb</code>没有直接的<code>EXEC</code>调用。换句话说，在提交给你的<code>multi方法</code>的块的开始和结束，表明也是事务的开始和结束。在你块结束的时候，<code>redis-rb</code>内部会调用<code>EXEC</code>。</p><blockquote><p><em>Redis 命令</em>:</p><ul><li><p><code>ZINCRBY zset-name increment element</code></p><p>   添加或者增长在有序集合中元素的分数。而使用ZADD和SADD，则如果集合不存在则将会被创建。</p></li><li><p><code>ZINTERSTORE destination-zset number-of-zsets-to-intersect zset1 [zset2 ...] [WEIGHTS weight1 [weight2 ...]] [AGGREGATE SUM | MIN | MAX]</code></p><p>   计算给定的一些ZSETS集合的交集，然后把结果存储在新的ZSET中。此外，也可以使用增长因子或者聚合方法来获取新的集合。默认情况下，它是所有集合中分数的和，但是它也可以是最大或者最小值。</p></li><li><p><code>ZREVRANGE zset-name start-index stop-index [WITHSCORES]</code></p><p>   返回在有序集合中给定范围内的元素，以递减的顺序。这个命令也可以选择在返回结果中包含元素的分数。ZRANGE命令执行相同的操作，但是是以递增的顺序。</p></li></ul></blockquote><h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><p>对于搜索，还有许多地方可以被优化：</p><ul><li><p><em>大小写敏感</em></p><p>  我们可以在建立索引之前单词和查询之前的搜索项，使用单词的大小写敏感。</p></li><li><p><em>模糊搜索</em></p><p>  可能你也感兴趣实现模糊搜索作为你的搜索应用的一部分。它考虑基于通常错误的拼写单词。例如，在我们的例子中，在建立索引的时候也一起考虑为拼写错误单词的项建立索引，要么从一个列表中查找，要么为这个目标使用专门的算法（例如语音学上的算法）</p></li><li><p><em>部分单词匹配</em></p><p>  虽然这个非常有用，但是将会增加索引内存的使用，并且给出一些你不想要的搜索结果。为了达到这个目的，你不得不分解你的单词为子串，然后为它们建索引。例如，为单词<code>matching</code>建索引，你不得不增加下面这些：</p><pre><code>  matching  mat   matc   match   matchi   matchin</code></pre><p>  假设设置的最小长度为3个字符，并且也假设我们只匹配单词的前缀。如果我们有兴趣建立所有可能的组合，你需要为这个单词其他的子串也建立索引。</p><p>  使用有序集合对于这个和前面的模糊查找增强技术都是很有用的。你可以根据部分单词匹配和错误拼写单词而让它们<em>获取更低的分数来提高你的搜索结果质量</em>。</p></li></ul><h2 id="倒序索引介绍"><a href="#倒序索引介绍" class="headerlink" title="倒序索引介绍"></a><a id="InvertedIndex">倒序索引介绍</a></h2><p>如果不使用倒序索引技术，在每次进行检索时，搜索引擎必须遍历每一个网页，查找网页中是否包含你指定的关键词。这个工作量是十分巨大的，主要原因有二：</p><ul><li><p>互联网的网页基数非常大；</p></li><li><p>在每一个网页中检索是否含有指定的关键词不是一件简单的事情，它需要遍历网页的每个字符。<br>为了更好的建立被搜索的关键字和含有这些关键字的页面之间的映射关系，倒序索引产生了。简单的说，倒序索引的倒序，指的是这个索引是从关键词中查找对应的源的，而不是从源中检索对应的关键词。</p></li></ul><p><em>举例如下</em>：为了检索关键词 A，首先从倒序索引的索引表中，找到关键词 A，然后查找 A 所在的页。由于倒序索引表排序后，在其中查找一个关键词可以使用二分查找，特别是在采用分布式数据、服务器集群、多线程技术等条件下，效率极高，所以，查找含有某个关键词的页变得非常简单。</p><p>假设数据库中含有1000000条记录，其中有 10 条记录符合搜寻条件，如果使用倒序索引，可以很快找到这些关键词，并且定位到含有这些关键词的十条记录；否则，需要遍历1000000条记录，效率的差异可想而知。</p><p>所以，倒序索引相当于一本出处大字典，查阅其中的每个词汇，都可以告诉你它的所有出处。</p><p>倒序索引中的关键词，一般是 <em>蜘蛛（Spider）</em>在网页爬行时对网页进行分词的结果。中文分词也是一件比较麻烦的事情。关于 <em>分词技术</em>，请查阅其他相关文章。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> Redis Cookbook </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis Cookbook 之 基于Redis 实现一个聊天系统</title>
      <link href="2014/12/20/2014-12-20-Redis-Cookbook-Chat-System/"/>
      <url>2014/12/20/2014-12-20-Redis-Cookbook-Chat-System/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a id="Problem">问题</a></h2><p>想要借助 <code>Redis</code>的<code>PUB/SUB</code>功能，使用node.js和Socket.io实现一个轻量级的实时聊天系统。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><a id="Solution">解决方法</a></h2><p>由于Redis 天生就支持发布订阅(pub/sub)模式，所以我们可以很容易就使用<code>Node.js</code> 和 <code>Socket.IO</code>来快速创建一个实时的聊天系统。</p><p>发布订阅模式，其实就是接收者订阅某种特定模式的消息(比如，发送到某个指定channel的消息)，而发送者发送一个消息到消息云上。当一个消息到达云上的时候，订阅了这一种类的客户端就会获得消息。这中发布订阅模式，然后就可以允许发送者和接收客户端在不知道彼此的情况下，亲密结对交流。而他们仅仅需要以一种既定的模式发送消息和接收匹配类型的消息即可。</p><p><code>Redis</code>直接支持<code>pub/sub</code>模式，意味着其可以让接收客户端订阅指定的匹配消息频道channel，以及发布消息到一个给定的频道channel。这意味着，我们可以很简单地创建像<code>chat:cars</code>的聊车频道；或者像<code>chat:sausage</code>这种关于食物的谈话。此外，频道channel的命名跟Redis 的keySpace无关，所以不用担心会存在某些冲突情况。下面给出，Redis支持的一些命令：</p><pre><code>    * PUBLISH：发布消息到指定的频道；    * SUBSCRIBE：订阅一个指定频道的消息；    * UNSUBSCRIBE：取消订阅一个指定频道；    * PSUBSCRIBE：订阅一个满足给定模式的频道集；    * PUNSUBSCRIBE：取消订阅满足指定模式的频道集。</code></pre><p>拥有上面这些知识，为在应用程序逻辑部分之间的终端用户或者流消息实现一个聊天和统计系统，其实还是很琐碎的。<br><code>pub/sub</code>甚至可以被用来作为一个内建的强壮阻塞队列系统。接下来看看，如何去实现这么一个消息聊天系统吧。</p><p>在服务端，<code>Node.js</code> 和 <code>Socket.IO</code>将来实现网络层，然后Redis将作为一个在客户端之间递交消息的<code>pub/sub</code>功能的实现。在客户端，我们使用jQuery来处理消息，然后发送数据到服务器上。</p><span id="more"></span><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a><a id="Discussion">讨论</a></h2><p>由于本文使用Node.js来实现一个聊天系统，所以我们假设你已经安装了node.js，并且我们也希望你可以按顺序安装支持我们聊天系统所需要的<code>node库(Socket.IO and Redis)</code>。</p><h3 id="初始设置"><a href="#初始设置" class="headerlink" title="初始设置"></a>初始设置</h3><p>安装所需要的第三方库：</p><pre><code>    npm install socket.io    npm install redis</code></pre><h3 id="服务端代码实现"><a href="#服务端代码实现" class="headerlink" title="服务端代码实现"></a>服务端代码实现</h3><p>在服务端，我们正在运行<code>Redis</code>并且创建了一个运行node.js的javaScript文件。该代码主要负责建立到Redis服务之间的链接conn，然后一直监听来自clients端连接请求的端口。因此，我们创建一个javascript代码文件<code>chat.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>), </span><br><span class="line">io = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>), </span><br><span class="line">redis = <span class="built_in">require</span>(<span class="string">&#x27;redis&#x27;</span>), </span><br><span class="line">rc = redis.createClient();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码，可以建立redis连接，和引入http,socket.io,redis库。接下来，我们需要设置一个简单地server，让客户端可以连接，请求数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line">server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// we may want to redirect a client that hits this page </span></span><br><span class="line">    <span class="comment">// to the chat URL instead</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>&#125;); </span><br><span class="line">    res.end(<span class="string">&#x27;&lt;h1&gt;Hello world&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up our server to listen on 8000 and serve socket.io server.listen(8000);</span></span><br><span class="line"><span class="keyword">var</span> socketio = io.listen(server);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，建立连接了就可以开始使用node.js来完成开发连接redis，客户端订阅某个channel，接收到消息处理动作等功能。所以，接下来使用redis来完成订阅消息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// if the Redis server emits a connect event, it means we&#x27;re ready to work, </span></span><br><span class="line"><span class="comment">// which in turn means we should subscribe to our channels. Which we will. rc.on(&quot;connect&quot;, function() &#123;</span></span><br><span class="line">    rc.subscribe(<span class="string">&quot;chat&quot;</span>);</span><br><span class="line">    <span class="comment">// we could subscribe to more channels here </span></span><br><span class="line">&#125;);</span><br><span class="line">    <span class="comment">// When we get a message in one of the channels we&#x27;re subscribed to, // we send it over to all connected clients.</span></span><br><span class="line">rc.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">channel, message</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Sending: &quot;</span> + message);</span><br><span class="line">    socketio.sockets.emit(<span class="string">&#x27;message&#x27;</span>, message); </span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ok，如你所见，这段代码非常简单。其实现，就是我们在特定的channel监听消息，当有消息接收到的时候，服务端就广播给所有订阅该消息的客户端。</p><h3 id="客户端代码实现"><a href="#客户端代码实现" class="headerlink" title="客户端代码实现"></a>客户端代码实现</h3><p>完成了server端部分的开发，接下来完成一个小页面来连接Node.js，建立客户端的Socket.IO，然后处理进来和出去的消息。所以我们创建了一个很简单的<code>HTML5</code>页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span> <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Chat with Redis<span class="tag">&lt;/<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;messages&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- chat messages go here --&gt;</span> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们需要引入两个非常重要的库来获得想要的功能：jQuery 和 Socket.IO：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8000/socket.io/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们准备好了从页面连接Node.js，然后开始监听处理消息。在页面的头部增加下面的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> socket = io.connect(<span class="string">&#x27;localhost&#x27;</span>, &#123; <span class="attr">port</span>: <span class="number">8000</span> &#125;);</span></span><br><span class="line"><span class="javascript">socket.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> li = <span class="keyword">new</span> Element(<span class="string">&#x27;li&#x27;</span>).insert(data);</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;messages&#x27;</span>).insert(&#123;<span class="attr">top</span>: li&#125;); </span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个javascript代码片段表示，客户端使用<code>Socket.IO</code>连接我们的node.js实例8000端口，然后开始监听消息事件。当一个消息到达时，它创建一个新的list元素，并且把它添加到我们事先已经建好的未排序list中。</p><p>到这里，还剩下的，就是客户端发送消息了。和server端一样，我们使用<code>Socket.IO emit</code>方法，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;chatform&quot;</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;chattext&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Send&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> </span></span><br><span class="line"><span class="javascript">$(<span class="string">&#x27;#chatform&#x27;</span>).submit(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    socket.emit(<span class="string">&#x27;message&#x27;</span>, $(<span class="string">&#x27;chattext&#x27;</span>).val()); </span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;chattext&#x27;</span>).val(<span class="string">&quot;&quot;</span>); <span class="comment">// cleanup the field </span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">&#125;); </span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当一个用户写东西到<code>form</code>中，然后点击<code>Send</code>，jQuery将会使用我们的socket变量emit发送一个消息事件到服务器端，服务器然后会广播这条消息给其他所有人。最后返回false表示消息事件真的被发送提交出去了。提交的这个动作是由<code>Socket.IO</code>完成的。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> Redis Cookbook </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Guava LocalCache 缓存介绍及实现源码深入剖析</title>
      <link href="2014/12/19/2014-12-19-Guava-Cache-Guide-And-Implement-Analyse/"/>
      <url>2014/12/19/2014-12-19-Guava-Cache-Guide-And-Implement-Analyse/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>Guava是Google开源出来的Java常用工具集库,包括集合|缓存|并发|字符串|IO操作等在Java开发过程中经常需要去实现的工具类.</p><p>显然,对于这种十分常见的需求,Guava提供了自己的工具类实现.GuavaCache 提供了一般我们使用缓存所需要的几乎所有的功能,主要有:</p><ul><li><p>自动将entry节点加载进缓存结构中;</p></li><li><p>当缓存的数据已经超过预先设置的最大值时，使用LRU算法移除一些数据；</p></li><li><p>具备根据entry节点上次被访问或者写入的时间来计算过期机制；</p></li><li><p>缓存的key被封装在<code>WeakReference</code>引用内;</p></li><li><p>缓存的value被封装在<code>WeakReference</code>或者<code>SoftReference</code>引用内；</p></li><li><p>移除entry节点，可以触发监听器通知事件；</p></li><li><p>统计缓存使用过程中命中率/异常率/未命中率等数据。</p></li></ul><p>此外，<code>Guava Cache</code>其核心数据结构大体上和<code>ConcurrentHashMap</code>一致，具体细节上会有些区别。功能上，ConcurrentMap会一直保存所有添加的元素，直到显式地移除.相对地,<code>Guava Cache</code>为了限制内存占用,通常都设定为自动回收元素.在某些场景下,尽管它不回收元素,也是很有用的,因为它会自动加载缓存.</p><span id="more"></span><h2 id="Guava-Cache-介绍"><a href="#Guava-Cache-介绍" class="headerlink" title="Guava Cache 介绍"></a><a id="CacheGuide">Guava Cache 介绍</a></h2><p>在介绍<code>Guava Cache</code>使用之前，先需要引入下官方推荐的使用场景：</p><pre><code>* 愿意消耗一些内存空间来提升速度；    * 能够预计某些key会被查询一次以上；    * 缓存中存放的数据总量不会超出内存容量(`Guava Cache`是单个应用运行时的本地缓存)。</code></pre><p>不管性能，还是可用性来说，<code>Guava Cache</code>绝对是本地缓存类库中首要推荐的工具类。其提供的<code>Builder模式</code>的CacheBuilder生成器来创建缓存的方式，十分方便，并且各个缓存参数的配置设置，类似于函数式编程的写法，也特别棒。</p><p><code>Guava Cache</code>的官方文档地址：<a href="http://code.google.com/p/guava-libraries/wiki/CachesExplained">http://code.google.com/p/guava-libraries/wiki/CachesExplained</a>. 该文档对<code>Cache</code>有详细的介绍。<br><br/></p><blockquote><p>Tips：在官方文档中，提到三种方式加载<code>&lt;key,value&gt;</code>到缓存中。分别是:</p><ol><li><code>LoadingCache</code>在构建缓存的时候，使用build方法内部调用<code>CacheLoader</code>方法加载数据；</li><li>在使用get方法的时候，如果缓存不存在该key或者key过期等，则调用<code>get(K, Callable&lt;V&gt;)</code>方式加载数据；</li><li>使用粗暴直接的方式，直接想缓存中put数据。</li></ol><p> 需要说明的是，如果不能通过key快速计算出value时，则还是不要在初始化的时候直接调用<code>CacheLoader</code>加载数据到缓存中。</p></blockquote><h3 id="2-1-Guava-Cache使用示例"><a href="#2-1-Guava-Cache使用示例" class="headerlink" title="2.1 Guava Cache使用示例"></a>2.1 Guava Cache使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheLoader;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.LoadingCache;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.RemovalListener;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.RemovalNotification;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tao.ke Date: 14-12-20 Time: 下午1:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> \$Id$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CacheSample.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Callable形式的Cache</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;String, String&gt; CALLABLE_CACHE = CacheBuilder.newBuilder()</span><br><span class="line">            .expireAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS).maximumSize(<span class="number">1000</span>).recordStats()</span><br><span class="line">            .removalListener(<span class="keyword">new</span> RemovalListener&lt;Object, Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;Object, Object&gt; notification)</span> </span>&#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;Remove a map entry which key is &#123;&#125;,value is &#123;&#125;,cause is &#123;&#125;.&quot;</span>, notification.getKey(),</span><br><span class="line">                            notification.getValue(), notification.getCause().name());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CacheLoader形式的Cache</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LoadingCache&lt;String, String&gt; LOADER_CACHE = CacheBuilder.newBuilder()</span><br><span class="line">            .expireAfterAccess(<span class="number">1</span>, TimeUnit.SECONDS).maximumSize(<span class="number">1000</span>).recordStats().build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> key + <span class="keyword">new</span> Date();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span> (times-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">900</span>);</span><br><span class="line"></span><br><span class="line">            String valueCallable = CALLABLE_CACHE.get(<span class="string">&quot;key&quot;</span>, <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;key&quot;</span> + <span class="keyword">new</span> Date();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">&quot;Callable Cache -----&gt;&gt;&gt;&gt;&gt; key is &#123;&#125;,value is &#123;&#125;&quot;</span>, <span class="string">&quot;key&quot;</span>, valueCallable);</span><br><span class="line">            logger.info(<span class="string">&quot;Callable Cache -----&gt;&gt;&gt;&gt;&gt; stat miss:&#123;&#125;,stat hit:&#123;&#125;&quot;</span>,CALLABLE_CACHE.stats().missRate(),CALLABLE_CACHE.stats().hitRate());</span><br><span class="line"></span><br><span class="line">            String valueLoader = LOADER_CACHE.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">&quot;Loader Cache -----&gt;&gt;&gt;&gt;&gt; key is &#123;&#125;,value is &#123;&#125;&quot;</span>, <span class="string">&quot;key&quot;</span>, valueLoader);</span><br><span class="line">            logger.info(<span class="string">&quot;Loader Cache -----&gt;&gt;&gt;&gt;&gt; stat miss:&#123;&#125;,stat hit:&#123;&#125;&quot;</span>,LOADER_CACHE.stats().missRate(),LOADER_CACHE.stats().hitRate());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上述代码，简单的介绍了<code>Guava Cache </code>的使用，给了两种加载构建Cache的方式。在<code>Guava Cache</code>对外提供的方法中， <code>recordStats</code>和<code>removalListener</code>是两个很有趣的接口，可以很好的帮我们完成统计功能和Entry移除引起的监听触发功能。</p><p>此外，虽然在<code>Guava Cache</code>对外方法接口中提供了丰富的特性，但是如果我们在实际的代码中不是很有需要的话，建议不要设置这些属性，因为会额外占用内存并且会多一些处理计算工作，不值得。</p></blockquote><h2 id="Guava-Cache-分析前置知识"><a href="#Guava-Cache-分析前置知识" class="headerlink" title="Guava Cache 分析前置知识"></a><a id="PrepareKnowledge">Guava Cache 分析前置知识</a></h2><p><code>Guava Cache</code>就是借鉴Java的<code>ConcurrentHashMap</code>的思想来实现一个本地缓存，但是它内部代码实现的时候，还是有很多非常精彩的设计实现，并且如果对<code>ConcurrentHashMap</code>内部具体实现不是很清楚的话，通过阅读<code>Cache</code>的实现，对<code>ConcurrentHashMap</code>的实现基本上会有个全面的了解。</p><h3 id="3-1-Builder模式"><a href="#3-1-Builder模式" class="headerlink" title="3.1 Builder模式"></a>3.1 Builder模式</h3><p>设计模式之 Builder模式 在Guava中很多地方得到的使用。<code>Builder模式</code>是将一个复杂对象的构造与其对应配置属性表示的分离，也就是可以使用基本相同的构造过程去创建不同的具体对象。</p><p>Builder模式典型的结构图如：</p><img src="/images/2014/12/builder.png" /><pre><code>Builder：为创建一个Product对象的各个部件制定抽象接口；ConcreteBuilder：具体的建造者，它负责真正的生产；Director：导演, 建造的执行者，它负责发布命令；Product：最终消费的产品</code></pre><p>各类之间的交互关系如下图：</p><img src="/images/2014/12/builder-relation.png" /><p><code>Builder模式</code>的关键是其中的Director对象并不直接返回对象，而是通过（BuildPartA，BuildPartB，BuildPartC）来一步步进行对象的创建。当然这里Director可以提供一个默认的返回对象的接口（即返回通用的复杂对象的创建，即不指定或者特定唯一指定BuildPart中的参数）。</p><blockquote><p>Tips：在<code>Effective Java</code>第二版中，<code>Josh Bloch</code>在第二章中就提到使用Builder模式处理需要很多参数的构造函数。他不仅展示了Builder的使用，也描述了相这种方法相对使用带很多参数的构造函数带来的好处。</p></blockquote><p>下面给出一个使用Builder模式来构造对象，这种方式优点和不足（代码量增加）非常明显。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.builder.ToStringBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.builder.ToStringStyle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tao.ke Date: 14-12-22 Time: 下午8:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> \$Id$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderPattern</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 年龄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 性别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BuilderPattern <span class="title">newBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BuilderPattern();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BuilderPattern <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BuilderPattern <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BuilderPattern <span class="title">setGender</span><span class="params">(Gender gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ToStringBuilder.reflectionToString(<span class="keyword">this</span>, ToStringStyle.SHORT_PREFIX_STYLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Gender</span> </span>&#123;</span><br><span class="line">        MALE, FEMALE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BuilderPattern bp = BuilderPattern.newBuilder().setAge(<span class="number">10</span>).setName(<span class="string">&quot;zhangsan&quot;</span>).setGender(Gender.FEMALE);</span><br><span class="line">        System.out.println(bp.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-Java对象引用"><a href="#3-2-Java对象引用" class="headerlink" title="3.2 Java对象引用"></a>3.2 Java对象引用</h3><p>对象引用之前需要先看看对象的访问定位。</p><p>当虚拟机执行时，遇到一条new指令时，首先会去检查这个指令在常量池中是否已经存在该类对应的符号引用，并且检查这个符号引用对应的类是否已经被加载，解析和初始化。如果没有，则执行相应的类加载过程。</p><p>然后虚拟机为新的对象分配内存。虚拟机根据我们配置的垃圾收集器规则采取不同的分配方式，包括：指针碰撞分配方式和空闲列表分配方式。</p><p>内存分配完成之后，开始执行init方法。init方法会按照代码的指定过程来初始化，对一些类属性进行赋值。</p><p>然后，我们需要访问这个对象，怎么办？在Java运行时内存区域模型中，线程拥有一个虚拟机栈，这个栈会有一个本地方法表，这个表内部就会存放一个引用地址，如下图所示（HotSpot虚拟机采用这种方式，还有另外一种形式这里不做介绍）：</p><img src="/images/2014/12/reference.png" /><p>在JDK 1.2之前，Java中关于引用的定义是：如果reference类型的数据中存储的数值表示的是另外一块内存的起始地址，就说明这块内存称为引用。这种定义表明对象只有两种：被引用的对象和没有被引用的对象。这种方式对于垃圾收集GC来说，效果并不是很好，因为很多对象划为为被引用和非被引用都不是很重要，这种现象就无法划分。垃圾收集的时候，就无法更好更精准的划为可GC的对象。</p><p>因此，在JDK 1.2之后，Java对引用的概念进行扩展，有如下四种类型的引用（按强度排序）：</p><pre><code>* 强引用(Strong Reference)* 软引用(SoftReference)* 弱引用(WeakReference)* 虚引用(PhantomReference)</code></pre><ol><li><p><em>强引用</em>：强引用在程序代码中随处可见，十分普遍。比如： <code>Object object = new Object()</code> ，这类引用只要还存在，垃圾收集器就永远不会回收掉这类引用的对象。</p></li><li><p><em>软引用</em>：软引用用来描述一些虽然有用但是并不是必须的对象。对于软引用关联的对象，在系统将可能发生内存溢出异常之前，垃圾收集器将会把这些引用的对象进行第二次回收。只有这次垃圾回收还没有足够的内存的时候，才会抛出内存溢出异常。</p></li><li><p><em>弱引用</em>：弱引用是一种比软引用强度还要弱的引用，因此这些引用的对象也是非必须的。但是，对于弱引用的对象只能生存到下一次垃圾回收发生之前。当垃圾收集工作开始后，无论当前的内存是否够用，都会把这些弱引用的对象回收掉。</p></li><li><p><em>虚引用</em>：虚引用是最弱的一种引用。一个对象是否被虚引用关联，完全不会对其生存时间构成影响，也无法通过虚引用获得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p></li></ol><blockquote><p>Notes：关于引用，最典型的使用就是对HashMap的自定义开发，包括JDK内部也存在。</p><ol><li><p><code>Strong Reference</code>—&gt; <code>HashMap</code>：默认情况下，HashMap使用的引用就是强引用，也就是说垃圾收集的时候，Map中引用的对象不会被GC掉。</p></li><li><p><code>Weak Reference</code>—&gt; <code>WeakHashMap</code>：JDK中还有一种基于引用类型实现的HashMap，WeakHashMap。当节点的key不在被使用的时候，该entry就会被自动回收掉。因此，对于一个mapping映射，不能保证接下来的GC不会把这个entry回收掉。</p></li><li><p><code>Soft Reference</code>—&gt; <code>SoftHashMap</code>：在JDK中没有提供基于软引用实现的HashMap，原因可能是一般大家都不能期待出现内存溢出，而当出现内存溢出，一点点的软引用GC余下的内存空间，肯定不会起到关键作用。但是，虽然不广泛，在<code>aspectj</code>提供的<code>ClassLoaderRepository</code>类中实现了SoftHashMap，作为一个基于ClassLoader字节码实现的方法，在OOM的时候，显然需要考虑通过GC释放内存空间，并且SoftHashMap在内部是作为缓存使用。</p></li></ol></blockquote><h3 id="3-3-JMM可见性"><a href="#3-3-JMM可见性" class="headerlink" title="3.3 JMM可见性"></a>3.3 JMM可见性</h3><p>在<a href="http://ketao1989.github.io/posts/java-some-tips.html">Java一些小Tips</a>博文中，简单地介绍了JMM模型，但是Java内存模型涉及了大量的规则内容指令。</p><p><em>什么叫可见性？</em></p><p>可见性就是，当程序中一个线程修改了某个全局共享变量的值之后，其他使用该值的线程都可以获知，在随后他们读该共享变量的时候，查询的都是最新的改改修改的值。</p><p>在上一篇博文中，我们给出了内存模型访问的图。根据图可以了解，一个线程上修改共享变量，这个变量的最新的值不会立刻写入到共享内存中，还是暂时存放在线程本地缓存，然后某一时刻触发写入到共享内存中。可见性就是，当我们对共享变量修改的时候，立刻把新值同步到主内存中，然后该变量被读的时候从主内存获取最新的值确保所有对该变量的读取操作，总是获取最新最近修改的值。</p><p><em>为什么会有可见性问题？</em></p><p>学过计算机组成原理的同学都知道，在现代CPU结构中，存在多级缓存架构，如下图所示：</p><img src="/images/2014/12/cpu_cache.jpg" /><p>同样，在Java虚拟机中分为两种内存：</p><pre><code>&gt; 主内存(Main Memory)：所有线程共享的内存区域，虚拟机内存的一部分。&gt; 工作内存(Working Memory)：线程自己操作的内存区域，线程直接无法访问对方的工作内存区域。</code></pre><p>之所以分为两部分内存区域，原因和CPU很类似。为了线程可以快速访问操作变量，当线程全部直接操作共享内存，则会导致大量线程之间竞争等问题出现，影响效率。</p><p>关于Java中线程，工作内存，主内存之间的交互关系如下图（深入理解Java虚拟机配图）：</p><img src="/images/2014/12/java_mmm.png" /><p>为了保证共享变量可见性，除了上篇博文中介绍的<code>volatile</code>之外，还有<code>synchronized</code>和<code>final</code>关键字。</p><p><em>synchronized</em>：执行synchronized代码块时，在对变量执行unlock操作之前，一定会把此变量写入到主内存中。<em>final</em>：该关键字修饰的变量在构造函数中初始化完成之后（不考虑指针逃逸，变量初始化一半的问题），其他线程就可以看到这个final变量的值，并且由于变量不能修改，所以能确保可见性。</p><blockquote><p>Notes：<em>保证JMM可见性，并不代表确保变量的线程安全性！！！</em></p></blockquote><h3 id="3-4-指令重排序"><a href="#3-4-指令重排序" class="headerlink" title="3.4 指令重排序"></a>3.4 指令重排序</h3><p>重排序通常是编译器或者运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：编译期重排序和运行期重排序，分别对应编译时和运行时环境。</p><p>编译期重排序主要的原因是CPU导致的。在编译期的微指令翻译阶段，许多操作同时执行，并且执行的顺序是乱序的，所以有可能出现一条指令读一个寄存器的同时，另外一条指令正在对这个寄存器进行写操作。此外，翻译之后，就是重排序缓存阶段。不同的微指令在不同的执行单元中同时执行，而且每个执行单元都全速运行。只要当前微指令所需要的数据就绪，而且有空闲的执行单元，微指令就可以立即执行，有时甚至可以跳过前面还未就绪的微指令。通过这种方式，需要长时间运行的操作不会阻塞后面的操作，流水线阻塞带来的损失被极大的减小了。</p><p>运行期JVM会对指令进行重排序以提高程序性能，当然其会通过<code>happens-before</code>原则保证顺序执行语义，也就是不会随便对代码指令进行重排序。</p><p>借用一个例子说明（来源<a href="http://www.infoq.com/cn/articles/java-memory-model-2">http://www.infoq.com/cn/articles/java-memory-model-2</a>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;                   <span class="comment">//1</span></span><br><span class="line">    flag = <span class="keyword">true</span>;             <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Public <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">int</span> i =  a * a;        <span class="comment">//4</span></span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述的代码会造成很多的不同结果，由于数据的可见性问题，或者就是重排序。比如重排序后执行顺序如下，则会存在问题。</p><img src="/images/2014/12/reorder.png" /><h3 id="3-5-锁细化"><a href="#3-5-锁细化" class="headerlink" title="3.5 锁细化"></a>3.5 锁细化</h3><p><em>锁粒度细化，是所有保证线程安全的程序方法优化的必经之路</em>。</p><p>这两年十分火的用于线程间通信的高性能消息组件，其虽然有很多创新的设计，但是很多优化的基本就是，锁细化，包括核心数据结构 <code>Ringbuffer</code>。<a href="http://ifeve.com/dissecting-disruptor-whats-so-special/">剖析Disruptor:为什么会这么快？（一）Ringbuffer的特别之处</a></p><p>此外，在Linux内核2.6之后采用的RCU锁机制，本质上也是锁粒度细化。<a href="https://www.ibm.com/developerworks/cn/linux/l-rcu/">Linux 2.6内核中新的锁机制–RCU</a></p><p>在Java语言中，最经典的锁细化提高多线程并发性能的案例，就是<code>ConcurrentHashMap</code>，其采用多个<code>segment</code>，每个segment对应一个锁，来分散全局锁带来的性能损失。从而，当我们put某一个entry的时候，在实现的时候，一般只需要拥有某一个segment锁就可以完成。</p><p>关于普通的<code>HashTable</code>结构和<code>ConcurrentHashMap</code>结构，借用一张图来说明：</p><img src="/images/2014/12/currentHashMap.jpg" /><p>从结构上，可以很显而易见的看出两者的区别。所以，就锁这个层面上，concurrentHashMap就会比HashTable性能好。</p><h3 id="3-6-Guava-ListenableFuture接口"><a href="#3-6-Guava-ListenableFuture接口" class="headerlink" title="3.6 Guava ListenableFuture接口"></a>3.6 Guava ListenableFuture接口</h3><p>我们强烈地建议你在代码中多使用<code>ListenableFuture</code>来代替JDK的 Future, 因为：</p><ul><li><p>大多数Futures 方法中需要它。</p></li><li><p>转到<code>ListenableFuture</code> 编程比较容易。</p></li><li><p>Guava提供的通用公共类封装了公共的操作方方法，不需要提供Future和<code>ListenableFuture</code>的扩展方法。</p></li></ul><p><em>创建ListenableFuture实例</em></p><p>首先需要创建<code>ListeningExecutorService</code>实例，Guava 提供了专门的方法把JDK中提供<code>ExecutorService</code>对象转换为<code>ListeningExecutorService</code>。然后通过submit方法就可以创建一个ListenableFuture实例了。</p><p>代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(<span class="number">10</span>));</span><br><span class="line">ListenableFuture explosion = service.submit(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Explosion <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pushBigRedButton();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Futures.addCallback(explosion, <span class="keyword">new</span> FutureCallback() &#123;</span><br><span class="line">  <span class="comment">// we want this handler to run immediately after we push the big red button!</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Explosion explosion)</span> </span>&#123;</span><br><span class="line">    walkAwayFrom(explosion);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable thrown)</span> </span>&#123;</span><br><span class="line">    battleArchNemesis(); <span class="comment">// escaped the explosion!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也就是说，对于异步的方法，我可以通过监听器来根据执行结果来判断接下来的处理行为。</p><p><em>ListenableFuture 链式操作</em></p><p>使用ListenableFuture 最重要的理由是它可以进行一系列的复杂链式的异步操作。</p><p>一般，使用AsyncFunction来完成链式异步操作。不同的操作可以在不同的Executors中执行，单独的ListenableFuture 可以有多个操作等待。</p><blockquote><p>Tips:  AsyncFunction接口常被用于当我们想要异步的执行转换而不造成线程阻塞时，尽管Future.get()方法会在任务没有完成时造成阻塞，但是AsyncFunction接口并不被建议用来异步的执行转换，它常被用于返回Future实例。</p></blockquote><p>下面给出这个链式操作完成一个简单的异步字符串转换操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.AsyncFunction;</span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.FutureCallback;</span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.Futures;</span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.ListenableFuture;</span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.ListeningExecutorService;</span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.MoreExecutors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tao.ke Date: 14-12-26 Time: 下午5:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> \$Id$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerFutureChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ListeningExecutorService executorService = MoreExecutors.listeningDecorator(executor);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AsyncFunction&lt;String, String&gt; asyncFunction = <span class="keyword">new</span> AsyncFunction&lt;String, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ListenableFuture&lt;String&gt; <span class="title">apply</span><span class="params">(<span class="keyword">final</span> String input)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ListenableFuture&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;STEP1 &gt;&gt;&gt;&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                        <span class="keyword">return</span> input + <span class="string">&quot;|||step 1 ===--===||| &quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> future;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        AsyncFunction&lt;String, String&gt; asyncFunction2 = <span class="keyword">new</span> AsyncFunction&lt;String, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ListenableFuture&lt;String&gt; <span class="title">apply</span><span class="params">(<span class="keyword">final</span> String input)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ListenableFuture&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;STEP2 &gt;&gt;&gt;&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                        <span class="keyword">return</span> input + <span class="string">&quot;|||step 2 ===--===---||| &quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> future;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ListenableFuture startFuture = executorService.submit(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;BEGIN &gt;&gt;&gt;&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;BEGIN---&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ListenableFuture future = Futures.transform(startFuture, asyncFunction, executor);</span><br><span class="line">        ListenableFuture endFuture = Futures.transform(future, asyncFunction2, executor);</span><br><span class="line"></span><br><span class="line">        Futures.addCallback(endFuture, <span class="keyword">new</span> FutureCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">                System.out.println(result);</span><br><span class="line">                System.out.println(<span class="string">&quot;=======OK=======&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;========START=======&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;MAIN &gt;&gt;&gt;&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        ListenerFutureChain chain = <span class="keyword">new</span> ListenerFutureChain();</span><br><span class="line">        chain.executeChain();</span><br><span class="line">        System.out.println(<span class="string">&quot;========END=======&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="comment">// System.exit(0);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><pre><code>========START=======MAIN &gt;&gt;&gt;mainBEGIN &gt;&gt;&gt;pool-2-thread-1========END=======STEP1 &gt;&gt;&gt;pool-2-thread-2STEP2 &gt;&gt;&gt;pool-2-thread-1BEGIN---&gt;|||step 1 ===--===||| |||step 2 ===--===---||| =======OK=======</code></pre><p>从输出可以看出，代码是异步完成字符串操作的。</p><h2 id="CacheBuilder实现"><a href="#CacheBuilder实现" class="headerlink" title="CacheBuilder实现"></a><a id="CacheBuilder">CacheBuilder实现</a></h2><p>写过Cache的，或者其他一些工具类的同学知道，为了让工具类更灵活，我们需要对外提供大量的参数配置给使用者设置，虽然这带有一些好处，但是由于参数太多，使用者开发构造对象的时候过于繁杂。</p><p>上面提到过参数配置过多，可以使用Builder模式。Guava Cache也一样，它为我们提供了CacheBuilder工具类来构造不同配置的Cache实例。但是，和本文上面提到的构造器实现有点不一样，它构造器返回的是另外一个对象，因此，这意味着在实现的时候，对象构造函数需要有Builder参数提供配置属性。</p><h3 id="4-1-CacheBuilder构造LocalCache实现"><a href="#4-1-CacheBuilder构造LocalCache实现" class="headerlink" title="4.1 CacheBuilder构造LocalCache实现"></a>4.1 CacheBuilder构造LocalCache实现</h3><p>首先，我们先看看Cache的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从builder中获取相应的配置参数。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">LocalCache(CacheBuilder&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; builder, <span class="meta">@Nullable</span> CacheLoader&lt;? <span class="keyword">super</span> K, V&gt; loader) &#123;</span><br><span class="line">    concurrencyLevel = Math.min(builder.getConcurrencyLevel(), MAX_SEGMENTS);</span><br><span class="line"></span><br><span class="line">    keyStrength = builder.getKeyStrength();</span><br><span class="line">    valueStrength = builder.getValueStrength();</span><br><span class="line"></span><br><span class="line">    keyEquivalence = builder.getKeyEquivalence();</span><br><span class="line">    valueEquivalence = builder.getValueEquivalence();</span><br><span class="line"></span><br><span class="line">    maxWeight = builder.getMaximumWeight();</span><br><span class="line">    weigher = builder.getWeigher();</span><br><span class="line">    expireAfterAccessNanos = builder.getExpireAfterAccessNanos();</span><br><span class="line">    expireAfterWriteNanos = builder.getExpireAfterWriteNanos();</span><br><span class="line">    refreshNanos = builder.getRefreshNanos();</span><br><span class="line"></span><br><span class="line">    removalListener = builder.getRemovalListener();</span><br><span class="line">    removalNotificationQueue = (removalListener == NullListener.INSTANCE) ? LocalCache</span><br><span class="line">                .&lt;RemovalNotification&lt;K, V&gt;&gt; discardingQueue() : <span class="keyword">new</span> ConcurrentLinkedQueue&lt;RemovalNotification&lt;K, V&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    ticker = builder.getTicker(recordsTime());</span><br><span class="line">    entryFactory = EntryFactory.getFactory(keyStrength, usesAccessEntries(), usesWriteEntries());</span><br><span class="line">    globalStatsCounter = builder.getStatsCounterSupplier().get();</span><br><span class="line">    defaultLoader = loader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> initialCapacity = Math.min(builder.getInitialCapacity(), MAXIMUM_CAPACITY);</span><br><span class="line">    <span class="keyword">if</span> (evictsBySize() &amp;&amp; !customWeigher()) &#123;</span><br><span class="line">        initialCapacity = Math.min(initialCapacity, (<span class="keyword">int</span>) maxWeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从构造函数可以看到，Cache的所有参数配置都是从Builder对象中获取的，Builder完成了作为该模式最典型的应用，多配置参数构建对象。</p><p>在Cache中只提供一个构造函数，但是在上面代码示例中，我们演示了两种构建缓存的方式：自动加载；手动加载。那么，一般会存在一个完成两者之间的过渡<code>adapter</code>组件，接下来看看Builder在内部是如何完成创建缓存对象过程的。</p><p>OK，你猜到了。在<code>LocalCache</code>中确实提供了两种过渡类，一个是支持自动加载value的<code>LocalLoadingCache</code> 和只能在键值找不到的时候手动调用获取值方法的<code>LocalManualCache</code>。</p><p><em>LocalManualCache实现</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalManualCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LocalCache&lt;K, V&gt; localCache;</span><br><span class="line"></span><br><span class="line">    LocalManualCache(CacheBuilder&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; builder) &#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> LocalCache&lt;K, V&gt;(builder, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LocalManualCache</span><span class="params">(LocalCache&lt;K, V&gt; localCache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.localCache = localCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache methods</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getIfPresent</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localCache.getIfPresent(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, <span class="keyword">final</span> Callable&lt;? extends V&gt; valueLoader)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        checkNotNull(valueLoader);</span><br><span class="line">        <span class="keyword">return</span> localCache.get(key, <span class="keyword">new</span> CacheLoader&lt;Object, V&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> V <span class="title">load</span><span class="params">(Object key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> valueLoader.call();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheStats <span class="title">stats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleStatsCounter aggregator = <span class="keyword">new</span> SimpleStatsCounter();</span><br><span class="line">        aggregator.incrementBy(localCache.globalStatsCounter);</span><br><span class="line">        <span class="keyword">for</span> (Segment&lt;K, V&gt; segment : localCache.segments) &#123;</span><br><span class="line">            aggregator.incrementBy(segment.statsCounter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aggregator.snapshot();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serialization Support</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">writeReplace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ManualSerializationProxy&lt;K, V&gt;(localCache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从代码实现看出实际上是一个adapter组件，并且绝大部分实现都是直接调用LocalCache的方法，或者加一些参数判断和聚合。在它核心的构造函数中，就是直接调用LocalCache构造函数，对于loader对象直接设null值。</p><p><em>LocalLoadingCache实现</em></p><p><code>LocalLoadingCache</code>实现继承了``类，其主要对get相关方法做了重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalLoadingCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LocalManualCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">LoadingCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        LocalLoadingCache(CacheBuilder&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; builder, CacheLoader&lt;? <span class="keyword">super</span> K, V&gt; loader) &#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="keyword">new</span> LocalCache&lt;K, V&gt;(builder, checkNotNull(loader)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LoadingCache methods</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> localCache.getOrLoad(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getUnchecked</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> get(key);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UncheckedExecutionException(e.getCause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ImmutableMap&lt;K, V&gt; <span class="title">getAll</span><span class="params">(Iterable&lt;? extends K&gt; keys)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> localCache.getAll(keys);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">            localCache.refresh(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">apply</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getUnchecked(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Serialization Support</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Object <span class="title">writeReplace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LoadingSerializationProxy&lt;K, V&gt;(localCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>提供了这些adapter类之后，builder类就可以创建<code>LocalCache</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="comment">// 获取value可以通过key计算出</span></span><br><span class="line"><span class="keyword">public</span> &lt;K1 extends K, V1 extends V&gt; <span class="function">LoadingCache&lt;K1, V1&gt; <span class="title">build</span><span class="params">(CacheLoader&lt;? <span class="keyword">super</span> K1, V1&gt; loader)</span> </span>&#123;</span><br><span class="line">     checkWeightWithWeigher();</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> LocalCache.LocalLoadingCache&lt;K1, V1&gt;(<span class="keyword">this</span>, loader);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 手动加载</span></span><br><span class="line"> <span class="keyword">public</span> &lt;K1 extends K, V1 extends V&gt; <span class="function">Cache&lt;K1, V1&gt; <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     checkWeightWithWeigher();</span><br><span class="line">     checkNonLoadingCache();</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> LocalCache.LocalManualCache&lt;K1, V1&gt;(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-CacheBuilder参数设置"><a href="#4-2-CacheBuilder参数设置" class="headerlink" title="4.2 CacheBuilder参数设置"></a>4.2 CacheBuilder参数设置</h3><p><code>CacheBuilder</code>在为我们提供了构造一个Cache对象时，会构造各个成员对象的初始值（默认值）。了解这些默认值，对于我们分析Cache源码实现时，一些判断条件的设置原因，还是很有用的。</p><p><em>初始参数值设置</em></p><p>在<code>ConcurrentHashMap</code>中，我们知道有个并发水平（CONCURRENCY_LEVEL），这个参数决定了其允许多少个线程并发操作修改该数据结构。这是因为这个参数是最后map使用的segment个数，而每个segment对应一个锁，因此，对于一个map来说，并发环境下，理论上最大可以有segment个数的线程同时安全地操作修改数据结构。那么是不是segment的值可以设置很大呢？显然不是，要记住维护一个锁的成本还是挺高的，此外如果涉及全表操作，那么性能就会非常不好了。</p><p>其他一些初始参数值的设置如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>; <span class="comment">// 默认的初始化Map大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">4</span>; <span class="comment">// 默认并发水平</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EXPIRATION_NANOS = <span class="number">0</span>; <span class="comment">// 默认超时</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_REFRESH_NANOS = <span class="number">0</span>; <span class="comment">// 默认刷新时间</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSET_INT = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">boolean</span> strictParsing = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> initialCapacity = UNSET_INT;</span><br><span class="line"><span class="keyword">int</span> concurrencyLevel = UNSET_INT;</span><br><span class="line"><span class="keyword">long</span> maximumSize = UNSET_INT;</span><br><span class="line"><span class="keyword">long</span> maximumWeight = UNSET_INT;</span><br><span class="line"><span class="keyword">long</span> expireAfterWriteNanos = UNSET_INT;</span><br><span class="line"><span class="keyword">long</span> expireAfterAccessNanos = UNSET_INT;</span><br><span class="line"><span class="keyword">long</span> refreshNanos = UNSET_INT;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>初始对象引用设置</em></p><p>在Cache中，我们除了超时时间，键值引用属性等设置外，还关注命中统计情况，这就需要统计对象来工作。CacheBuilder提供了初始的null 统计对象和空统计对象。</p><p>此外，还会设置到默认的引用类型等设置，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认空的缓存命中统计类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Supplier&lt;? extends StatsCounter&gt; NULL_STATS_COUNTER = Suppliers.ofInstance(<span class="keyword">new</span> StatsCounter() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//......省略空override</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CacheStats <span class="title">snapshot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_STATS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CacheStats EMPTY_STATS = <span class="keyword">new</span> CacheStats(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 初始状态的统计对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统实现的简单的缓存状态统计类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Supplier&lt;StatsCounter&gt; CACHE_STATS_COUNTER = <span class="keyword">new</span> Supplier&lt;StatsCounter&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> StatsCounter <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleStatsCounter();<span class="comment">//这里构造简单地统计类实现</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的空RemovalListener，监听到移除通知，默认空处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">NullListener</span> <span class="keyword">implements</span> <span class="title">RemovalListener</span>&lt;<span class="title">Object</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;Object, Object&gt; notification)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认权重类，任何对象的权重均为1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">OneWeigher</span> <span class="keyword">implements</span> <span class="title">Weigher</span>&lt;<span class="title">Object</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">weigh</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Ticker NULL_TICKER = <span class="keyword">new</span> Ticker() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的key等同判断</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Equivalence&lt;Object&gt; <span class="title">getKeyEquivalence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstNonNull(keyEquivalence, getKeyStrength().defaultEquivalence());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认value的等同判断</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Equivalence&lt;Object&gt; <span class="title">getValueEquivalence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstNonNull(valueEquivalence, getValueStrength().defaultEquivalence());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的key引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Strength <span class="title">getKeyStrength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstNonNull(keyStrength, Strength.STRONG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认为Strong 属性的引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Strength <span class="title">getValueStrength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstNonNull(valueStrength, Strength.STRONG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;K1 extends K, V1 extends V&gt; <span class="function">Weigher&lt;K1, V1&gt; <span class="title">getWeigher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Weigher&lt;K1, V1&gt;) Objects.firstNonNull(weigher, OneWeigher.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，在我们不设置缓存中键值引用的情况下，默认都是采用强引用及相对应的属性策略来初始化的。此外，在上面代码中还可以看到，统计类<code>SimpleStatsCounter</code>是一个简单的实现。里面主要是简单地缓存累加，此外由于多线程下Long类型的线程非安全性，所以也进行了一下封装，下面给出命中率的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleStatsCounter</span> <span class="keyword">implements</span> <span class="title">StatsCounter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongAddable hitCount = LongAddables.create();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongAddable missCount = LongAddables.create();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongAddable loadSuccessCount = LongAddables.create();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongAddable loadExceptionCount = LongAddables.create();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongAddable totalLoadTime = LongAddables.create();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongAddable evictionCount = LongAddables.create();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleStatsCounter</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordHits</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">      hitCount.add(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheStats <span class="title">snapshot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CacheStats(</span><br><span class="line">          hitCount.sum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increments all counters by the values in &#123;<span class="doctag">@code</span> other&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementBy</span><span class="params">(StatsCounter other)</span> </span>&#123;</span><br><span class="line">      CacheStats otherStats = other.snapshot();</span><br><span class="line">      hitCount.add(otherStats.hitCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此，CacheBuilder的一些参数对象等得初始化就完成了。可以看到这些默认的初始化，有两套引用：Null对象和Empty对象，显然Null会更省空间，但我们在创建的时候将决定不使用某特性的时候，就会使用Null来创建，否则使用Empty来完成初始化工作。在分析Cache的时候，写后超时队列和读后超时队列也存在两个版本。</p><h2 id="LocalCache实现"><a href="#LocalCache实现" class="headerlink" title="LocalCache实现"></a><a id="LocalCache">LocalCache实现</a></h2><p>在设计实现上，<code>LocalCache</code>的并发策略和<code>concurrentHashMap</code>的并发策略是一致的，也是根据分段锁来提高并发能力,分段锁可以很好的保证 并发读写的效率。因此，该map支持非阻塞读和不同段之间并发写。</p><p>如果最大的大小指定了，那么基于段来执行操作是最好的。使用页面替换算法来决定当map大小超过指定值时，哪些entries需要被驱赶出去。页面替换算法的数据结构保证Map临时一致性：对一个segment写排序是一致的；但是对map进行更新和读不能直接立刻 反应在数据结构上。 虽然这些数据结构被lock锁保护，但是其结构决定了批量操作可以避免锁竞争出现。在线程之间传播的批量操作导致分摊成本比不强制大小限制的操作要稍微高一点。</p><p>此外，<code>LoacalCache</code>使用LRU页面替换算法，是因为该算法简单，并且有很高的命中率，以及O(1)的时间复杂度。需要说明的是， LRU算法是基于页面而不是全局实现的，所以可能在命中率上不如全局LRU算法，但是应该基本相似。</p><p>最后，要说明一点，在代码实现上，页面其实就是一个段segment。之所以说page页，是因为在计算机专业课程上，CPU，操作系统，算法上，基本上都介绍过分页导致优化效果的提升。</p><h3 id="5-1-总体数据结构"><a href="#5-1-总体数据结构" class="headerlink" title="5.1 总体数据结构"></a>5.1 总体数据结构</h3><p><code>LocalCache</code>的数据结构和<code>ConcurrentHashMap</code>一样，都是采用分segment来细化管理HashMap中的节点Entry。借用<code>ConcurrentHashMap</code>的数据结构图来说明Cache的实现：</p><img src="/images/2014/12/segement.jpg" height="300" width="600" /><p>从图中可以直观看到cache是以segment粒度来控制并发get和put等操作的，接下来首先看我们的<code>LocalCache</code>是如何构造这些segment段的，继续上面初始化localCache构造函数的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 找到大于并发水平的最小2的次方的值，作为segment数量</span></span><br><span class="line">    <span class="keyword">int</span> segmentShift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> segmentCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (segmentCount &lt; concurrencyLevel &amp;&amp; (!evictsBySize() || segmentCount * <span class="number">20</span> &lt;= maxWeight)) &#123;</span><br><span class="line">        ++segmentShift;</span><br><span class="line">        segmentCount &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - segmentShift;<span class="comment">//位 偏移数</span></span><br><span class="line">    segmentMask = segmentCount - <span class="number">1</span>;<span class="comment">//mask码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.segments = newSegmentArray(segmentCount);<span class="comment">// 构造数据数组，如上图所示</span></span><br><span class="line">    <span class="comment">//获取每个segment初始化容量，并且保证大于等于map初始容量</span></span><br><span class="line">    <span class="keyword">int</span> segmentCapacity = initialCapacity / segmentCount;</span><br><span class="line">    <span class="keyword">if</span> (segmentCapacity * segmentCount &lt; initialCapacity) &#123;</span><br><span class="line">        ++segmentCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//段Size 必须为2的次数，并且刚刚大于段初始容量</span></span><br><span class="line">    <span class="keyword">int</span> segmentSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (segmentSize &lt; segmentCapacity) &#123;</span><br><span class="line">        segmentSize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 权重设置，确保权重和==map权重</span></span><br><span class="line">    <span class="keyword">if</span> (evictsBySize()) &#123;</span><br><span class="line">        <span class="comment">// Ensure sum of segment max weights = overall max weights</span></span><br><span class="line">        <span class="keyword">long</span> maxSegmentWeight = maxWeight / segmentCount + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> remainder = maxWeight % segmentCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == remainder) &#123;</span><br><span class="line">                maxSegmentWeight--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//构造每个段结构</span></span><br><span class="line">            <span class="keyword">this</span>.segments[i] = createSegment(segmentSize, maxSegmentWeight, builder.getStatsCounterSupplier().get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i) &#123;</span><br><span class="line">            <span class="comment">//构造每个段结构</span></span><br><span class="line">            <span class="keyword">this</span>.segments[i] = createSegment(segmentSize, UNSET_INT, builder.getStatsCounterSupplier().get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes：基本上都是基于2的次数来设置大小的，显然基于移位操作比普通计算操作速度要快。此外，对于最大权重分配到段权重的设计上，很特殊。为什么呢？为了保证两者能够相等（maxWeight==sumAll(maxSegmentWeight)）,对于remainder前面的segment maxSegmentWeight的值比remainder后面的权重值大1，这样保证最后值相等。</p></blockquote><p><em>map get 方法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="meta">@Nullable</span> Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes：代码很简单，首先check key是否为null，然后计算hash值，定位到对应的segment，执行segment实例拥有的get方法获取对应的value值</p></blockquote><p><em>map put 方法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        checkNotNull(key);</span><br><span class="line">        checkNotNull(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">return</span> segmentFor(hash).put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes：和get方法一样，也是先check值，然后计算key的hash值，然后定位到对应的segment段，执行段实例的put方法，将键值存入map中。</p></blockquote><p><em>map isEmpty 方法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">    Segment&lt;K, V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (segments[i].count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += segments[i].modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum != <span class="number">0L</span>) &#123; <span class="comment">// recheck unless no modifications</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (segments[i].count != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= segments[i].modCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum != <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes：判断Cache是否为空，就是分别判断每个段segment是否都为空，但是由于整体是在并发环境下进行的，也就是说存在对一个segment并发的增加和移除元素的时候，而我们此时正在check其他segment段。</p><p>上面这种情况，决定了我们不能够获得任何一个时间点真实段状态的情况。因此，上面的代码引入了sum变量来计算段modCount变更情况。modCount表示改变segment大小size的更新次数，这个在批量读取方法期间保证它们可以看到一致性的快照。<code>需要注意，这里先获取count，该值是volatile，因此modCount通常都可以在不需要一致性控制下，获得当前segment最新的值.</code></p><p>在判断如果在第一次check的时候，发现segment发生了数据结构级别变更，则会进行recheck，就是在每个modCount下，段仍然是空的，则判断该map为空。如果发现这期间数据结构发生变化，则返回非空判断。</p></blockquote><p><em>map 其他方法</em></p><p>在Cache数据结构中，还有很多方法，和上面列出来的方法一样，其底层核心实现都是依赖segment类实例中实现的对应方法。</p><p>此外，在总的数据结构中，还提供了一些根据builder配制制定相应地缓存策略方法。比如：</p><ul><li>expiresAfterAccess：是否执行访问后超时过期策略；</li><li>expiresAfterWrite：是否执行写后超时过期策略；</li><li>usesAccessQueue：根据上面的配置决定是否需要new一个访问队列；</li><li>usesWriteQueue：根据上面的配置决定是否需要new一个写队列；</li><li>usesKeyReferences/usesValueReferences：是否需要使用特别的引用策略(非Strong引用).</li><li>等等……</li></ul><h3 id="5-2-引用数据结构"><a href="#5-2-引用数据结构" class="headerlink" title="5.2 引用数据结构"></a>5.2 引用数据结构</h3><p>在介绍Segment数据结构之前，先讲讲Cache中引用的设计。</p><p>关于Reference引用的一些说明，在博文的上面已经介绍了，这里就不赘述。在Guava Cache 中，主要使用三种引用类型，分别是：<code>STRONG引用</code>，<code>SOFT引用</code> ，<code>WEAK引用</code>。和Map不同，在Cache中，使用<code>ReferenceEntry</code>来封装键值对，并且对于值来说，还额外实现了<code>ValueReference</code>引用对象来封装对应Value对象。</p><p><em>ReferenceEntry节点结构</em></p><p>为了支持各种不同类型的引用，以及不同过期策略，这里构造了一个ReferenceEntry节点结构。通过下面的节点数据结构，可以清晰的看到缓存大致操作流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引用map中一个entry节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在map中得entries节点有下面几种状态：</span></span><br><span class="line"><span class="comment"> * valid：-live：设置了有效的key/value;-loading：加载正在处理中....</span></span><br><span class="line"><span class="comment"> * invalid：-expired：时间过期(但是key/value可能仍然设置了)；Collected：key/value部分被垃圾收集了，但是还没有被清除；</span></span><br><span class="line"><span class="comment"> * -unset：标记为unset，表示等待清除或者重新使用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ReferenceEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从entry中返回value引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ValueReference&lt;K, V&gt; <span class="title">getValueReference</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为entry设置value引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValueReference</span><span class="params">(ValueReference&lt;K, V&gt; valueReference)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回链中下一个entry（解决hash碰撞存在链表）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">ReferenceEntry&lt;K, V&gt; <span class="title">getNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回entry的hash</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHash</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回entry的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Used by entries that use access order. Access entries are maintained in a doubly-linked list. New entries are</span></span><br><span class="line"><span class="comment">     * added at the tail of the list at write time; stale entries are expired from the head of the list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回该entry最近一次被访问的时间ns</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getAccessTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置entry访问时间ns.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAccessTime</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回访问队列中下一个entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ReferenceEntry&lt;K, V&gt; <span class="title">getNextInAccessQueue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the next entry in the access queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNextInAccessQueue</span><span class="params">(ReferenceEntry&lt;K, V&gt; next)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the previous entry in the access queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ReferenceEntry&lt;K, V&gt; <span class="title">getPreviousInAccessQueue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the previous entry in the access queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPreviousInAccessQueue</span><span class="params">(ReferenceEntry&lt;K, V&gt; previous)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...... 省略write队列相关方法，和access一样</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes：从上面代码可以看到除了和Map一样，有key、value、hash和next四个属性之外，还有访问和写更新两个双向链表队列，以及entry的最近访问时间和最近更新时间。显然，多出来的属性就是为了支持缓存必须要有的过期机制。</p><p>此外，从上面的代码可以看出<em>cache支持的LRU机制实际上是建立在segment上的，也就是基于页的替换机制。</em></p><p>关于访问队列数据结构，其实质就是一个双向的链表。当节点被访问的时候，这个节点将会移除，然后把这个节点添加到链表的结尾。关于具体实现，将在segment中介绍。</p><p>创建不同类型的ReferenceEntry由其枚举工厂类EntryFactory来实现，它根据key的Strength类型、是否使用accessQueue、是否使用writeQueue来决定不同的EntryFactry实例，并通过它创建相应的ReferenceEntry实例</p></blockquote><p><em>ValueReference结构</em></p><p>同样为了支持Cache中各个不同类型的引用，其对Value类型进行再封装，支持引用。看看其内部数据属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A reference to a value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ValueReference</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value. Does not block or throw exceptions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Waits for a value that may still be loading. Unlike get(), this method can block (in the case of</span></span><br><span class="line"><span class="comment">     * FutureValueReference).</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if the loading thread throws an exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionError if the loading thread throws an error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">waitForValue</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the weight of this entry. This is assumed to be static between calls to setValue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the entry associated with this value reference, or &#123;<span class="doctag">@code</span> null&#125; if this value reference is</span></span><br><span class="line"><span class="comment">     * independent of any entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">ReferenceEntry&lt;K, V&gt; <span class="title">getEntry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为一个指定的entry创建一个该引用的副本</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> value&#125; may be null only for a loading reference.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ValueReference&lt;K, V&gt; <span class="title">copyFor</span><span class="params">(ReferenceQueue&lt;V&gt; queue, <span class="meta">@Nullable</span> V value, ReferenceEntry&lt;K, V&gt; entry)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 告知一个新的值正在加载中。这个只会关联到加载值引用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyNewValue</span><span class="params">(<span class="meta">@Nullable</span> V newValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当一个新的value正在被加载的时候，返回true。不管是否已经有存在的值。这里加锁方法返回的值对于给定的ValueReference实例来说是常量。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isLoading</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回true，如果该reference包含一个活跃的值,意味着在cache里仍然有一个值存在。活跃的值包含：cache查找返回的，等待被移除的要被驱赶的值； 非激活的包含：正在加载的值，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes：value引用接口对象中包含了不同状态的标记，以及一些加载方法和获取具体value值对象。</p><p>为了减少不必须的load加载，在value引用中增加了loading标识和wait方法等待加载获取值。这样，就可以等待上一个调用loader方法获取值，而不是重复去调用loader方法加重系统负担，而且可以更快的获取对应的值。</p><p>此外，介绍下<code>ReferenceQueue</code>引用队列，这个队列是JDK提供的，在检测到适当的可到达性更改后，垃圾回收器将已注册的引用对象添加到该队列中。因为Cache使用了各种引用，而通过ReferenceQueue这个“监听器”就可以优雅的实现自动删除那些引用不可达的key了，是不是很吊，哈哈。</p><p>在Cache分别实现了基于Strong,Soft，Weak三种形式的ValueReference实现。</p><p>这里ValueReference之所以要有对ReferenceEntry的引用是因为在Value因为WeakReference、SoftReference被回收时，需要使用其key将对应的项从Segment段中移除；<br>copyFor()函数的存在是因为在expand(rehash)重新创建节点时，对WeakReference、SoftReference需要重新创建实例（C++中的深度复制思想，就是为了保持对象状态不会相互影响），而对强引用来说，直接使用原来的值即可，这里很好的展示了对彼变化的封装思想；<br>notifiyNewValue只用于LoadingValueReference，它的存在是为了对LoadingValueReference来说能更加及时的得到CacheLoader加载的值。</p></blockquote><h3 id="5-3-Segment-数据结构"><a href="#5-3-Segment-数据结构" class="headerlink" title="5.3 Segment 数据结构"></a>5.3 Segment 数据结构</h3><p><code>Segment</code>数据结构，是ConcurrentHashMap的核心实现，也是该结构保证了其算法的高效性。在<code>Guava Cache</code> 中也一样，<code>segment</code>数据结构保证了缓存在线程安全的前提下可以高效地更新，插入，获取对应value。</p><p>实际上，segment就是一个特殊版本的hash table实现。其内部也是对应一个锁，不同的是，对于get和put操作做了一些优化处理。因此，在代码实现的时候，为了快速开发和利用已有锁特性，直接<code>extends ReentrantLock</code>。</p><p>在segment中，其主要的类属性就是一个<code>LoacalCache</code>类型的map变量。关于segment实现说明，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * segments 维护一个entry列表的table，确保一致性状态。所以可以不加锁去读。节点的next field是不可修改的final，因为所有list的增加操作</span></span><br><span class="line"><span class="comment"> * 是执行在每个容器的头部。因此，这样子很容易去检查变化，也可以快速遍历。此外，当节点被改变的时候，新的节点将被创建然后替换它们。 由于容器的list一般都比较短（平均长度小于2），所以对于hash</span></span><br><span class="line"><span class="comment"> * tables来说，可以工作的很好。虽然说读操作因此可以不需要锁进行，但是是依赖</span></span><br><span class="line"><span class="comment"> * 使用volatile确保其他线程完成写操作。对于绝大多数目的而言，count变量，跟踪元素的数量，其作为一个volatile变量确保可见性（其内部原理可以参考其他相关博文）。</span></span><br><span class="line"><span class="comment"> * 这样一下子变得方便的很多，因为这个变量在很多读操作的时候都会被获取：所有非同步的（unsynchronized）读操作必须首先读取这个count值，并且如果count为0则不会 查找table</span></span><br><span class="line"><span class="comment"> * 的entries元素；所有的同步（synchronized）操作必须在结构性的改变任务bin容器之后，才会写操作这个count值。</span></span><br><span class="line"><span class="comment"> * 这些操作必须在并发读操作看到不一致的数据的时候，不采取任务动作。在map中读操作性质可以更容易实现这个限制。例如：没有操作可以显示出 当table</span></span><br><span class="line"><span class="comment"> * 增长了，但是threshold值没有更新，所以考虑读的时候不要求原子性。作为一个原则，所有危险的volatile读和写count变量都必须在代码中标记。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> LocalCache&lt;K, V&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该segment区域内所有存活的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改变table大小size的更新次数。这个在批量读取方法期间保证它们可以看到一致性的快照：</span></span><br><span class="line"><span class="comment"> * 如果modCount在我们遍历段加载大小或者核对containsValue期间被改变了，然后我们会看到一个不一致的状态视图，以至于必须去重试。</span></span><br><span class="line"><span class="comment"> * count+modCount 保证内存一致性</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 感觉这里有点像是版本控制，比如数据库里的version字段来控制数据一致性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个段表，使用乐观锁的Array来保存entry The per-segment table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">volatile</span> AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table; <span class="comment">// 这里和concurrentHashMap不一致，原因是这边元素是引用，直接使用不会线程安全</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A queue of elements currently in the map, ordered by write time. Elements are added to the tail of the queue</span></span><br><span class="line"><span class="comment"> * on write.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;Segment.this&quot;)</span></span><br><span class="line"><span class="keyword">final</span> Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; writeQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A queue of elements currently in the map, ordered by access time. Elements are added to the tail of the queue</span></span><br><span class="line"><span class="comment"> * on access (note that writes count as accesses).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;Segment.this&quot;)</span></span><br><span class="line"><span class="keyword">final</span> Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; accessQueue;</span><br></pre></td></tr></table></figure><blockquote><p>Notes：</p><p>在segment实现中，很多地方使用count变量和modCount变量来保持线程安全，从而省掉lock开销。</p><p>在本文上面的图中说明了每个segment就是一个节点table，和jdk实现不一致，这里为了GC，内部维护的是一个<code>AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;</code>类型的列表，可以保证安全性。</p><p>最后，<code>LocalCache</code>作为一个缓存，其必须具有访问和写超时特性，因为其内部维护了访问队列和写队列，队列中的元素按照访问或者写时间排序，新的元素会被添加到队列尾部。如果，在队列中已经存在了该元素，则会先delete掉，然后再尾部add该节点，新的时间。这也就是为什么，对于<code>LocalCache</code>而言，其LRU是针对segment的，而不是全Cache范围的。</p></blockquote><p>在本文的 5.2节中知道，cache会根据初始化实例时配置来创建多个segment（<code>createSegment</code>），然后该方法最终调用segment类的构造函数创建一个段。对于参数set，就不展示，看看构造方法中其主要操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">    Segment(LocalCache&lt;K, V&gt; map, <span class="keyword">int</span> initialCapacity, <span class="keyword">long</span> maxSegmentWeight, StatsCounter statsCounter) &#123;</span><br><span class="line">        initTable(newEntryArray(initialCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; newEntryArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initTable</span><span class="params">(AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; newTable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threshold = newTable.length() * <span class="number">3</span> / <span class="number">4</span>; <span class="comment">// 0.75</span></span><br><span class="line">        <span class="keyword">if</span> (!map.customWeigher() &amp;&amp; <span class="keyword">this</span>.threshold == maxSegmentWeight) &#123;</span><br><span class="line">            <span class="comment">// prevent spurious expansion before eviction</span></span><br><span class="line">            <span class="keyword">this</span>.threshold++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.table = newTable;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>OK，这里我们已经构造好了整个localCache对象了，包括其内部每个segment中对应的节点表。这些节点table，决定了最后所有核心操作的具体实现和操作结果。</p><p>接下来，需要看看最核心的几个方法。</p><blockquote><p>Tips：本文把这几个方法单独作为几节来说明，这也表示这几个方法的重要性。</p></blockquote><h3 id="5-4-GET方法实现"><a href="#5-4-GET方法实现" class="headerlink" title="5.4 GET方法实现"></a>5.4 GET方法实现</h3><p>首先，如果我们从一个列表中查找对象，怎么做？</p><pre><code>1. 列表元素个数是否为0；2. 如果非0，则依次查询列表中元素是否是我们的对象。</code></pre><p>然后，如果是考虑超时策略的缓存呢？</p><pre><code>1. 缓存列表元素个数是否为0；2. 如果非0，则依次查询列表中元素是否是我们的对象；3. 查看队列中该对象是否已过期，如果过期则考虑其他方式获取。4. 此外，为了线程安全，必须在获取的时候，锁住表不让更新缓存操作。</code></pre><p>接下来是，<code>LocalCache</code>的缓存应该怎么做？</p><pre><code>1. 缓存中元素个数volatile count是否为0；2. 如果非0，则获取我们需要的对象引用【getEntry(key, hash)】；3. 如果对象引用不为null,则获取对应的value值；4. 如果value已经过期或者无效，则判断是否在Loading【scheduleRefresh(e, key, hash, value, now, loader)】,否则，判断是否到了refresh时间;5. 如果设置refresh，则异步刷新查询value，然后等待返回最新value【scheduleRefresh(e, key, hash, value, now, loader)】;6. ok，这里如果value还没有拿到，则查询loader方法获取对应的值(存在加锁)【lockedGetOrLoad(key, hash, loader)】。</code></pre><p>上面就是get方法的主要流程，对于其中一些核心的方法进行分析解析：</p><p><em>getEntry方法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ReferenceEntry&lt;K, V&gt; <span class="title">getEntry</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hash链表</span></span><br><span class="line">    <span class="keyword">for</span> (ReferenceEntry&lt;K, V&gt; e = getFirst(hash); e != <span class="keyword">null</span>; e = e.getNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.getHash() != hash) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hash值相同的，接下来找key值也相同的ReferenceEntry</span></span><br><span class="line">        K entryKey = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (entryKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tryDrainReferenceQueues();<span class="comment">//线程安全的清除搜集到的entries，使用lock机制。</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.keyEquivalence.equivalent(key, entryKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AtomicReferenceArray 可以确保原子的更新引用的元素。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 为给定的hash值返回第一个entry节点.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ReferenceEntry&lt;K, V&gt; <span class="title">getFirst</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制到线程安全的数组中，形成一个快照，确保读的时候，数据一致性。只会读取这个域一次。</span></span><br><span class="line">    <span class="comment">// 此外，这样子可以提供读对于整个table的影响，因为全局的table并不会锁住。（猜测）</span></span><br><span class="line">    AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table = <span class="keyword">this</span>.table;</span><br><span class="line">    <span class="keyword">return</span> table.get(hash &amp; (table.length() - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes：上面从缓存中直接获取key对应value，是完全没有加锁来完成的。</p></blockquote><p><em>scheduleRefresh方法</em></p><p>如果配置refresh特性，到了配置的刷新间隔时间，而且节点也没有正在加载，则应该进行refresh操作。refresh操作比较复杂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 刷新和key关联的value值，除非另一个线程正在做这个。如果在内部刷新了，则返回和key关联的value，否则如果另一个线程正在</span></span><br><span class="line"><span class="comment">         * 刷新或者出现error则返回null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function">V <span class="title">refresh</span><span class="params">(K key, <span class="keyword">int</span> hash, CacheLoader&lt;? <span class="keyword">super</span> K, V&gt; loader, <span class="keyword">boolean</span> checkTime)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// loadingValueReference表明当前线程开始加载，获取key对于的value引用。</span></span><br><span class="line">            <span class="keyword">final</span> LoadingValueReference&lt;K, V&gt; loadingValueReference = insertLoadingValueReference(key, hash, checkTime);</span><br><span class="line">            <span class="keyword">if</span> (loadingValueReference == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果说本线程启动加载，则开始异步调用，等待future返回get获取一个监听listenableFuture（见本文准备知识部分介绍），然后等待返回value值。loader相关方法随后介绍</span></span><br><span class="line">            ListenableFuture&lt;V&gt; result = loadAsync(key, hash, loadingValueReference, loader);</span><br><span class="line">            <span class="keyword">if</span> (result.isDone()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> Uninterruptibles.getUninterruptibly(result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="comment">// don&#x27;t let refresh exceptions propagate; error was already logged</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回一个本线程新插入的LoadingValueReference对象，或者如果一个活跃的value引用已经被加载了，则返回null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function">LoadingValueReference&lt;K, V&gt; <span class="title">insertLoadingValueReference</span><span class="params">(<span class="keyword">final</span> K key, <span class="keyword">final</span> <span class="keyword">int</span> hash, <span class="keyword">boolean</span> checkTime)</span> </span>&#123;</span><br><span class="line">            ReferenceEntry&lt;K, V&gt; e = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 加锁，保证只有一个线程对segment refresh操作</span></span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> now = map.ticker.read();</span><br><span class="line">                preWriteCleanup(now);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 快照保证</span></span><br><span class="line">                AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table = <span class="keyword">this</span>.table;</span><br><span class="line">                <span class="keyword">int</span> index = hash &amp; (table.length() - <span class="number">1</span>);</span><br><span class="line">                ReferenceEntry&lt;K, V&gt; first = table.get(index);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 查找一个存在的entry节点，和上面的getEntry方法基本一致。</span></span><br><span class="line">                <span class="keyword">for</span> (e = first; e != <span class="keyword">null</span>; e = e.getNext()) &#123;</span><br><span class="line">                    K entryKey = e.getKey();</span><br><span class="line">                    <span class="keyword">if</span> (e.getHash() == hash &amp;&amp; entryKey != <span class="keyword">null</span> &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) &#123;</span><br><span class="line">                        <span class="comment">// 如果存在我们想要的节点</span></span><br><span class="line">                        ValueReference&lt;K, V&gt; valueReference = e.getValueReference();</span><br><span class="line">                        <span class="keyword">if</span> (valueReference.isLoading() || (checkTime &amp;&amp; (now - e.getWriteTime() &lt; map.refreshNanos))) &#123;</span><br><span class="line">                            <span class="comment">// 如果loading正在处理，并且发现该节点引用的写时间未超期刷新周期，则返回null</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// continue returning old value while loading</span></span><br><span class="line">                        ++modCount;</span><br><span class="line">                        LoadingValueReference&lt;K, V&gt; loadingValueReference = <span class="keyword">new</span> LoadingValueReference&lt;K, V&gt;(</span><br><span class="line">                                valueReference);<span class="comment">//使用老的值引用</span></span><br><span class="line">                        e.setValueReference(loadingValueReference);</span><br><span class="line">                        <span class="keyword">return</span> loadingValueReference;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ++modCount;</span><br><span class="line">                LoadingValueReference&lt;K, V&gt; loadingValueReference = <span class="keyword">new</span> LoadingValueReference&lt;K, V&gt;();</span><br><span class="line">                e = newEntry(key, hash, first);<span class="comment">//一个新的节点，存放的hash链头部</span></span><br><span class="line">                e.setValueReference(loadingValueReference);</span><br><span class="line">                table.set(index, e);<span class="comment">// 插入到列表中</span></span><br><span class="line">                <span class="keyword">return</span> loadingValueReference;<span class="comment">//返回新的值引用</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">                postWriteCleanup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><em>lockedGetOrLoad方法</em></p><p>如方法名所见，该方法是加锁加载key对应的值引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 这里开始从我们实现cacheLoader继承类中的load方法获取 key对应的值。</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * 加锁get或者load</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function">V <span class="title">lockedGetOrLoad</span><span class="params">(K key, <span class="keyword">int</span> hash, CacheLoader&lt;? <span class="keyword">super</span> K, V&gt; loader)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">           ReferenceEntry&lt;K, V&gt; e;</span><br><span class="line">           ValueReference&lt;K, V&gt; valueReference = <span class="keyword">null</span>;</span><br><span class="line">           LoadingValueReference&lt;K, V&gt; loadingValueReference = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">boolean</span> createNewEntry = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 确保线程安全，使用加锁来确保加载。当然这个也是针对segment粒度来加的</span></span><br><span class="line">           lock();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// re-read ticker once inside the lock</span></span><br><span class="line">               <span class="keyword">long</span> now = map.ticker.read();</span><br><span class="line">               preWriteCleanup(now);<span class="comment">// 加锁清GC遗留引用数据和超时数据</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">int</span> newCount = <span class="keyword">this</span>.count - <span class="number">1</span>;</span><br><span class="line">               AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table = <span class="keyword">this</span>.table;</span><br><span class="line">               <span class="keyword">int</span> index = hash &amp; (table.length() - <span class="number">1</span>);<span class="comment">// 根据hash和table长度来确定index索引</span></span><br><span class="line">               ReferenceEntry&lt;K, V&gt; first = table.get(index);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> (e = first; e != <span class="keyword">null</span>; e = e.getNext()) &#123;</span><br><span class="line">                   K entryKey = e.getKey();</span><br><span class="line">                   <span class="keyword">if</span> (e.getHash() == hash &amp;&amp; entryKey != <span class="keyword">null</span> &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) &#123;</span><br><span class="line">                       valueReference = e.getValueReference();</span><br><span class="line">                       <span class="keyword">if</span> (valueReference.isLoading()) &#123;</span><br><span class="line">                           createNewEntry = <span class="keyword">false</span>;<span class="comment">// 如果正在加载，则返回false，表示不需要新建entry</span></span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">// 对value进行判断处理，</span></span><br><span class="line">                           V value = valueReference.get();</span><br><span class="line">                           <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                               <span class="comment">// 相关通知操作，GC原因回收了</span></span><br><span class="line">                               enqueueNotification(entryKey, hash, valueReference, RemovalCause.COLLECTED);</span><br><span class="line">                           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (map.isExpired(e, now)) &#123;</span><br><span class="line">                               <span class="comment">// This is a duplicate check, as preWriteCleanup already purged expired</span></span><br><span class="line">                               <span class="comment">// entries, but let&#x27;s accomodate an incorrect expiration queue.</span></span><br><span class="line">                               enqueueNotification(entryKey, hash, valueReference, RemovalCause.EXPIRED);</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="comment">// cache存在value，命中缓存</span></span><br><span class="line">                               recordLockedRead(e, now);</span><br><span class="line">                               statsCounter.recordHits(<span class="number">1</span>);</span><br><span class="line">                               <span class="comment">// we were concurrent with loading; don&#x27;t consider refresh</span></span><br><span class="line">                               <span class="keyword">return</span> value;</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// 最后写count，保证前面的变量操作，对内存立刻可见</span></span><br><span class="line">                           writeQueue.remove(e);</span><br><span class="line">                           accessQueue.remove(e);</span><br><span class="line">                           <span class="keyword">this</span>.count = newCount; <span class="comment">// write-volatile</span></span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 处理需要新增entry，从load方法获取的逻辑</span></span><br><span class="line">               <span class="keyword">if</span> (createNewEntry) &#123;</span><br><span class="line">                   loadingValueReference = <span class="keyword">new</span> LoadingValueReference&lt;K, V&gt;();</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       e = newEntry(key, hash, first);<span class="comment">// segment神马都没有的时候，新建一个</span></span><br><span class="line">                       e.setValueReference(loadingValueReference);</span><br><span class="line">                       table.set(index, e);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       e.setValueReference(loadingValueReference);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               unlock();</span><br><span class="line">               postWriteCleanup();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// ok,上面加锁部分建完了新的entry，设置完valueReference</span></span><br><span class="line">           <span class="keyword">if</span> (createNewEntry) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 在entry同步，但检测到递归load则会快速失败。当entry被copy时候可能绕行，但是绝大部分时间会快速失败</span></span><br><span class="line">                   <span class="keyword">synchronized</span> (e) &#123;</span><br><span class="line">                       <span class="keyword">return</span> loadSync(key, hash, loadingValueReference, loader);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   statsCounter.recordMisses(<span class="number">1</span>);<span class="comment">// 处理命中率</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 如果正在加载，则等待加载完成</span></span><br><span class="line">               <span class="comment">// The entry already exists. Wait for loading.</span></span><br><span class="line">               <span class="keyword">return</span> waitForLoadingValue(e, key, valueReference);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Tips：不管是lockget还是refresh，最后都会调用不同的load方法，只不过refresh使用<code>loadingFuture.addListener</code>方式来异步加载值而已。其最后都会调用<code>getAndRecordStats</code>方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">getAndRecordStats</span><span class="params">(K key, <span class="keyword">int</span> hash, LoadingValueReference&lt;K, V&gt; loadingValueReference,</span></span></span><br><span class="line"><span class="params"><span class="function">               ListenableFuture&lt;V&gt; newValue)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">           V value = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               value = getUninterruptibly(newValue);<span class="comment">// 非中断方式调用future.get方法获取值</span></span><br><span class="line">               <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InvalidCacheLoadException(<span class="string">&quot;CacheLoader returned null for key &quot;</span> + key + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               statsCounter.recordLoadSuccess(loadingValueReference.elapsedNanos());</span><br><span class="line">               <span class="comment">//线程安全地把key和value存放到cache中。</span></span><br><span class="line">               storeLoadedValue(key, hash, loadingValueReference, value);</span><br><span class="line">               <span class="keyword">return</span> value;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   statsCounter.recordLoadException(loadingValueReference.elapsedNanos());</span><br><span class="line">                   removeLoadingValue(key, hash, loadingValueReference);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Notes：上面代码会调用storeLoadedValue方法,这个方法和后面的put方法实现很相似.如下:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先，这里是线程安全的。把key和value存放到cache中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">storeLoadedValue</span><span class="params">(K key, <span class="keyword">int</span> hash, LoadingValueReference&lt;K, V&gt; oldValueReference, V newValue)</span> </span>&#123;</span><br><span class="line">    lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> now = map.ticker.read();</span><br><span class="line">        preWriteCleanup(now);<span class="comment">// clean工作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> newCount = <span class="keyword">this</span>.count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCount &gt; <span class="keyword">this</span>.threshold) &#123; <span class="comment">// 保证大小够用ensure capacity</span></span><br><span class="line">            expand();</span><br><span class="line">            newCount = <span class="keyword">this</span>.count + <span class="number">1</span>;<span class="comment">// 扩容之后，count可能会变化</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table = <span class="keyword">this</span>.table;</span><br><span class="line">        <span class="keyword">int</span> index = hash &amp; (table.length() - <span class="number">1</span>);</span><br><span class="line">        ReferenceEntry&lt;K, V&gt; first = table.get(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前segment中已经存在了该key元素</span></span><br><span class="line">        <span class="keyword">for</span> (ReferenceEntry&lt;K, V&gt; e = first; e != <span class="keyword">null</span>; e = e.getNext()) &#123;</span><br><span class="line">            K entryKey = e.getKey();</span><br><span class="line">            <span class="comment">// 找到hash链中对应的相等节点,则add操作;但是如果value是活跃的,则先移除</span></span><br><span class="line">            <span class="keyword">if</span> (e.getHash() == hash &amp;&amp; entryKey != <span class="keyword">null</span> &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) &#123;</span><br><span class="line">                ValueReference&lt;K, V&gt; valueReference = e.getValueReference();</span><br><span class="line">                V entryValue = valueReference.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 实现就有value引用的情况下</span></span><br><span class="line">                <span class="keyword">if</span> (oldValueReference == valueReference || (entryValue == <span class="keyword">null</span> &amp;&amp; valueReference != UNSET)) &#123;</span><br><span class="line">                    ++modCount;</span><br><span class="line">                    <span class="comment">// 首先如果value引用活跃,则让放入等待GC回收队列中,等待被回收.</span></span><br><span class="line">                    <span class="keyword">if</span> (oldValueReference.isActive()) &#123;</span><br><span class="line">                        RemovalCause cause = (entryValue == <span class="keyword">null</span>) ? RemovalCause.COLLECTED</span><br><span class="line">                                : RemovalCause.REPLACED;</span><br><span class="line">                        <span class="comment">// 如果监听类配置了,则这里会触发监听方法响应</span></span><br><span class="line">                        enqueueNotification(key, hash, oldValueReference, cause);</span><br><span class="line">                        newCount--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 更新新的值引用,如上所述,如果有老值,不直接删除,让GC回收.</span></span><br><span class="line">                    <span class="comment">// 这里会操作访问队列和写队列,还有其他对外的抽象监听方法调用等</span></span><br><span class="line">                    setValue(e, key, newValue, now);</span><br><span class="line">                    <span class="keyword">this</span>.count = newCount; <span class="comment">// write-volatile,确保modCount能及时写入共享内存中</span></span><br><span class="line">                    evictEntries();<span class="comment">// 移除操作,put方法也调用.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//那如果value引用已经没有了呢?!也就是value引用已经被回收了,而不只是value值为null</span></span><br><span class="line">                <span class="comment">// 新建一个value引用就好了呀?为什么返回false呢???</span></span><br><span class="line">                valueReference = <span class="keyword">new</span> WeightedStrongValueReference&lt;K, V&gt;(newValue, <span class="number">0</span>);</span><br><span class="line">                enqueueNotification(key, hash, valueReference, RemovalCause.REPLACED);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果事先segment数组中没有该key,则新建一个节点entry</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        ReferenceEntry&lt;K, V&gt; newEntry = newEntry(key, hash, first);</span><br><span class="line">        setValue(newEntry, key, newValue, now);</span><br><span class="line">        table.set(index, newEntry);</span><br><span class="line">        <span class="keyword">this</span>.count = newCount; <span class="comment">// write-volatile</span></span><br><span class="line">        evictEntries();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">        postWriteCleanup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-PUT方法实现"><a href="#5-5-PUT方法实现" class="headerlink" title="5.5 PUT方法实现"></a>5.5 PUT方法实现</h3><p>和 get方法相比，put方法则相对而言，简单了很多，直接上<code>Guava LocalCache</code>的实现。</p><pre><code>1. 加锁，对于更新操作，是需要加锁来确保线程安全的。2. put操作，所以需要确保当前的空间，足够存放；否则需要扩容【expand】3. 查看当前cache中是否已经存在该对象对应的key；3.1. 如果存在，则更新相关的value，并且更新相关的时间参数；3.2. 如果不存在，则创建一个新entry，然后放入table数组中。4. 在上面的一些步骤中，还涉及到移除一些参数。【evictEntries】.当我们put操作的时候, 对于map的segment容量就可能会有变更,这样子就需要调用evict方法,决定是否需要采取移除多余的元素.</code></pre><p><em>expand方法</em></p><p>扩展table的大小空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果需要并且没到限制大小，则扩展表table。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;Segment.this&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; oldTable = table;<span class="comment">// 原子引用</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length();</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">// 无法扩容</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把每个list的nodes分类到新的map中。 因为我们这里使用的是2的指数次扩容，所以在每个bin的元素，要么还是同样的index中待着，</span></span><br><span class="line"><span class="comment">     * 要么移到2的指数个偏移。我们排除了不必要的节点创建（可以优化场景：因为老的节点们下一个fields不会被改变，所以老的节点可以被重复使用）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 以默认域设置来统计，当我们双倍扩展table时，仅仅只有六分之一的节点需要clone。这些节点将会被GC掉， 在他们不在被任务reader线程（这些线程可能正遍历在table的中间部分）引用的时候。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> newCount = count;</span><br><span class="line">    AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; newTable = newEntryArray(oldCapacity &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    threshold = newTable.length() * <span class="number">3</span> / <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> newMask = newTable.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> oldIndex = <span class="number">0</span>; oldIndex &lt; oldCapacity; ++oldIndex) &#123;</span><br><span class="line">        <span class="comment">// 我们必须保证任务对老Map的正在进行的读操作可以处理，所以我们不能每个bin设置null</span></span><br><span class="line">        ReferenceEntry&lt;K, V&gt; head = oldTable.get(oldIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ReferenceEntry&lt;K, V&gt; next = head.getNext();</span><br><span class="line">            <span class="keyword">int</span> headIndex = head.getHash() &amp; newMask;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// hash链只有一个节点的情况</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                newTable.set(headIndex, head);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 这里可以重复使用链表，如注释所述，2的倍数扩展，很多引用hash值还是一样，所以把链表头直接set过去就可以了</span></span><br><span class="line">                ReferenceEntry&lt;K, V&gt; tail = head;</span><br><span class="line">                <span class="keyword">int</span> tailIndex = headIndex;</span><br><span class="line">                <span class="keyword">for</span> (ReferenceEntry&lt;K, V&gt; e = next; e != <span class="keyword">null</span>; e = e.getNext()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newIndex = e.getHash() &amp; newMask;</span><br><span class="line">                    <span class="keyword">if</span> (newIndex != tailIndex) &#123;</span><br><span class="line">                        <span class="comment">// 如果hash更变了，则引用改变。将需要复制前面的节点</span></span><br><span class="line">                        tailIndex = newIndex;</span><br><span class="line">                        tail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newTable.set(tailIndex, tail);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Clone nodes leading up to the tail.</span></span><br><span class="line">                <span class="keyword">for</span> (ReferenceEntry&lt;K, V&gt; e = head; e != tail; e = e.getNext()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newIndex = e.getHash() &amp; newMask;</span><br><span class="line">                    ReferenceEntry&lt;K, V&gt; newNext = newTable.get(newIndex);</span><br><span class="line">                    ReferenceEntry&lt;K, V&gt; newFirst = copyEntry(e, newNext);</span><br><span class="line">                    <span class="keyword">if</span> (newFirst != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 设置新位置的节点链表</span></span><br><span class="line">                        newTable.set(newIndex, newFirst);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 移除节点相关操作</span></span><br><span class="line">                        removeCollectedEntry(e);</span><br><span class="line">                        newCount--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="keyword">this</span>.count = newCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>evictEntries方法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果segment满了，则执行evict操作。这个调用仅仅发生在增加一个新的entry并且增加了count的时候。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;Segment.this&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!map.evictsBySize()) &#123; <span class="comment">// 如果没有设置cache的权重，则不执行evict操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除recencyQueue队列，按照指定的相关顺序来读取entries并且更新驱赶的元数据。</span></span><br><span class="line">    <span class="comment">// 把他们加到相关的evict列表 （这表明他们可以被移除出map中，由于被加到了recencyQueue队列中。）</span></span><br><span class="line">    drainRecencyQueue();</span><br><span class="line">    <span class="keyword">while</span> (totalWeight &gt; maxSegmentWeight) &#123; <span class="comment">// 当总的权重大于设置的最大段权重，才会执行remove操作</span></span><br><span class="line">        ReferenceEntry&lt;K, V&gt; e = getNextEvictable();</span><br><span class="line">        <span class="keyword">if</span> (!removeEntry(e, e.getHash(), RemovalCause.SIZE)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Guava-Cache扩展"><a href="#Guava-Cache扩展" class="headerlink" title="Guava Cache扩展"></a><a id="CacheOverWrite">Guava Cache扩展</a></h2><p>Guava的CacheBuilder是一个final对象，不允许继承。但是，其提供看专门用来扩展的接口供重写部分方法。分别为<code>ForwardingCache</code>和<code>ForwardingLoadingCache</code>，对应着Cache类和LoadingCache类。</p><p>两个扩展类，采用委托模式和/或装饰模式，提供抽象实现。</p><p>委派模式（Delegate）是面向对象设计模式中常用的一种模式。这种模式的原理为类B和类A是两个互相没有任何关系的类，B具有和A一模一样的方法和属性；并且调用B中的方法，属性就是调用A中同名的方法和属性。B好像就是一个受A授权委托的中介。第三方的代码不需要知道A的存在，也不需要和A发生直接的联系，通过B就可以直接使用A的功能，这样既能够使用到A的各种公能，又能够很好的将A保护起来了。</p><p>Decorator装饰模式是一种结构型模式，它主要是解决：“过度地使用了继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀（多继承）。继承为类型引入的静态特质的意思是说以继承的方式使某一类型要获得功能是在编译时。所谓静态，是指在编译时；动态，是指在运行时。</p><p>GoF《设计模式》中说道：动态的给一个对象添加一些额外的职责。就增加功能而言，Decorator模式比生成子类更为灵活。</p><p>两种模式其实很相近。委派模式的最终结果就是达到装饰模式的目的。</p><p>简单地来看看ForwardingCache抽象类的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个缓存将所有他的方法调用转到其他cache上。子类需要重写一个或者多个方法来改变背后cache的行为。</span></span><br><span class="line"><span class="comment"> * 因此，在该类里面会有一个delegate的成员，负责调用具体的cache类对象方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Beta</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ForwardingObject</span> <span class="keyword">implements</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Constructor for use by subclasses. */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">ForwardingCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Cache&lt;K, V&gt; <span class="title">delegate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 11.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">getIfPresent</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate().getIfPresent(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 11.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, Callable&lt;? extends V&gt; valueLoader)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate().get(key, valueLoader);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 11.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ImmutableMap&lt;K, V&gt; <span class="title">getAllPresent</span><span class="params">(Iterable&lt;?&gt; keys)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate().getAllPresent(keys);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 11.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    delegate().put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 12.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K,? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    delegate().putAll(m);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    delegate().invalidate(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 11.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidateAll</span><span class="params">(Iterable&lt;?&gt; keys)</span> </span>&#123;</span><br><span class="line">    delegate().invalidateAll(keys);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidateAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    delegate().invalidateAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate().size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheStats <span class="title">stats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate().stats();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ConcurrentMap&lt;K, V&gt; <span class="title">asMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate().asMap();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    delegate().cleanUp();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A simplified version of &#123;<span class="doctag">@link</span> ForwardingCache&#125; where subclasses can pass in an already</span></span><br><span class="line"><span class="comment">   * constructed &#123;<span class="doctag">@link</span> Cache&#125; as the delegete.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 10.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Beta</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleForwardingCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ForwardingCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cache&lt;K, V&gt; delegate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SimpleForwardingCache</span><span class="params">(Cache&lt;K, V&gt; delegate)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.delegate = Preconditions.checkNotNull(delegate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Cache&lt;K, V&gt; <span class="title">delegate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Guava-Cache-总结"><a href="#Guava-Cache-总结" class="headerlink" title="Guava Cache 总结"></a><a id="End">Guava Cache 总结</a></h2><p>Guava Cache的实现,核心数据结构和算法都是和JDK 1.6版本的<code>ConcurrentHashMap</code>一致.因此,如果你熟悉ConcurrentHashMap实现原理,对Cache是很容易明白的.</p><p>此外,Guava 还提供了相当多的优秀的工具类给开发者快速开发业务. 在后续的博客中, 会进一步介绍.</p><p>关于Guava 的源码学习, 博主都将一些注解和思考, 放在了源码解读中. 关于源码的地址, 请参考github: <a href="https://github.com/ketao1989/cnGuava.git">https://github.com/ketao1989/cnGuava.git</a></p><blockquote><p>源码被裁剪过, 删掉了一些不太关注的GWT相关源码等, 所以是无法编译的. </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis Cookbook 之 使用Redis存储基于时间序列的数据和进行分析</title>
      <link href="2014/11/29/2014-11-29-Redis-Cookbook-Analytics-Time-Based-Data/"/>
      <url>2014/11/29/2014-11-29-Redis-Cookbook-Analytics-Time-Based-Data/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a id="Problem">问题</a></h2><p>存储分析或者其他基于时间序列的数据，对于传统的存储系统（比如RDBMS）来说，是有一点挑战的。可能你想要对输入流量的速率进行限制（要求快速和高并发更新）或者简单地追踪网站访问者（或者其他更复杂的度量指标），然后以图表的形式画出来。</p><p>虽然当前在其他系统中，有很多的方式存储这类数据；但是，Redis是一个非常优秀的候选者，由于它强大的数据结构。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><a id="Solution">解决方法</a></h2><p>Redis 理念上非常适合存储这类数据，以及跟踪某种特定的事件。具有原子性的，并且非常快的（O(1)时间复杂度）<code>HINCR</code>和<code>HINCRBY</code>命令，结合快速数据查找，使得它非常适合这类场景。</p><p>在Redis中一种好的高效内存存储这类数据的方式是使用hash来存储统计值，使用<code>HINCRBY</code>增加它们，然后使用<code>HGET</code>和<code>HMGET</code>来获取这些数据。查找位于top位置的元素通过<code>SORT</code>命令也是很容易做到的。</p><span id="more"></span><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a><a id="Discussion">讨论</a></h2><p>为了简单起见，在这个实例中，我们将只追踪网页点击率数据。这也可以很简单地扩展到其他任务类型的事件。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;rubygems&#x27;</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;active_support/time&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加访问者的点击数，id表，date键，field数值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_hit</span><span class="params">(id)</span></span></span><br><span class="line">    <span class="variable">$redis</span>.sadd(<span class="string">&quot;clients&quot;</span>, id)</span><br><span class="line">    <span class="variable">$redis</span>.hincrby(<span class="string">&quot;stats/client:<span class="subst">#&#123;id&#125;</span>&quot;</span>, <span class="string">&quot;total&quot;</span>, <span class="number">1</span>) </span><br><span class="line">    <span class="variable">$redis</span>.hincrby(<span class="string">&quot;stats/client:<span class="subst">#&#123;id&#125;</span>&quot;</span>, Date.today.to_s(<span class="symbol">:number</span>), <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们在这里把用户（如果我们追踪网站的访问者，那么可以只简单地根据IP地址来区分用户）的ID添加到访问者列表中，然后记录在两个不同时间空挡中的点击数：”total”总数和日常的数。因此，这就允许我们追踪每天的网页点击数和一段时间内的全局总数。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 获取某id的key对应的值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hits</span><span class="params">(id, day = Date.today)</span></span> </span><br><span class="line">    <span class="variable">$redis</span>.hget(<span class="string">&quot;stats/client:<span class="subst">#&#123;id&#125;</span>&quot;</span>, day.to_s(<span class="symbol">:number</span>)).to_i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否超过阈值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">over_limit?</span><span class="params">(id, limit)</span></span> </span><br><span class="line">    hits(id) &gt; limit</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这允许我们通过简单地检查访问者访问，是否超过了我们设置的在一段时间区间内的阈值，来执行速率限制功能。</p><p>获取一个给定时间区间内的数据，也是一项琐碎但是高效的操作，我们可以用来画图表或者以其他方式展示这些数据：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 计算给定开始时间和结束时间对应的key值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keys</span><span class="params">(beg_p, end_p)</span></span> </span><br><span class="line">    keys = []</span><br><span class="line">    <span class="keyword">while</span> beg_p &lt;= end_p</span><br><span class="line">        keys &lt;&lt; <span class="keyword">if</span> block_given? </span><br><span class="line">            <span class="keyword">yield</span>(beg_p.to_s(<span class="symbol">:number</span>))</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            beg_p.to_s(<span class="symbol">:number</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        beg_p += <span class="number">1</span>.day </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    keys </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stats_for_period</span><span class="params">(id, beginning_of_period, end_of_period)</span></span> </span><br><span class="line">    beg_p = Date.parse(beginning_of_period)</span><br><span class="line">    end_p = Date.parse(end_of_period)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取id表中key对应的数据集</span></span><br><span class="line">    <span class="variable">$redis</span>.hmget <span class="string">&quot;stats/client:<span class="subst">#&#123;id&#125;</span>&quot;</span>, *keys(beg_p, end_p) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们也可以获取我们存储数据中在任何时间空挡的位于top的用户，可以使用<code>SORT</code>命令完成。SORT允许我们排序一个集合set，有序的集合sorted set,，或者本例中得列表list，访问者可以选择使用外键-我们时间片，然后指定order，offset，limit等参数：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照key为period进行排序，默认DESC，前0-limit个元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top_clients</span><span class="params">(period = <span class="string">&quot;total&quot;</span>, limit = <span class="number">5</span>)</span></span></span><br><span class="line"><span class="variable">$redis</span>.sort(<span class="string">&quot;clients&quot;</span>, <span class="symbol">:by</span> =&gt; <span class="string">&quot;stats/client:*-&gt;<span class="subst">#&#123;period&#125;</span>&quot;</span>, <span class="symbol">:order</span> =&gt; <span class="string">&quot;DESC&quot;</span>,<span class="symbol">:get</span> =&gt; [<span class="string">&quot;#&quot;</span>, <span class="string">&quot;stats/client:*-&gt;<span class="subst">#&#123;period&#125;</span>&quot;</span>], <span class="symbol">:limit</span> =&gt; [<span class="number">0</span>, limit])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用hash的实现方式，对于存储，检索和更新都是高度优化的（所有都是O(1)操作），但是对于计算top用户而言则不是（尤其是一个时间区间内）。你需要要求这些操作-比如当你显示一个高分值表格，你可以重新使用有序集合sorted set来完成排序，这样可以保证你拿到的数据是有序的：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_hit</span><span class="params">(id)</span></span></span><br><span class="line">    <span class="variable">$redis</span>.zincrby(<span class="string">&quot;stats/total&quot;</span>, <span class="number">1</span>, id) </span><br><span class="line">    <span class="variable">$redis</span>.zincrby(<span class="string">&quot;stats/<span class="subst">#&#123;Date.today.to_s(<span class="symbol">:number</span>)&#125;</span>&quot;</span>, <span class="number">1</span>, id)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hits</span><span class="params">(id, day = Date.today)</span></span> </span><br><span class="line">    <span class="variable">$redis</span>.zrank(<span class="string">&quot;stats/<span class="subst">#&#123;day.to_s(<span class="symbol">:number</span>)&#125;</span>&quot;</span>, id)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">over_limit?</span><span class="params">(id, limit)</span></span> </span><br><span class="line">    hits(id) &gt; limit</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stats_for_period</span><span class="params">(id, beginning_of_period, end_of_period)</span></span> </span><br><span class="line">    beg_p = Date.parse(beginning_of_period)</span><br><span class="line">    end_p = Date.parse(end_of_period)</span><br><span class="line"></span><br><span class="line">    keys(beg_p, end_p) &#123; <span class="params">|k|</span> <span class="variable">$redis</span>.zrank(<span class="string">&quot;stats/<span class="subst">#&#123;k&#125;</span>&quot;</span>, id) &#125; </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top_clients</span><span class="params">(period = <span class="string">&quot;total&quot;</span>, limit = <span class="number">5</span>)</span></span> </span><br><span class="line">    <span class="variable">$redis</span>.zrevrange(<span class="string">&quot;stats/<span class="subst">#&#123;period&#125;</span>&quot;</span>, <span class="number">0</span>, limit, <span class="symbol">:withscores</span> =&gt; <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top_for_period</span><span class="params">(beginning_of_period, end_of_period, limit = <span class="number">5</span>)</span></span> </span><br><span class="line">    beg_p = Date.parse(beginning_of_period)</span><br><span class="line">    end_p = Date.parse(end_of_period)</span><br><span class="line"></span><br><span class="line">    result_key = <span class="string">&quot;top/<span class="subst">#&#123;beg_p.to_s(<span class="symbol">:number</span>)&#125;</span>/<span class="subst">#&#123;end_p.to_s(<span class="symbol">:number</span>)&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$redis</span>.zrevrange(result_key, <span class="number">0</span>, limit, <span class="symbol">:withscores</span> =&gt; <span class="literal">true</span>) <span class="keyword">if</span> <span class="variable">$redis</span>.exists result_key</span><br><span class="line"></span><br><span class="line">    <span class="variable">$redis</span>.multi <span class="keyword">do</span></span><br><span class="line">        <span class="variable">$redis</span>.zunionstore result_key, keys(beg_p, end_p)&#123;<span class="params">|k|</span> <span class="string">&quot;stats/<span class="subst">#&#123;k&#125;</span>&quot;</span>&#125; <span class="variable">$redis</span>.expire result_key, <span class="number">10</span>.minutes</span><br><span class="line">        <span class="variable">$redis</span>.zrevrange result_key, <span class="number">0</span>, limit, <span class="symbol">:withscores</span> =&gt; <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span>.last </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Notes：我们保持了<code>ZUNIONSTORE</code>的结果，然后在它上面设置一个超时时间戳。这是一个通用的Redis模式：缓存一个计算昂贵的操作结果，然后每次有请求过来，都会在重新操作之前先检查缓存情况。<br>在上面的例子中，我们使用hash的地方，我们也可以存储SORT操作的结果，然后使用和EXISTS相似的方式检查它的缓存对象的存在性。</p></blockquote><p>当我们使用有序集合sorted sets时，这些top操作会更高效率的多（因为数据已经是排好序了），但是我们的内存使用率也会更高。</p><blockquote><p>Warns：这个特定的例子有一个竞争条件：如果缓存不存在，我们可能在结束之前会进行多次<code>ZUNIONSTORE</code>操作。因为我们最后期待的输出显然是相同或者更新的数值结果，因此存在竞争条件比使用<code>WATCH</code>，然后在我们在做客户端的计算时锁定其他访问者，效果可能会更好。</p></blockquote><p>-</p><blockquote><p><em>Redis 命令</em>:</p><ul><li><p><code>HINCRBY hash-name field increment-value</code></p><p>   按照给定的increment-value值增加hash表中存储的对应整数。这个命令和INCRBY很相似，但是和增加字符串不一样，这个使用在hash表中。而且increment-value的值也允许为负数。</p></li><li><p><code>HMGET hash-name field1 [field2 ...]</code></p><p>   从给定的hash表中获取一些field值。这个命令和HGET很相似，但是这个允许你在一个单操作中获取一些field值。</p></li><li><p><code>SORT key [BY pattern] [LIMIT offset count] [GET pattern1 [GET pattern2 ...]] [ASC| DESC] [ALPHA] [STORE destination]</code></p><p>  允许你排序一个list,set,或者sorted set，比较他们的值。排序也可以是使用外键完成，使用来自字符串或者hashes的模式匹配查询，就像我们在上面的例子中那样：<code>SORT clients BY stats/client:*-&gt;20110407</code>。其中，通配符*可以被set中成员所替换，所以在这些hash表中排序是基于匹配field 为20110407的值来完成的。如果我们把分析数据存储在strings中而不是hash表，则我们可以提交命令：<code>SORT clients BY stats/client:*/20110407</code>。<br>   使用相同的模式，你除了排好序的list也可以获取更多地数据（比如你用来排序的值）.可选择地，在list里SORT的输出也可以被排序。</p></li><li><p><code>ZRANK set-name member</code></p><p>   返回在给定的有序集合中给定成员的排名。</p></li><li><p><code>ZUNIONSTORE destination number-of-keys sorted-set1 [sorted-set2 ...] [WEIGHTS weight1 [weight2 ...]] [AGGREGATE SUM|MIN|MAX]</code></p><p>   聚合sorted sets集合，然后作为一个新的sorted set存储。可选择地，你可以为每一个set指定 weight，并且只需聚合函数：sum（默认）,maximum scores, 或者 minimum scores。</p></li><li><p><code>EXISTS key</code></p><p>   检查key是否存在。如果key存在则返回1；否则返回0.</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> Redis Cookbook </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一天一算法之java实现</title>
      <link href="2014/11/26/2014-11-26-Java-Implement-One-Algorithm-by-Day/"/>
      <url>2014/11/26/2014-11-26-Java-Implement-One-Algorithm-by-Day/</url>
      
        <content type="html"><![CDATA[<p>说明：算法背景和解法来自<a href="https://github.com/ketao1989/The-Art-Of-Programming-By-July.git">https://github.com/ketao1989/The-Art-Of-Programming-By-July.git</a>,如有版权问题，请留言告知！</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>最近看博客，发现一些有趣的算法，很久没接触，都不清楚了。这里，把上述的github中一些算法用java实现。</p><h2 id="旋转字符串"><a href="#旋转字符串" class="headerlink" title="旋转字符串"></a><a id="RotateString">旋转字符串</a></h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcddg”前面的2个字符’a’和’b’移动到字符串的尾部，使得原字符串变成字符串“cdcgab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。</p><h3 id="Java-代码"><a href="#Java-代码" class="headerlink" title="Java 代码"></a>Java 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: RotateString.java</span></span><br><span class="line"><span class="comment">&gt; Author: ketao</span></span><br><span class="line"><span class="comment">&gt; Mail: ketao1989@gmail.com</span></span><br><span class="line"><span class="comment">&gt; Created Time: 2014年11月26日 星期三 16时33分28秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateString</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把一个字符数组，按照指定位置移动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotateString</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> n,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        reverseString(str,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">        reverseString(str,n,len-<span class="number">1</span>);</span><br><span class="line">        reverseString(str,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *反转指定区间的字符数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(from &lt; to)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = str[from];</span><br><span class="line">            str[from++] = str[to];</span><br><span class="line">            str[to--] = ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *测试代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">        rotateString(str,<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="字符包含"><a href="#字符包含" class="headerlink" title="字符包含"></a><a id="StringContain">字符包含</a></h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？简单起见，暂不考虑非字符符号。</p><h3 id="Java-代码-1"><a href="#Java-代码-1" class="headerlink" title="Java 代码"></a>Java 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: StringContain.java</span></span><br><span class="line"><span class="comment">&gt; Author: ketao</span></span><br><span class="line"><span class="comment">&gt; Mail: ketao1989@gmail.com</span></span><br><span class="line"><span class="comment">&gt; Created Time: 2014年11月26日 星期三 21时16分42秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringContain</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContainString</span><span class="params">(String longger,String shortter)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//26*2个字符，使用long就可以了</span></span><br><span class="line">        <span class="keyword">long</span> hash = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;longger.length();i++)&#123;</span><br><span class="line">            hash |= (<span class="number">1L</span> &lt;&lt; computeLetterBit(longger.charAt(i)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;shortter.length();i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果&amp;操作为0，表示该位对应的字符，longger没有包含</span></span><br><span class="line">            <span class="keyword">if</span>((hash &amp; (<span class="number">1L</span> &lt;&lt; computeLetterBit(shortter.charAt(i)))) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeLetterBit</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (ch-<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ch &gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (ch-<span class="string">&#x27;a&#x27;</span>+<span class="number">26</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;参数错误！非法字符！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String a = <span class="string">&quot;AcBbDg&quot;</span>;</span><br><span class="line">        String b = <span class="string">&quot;AcD&quot;</span>;</span><br><span class="line">        String c = <span class="string">&quot;DdD&quot;</span>;</span><br><span class="line">        String d =<span class="string">&quot;*AcN&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isContainString(a,b))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a 包含b所有的字符！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a 不包含b所有的字符！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isContainString(a,c))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a 包含c所有的字符！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a 不包含c所有的字符！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isContainString(a,d))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a 包含d所有的字符！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="回文判断"><a href="#回文判断" class="headerlink" title="回文判断"></a><a id="PalindromeString">回文判断</a></h2><h3 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h3><p>回文，英文palindrome，指一个顺着读和反过来读都一样的字符串，比如madam、我爱我，这样的短句在智力性、趣味性和艺术性上都颇有特色，中国历史上还有很多有趣的回文诗。</p><p>那么，我们的第一个问题就是：判断一个字串是否是回文？</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: PalindromeString.java</span></span><br><span class="line"><span class="comment">    &gt; Author: ketao</span></span><br><span class="line"><span class="comment">    &gt; Mail: ketao1989@gmail.com</span></span><br><span class="line"><span class="comment">    &gt; Created Time: 2014年11月27日 星期四 17时03分52秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromeString</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span>[] palindromeString,<span class="keyword">final</span> <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( <span class="keyword">null</span>  == palindromeString || len &lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> middle = middlePos(len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> before = middle -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> behind = (len % <span class="number">2</span> == <span class="number">0</span>) ? middle : (middle + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(before &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(palindromeString[before]+<span class="string">&quot;----&quot;</span>+palindromeString[behind]);</span><br><span class="line">            <span class="keyword">if</span>(palindromeString[before--] != palindromeString[behind++])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">middlePos</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> num )</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> middle = (num &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> middle &gt; <span class="number">0</span> ? middle : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;P</span><br><span class="line">        <span class="keyword">char</span>[] palindromeString1 = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] palindromeString2 = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isPalindrome(palindromeString1,<span class="number">6</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;palindromeString1 is PalindromeString&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;palindromeString1 is not PalindromeString&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isPalindrome(palindromeString2,<span class="number">5</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;palindromeString2 is PalindromeString&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;palindromeString2 is not PalindromeString&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a id="LongestPalindromeSubString">最长回文子串</a></h2><h3 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h3><p>上一小节已经介绍了回文字符串，不再做介绍。最长回文子串，就是：给定一个字符串，求它的最长回文串的长度，并且把这个回文子串打印出来。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>由于查找最长回文子串问题的解决方法有很多种，而最快捷高效的算法，理解起来比较复杂，这里介绍一下，所谓的时间空间复杂度都是O(N)的<code>Manacher</code>算法.</p><ul><li><code>Manacher</code>算法，首先会初始化处理字符串。在上一节的时候我们会需要针对奇数偶数不同情况来不同处理，但是如果按照<code>Manacher</code>算法的初始化规则，就可以统一为奇数一种情况来处理，方便快捷。</li></ul><p>初始化规则就是：在字符串中每个字符前后都是用<code>#</code>来分隔，包括开头和结尾；然后再新字符串的前后分别添加<code>$</code>和<code>^</code>符号标识字符串开始和结束。例如给定一个字符串<code>abcdcda</code>，初始化处理之后为<code>$#a#b#c#d#c#d#a#^</code></p><ul><li>接下来，就需要对每一个字符分别计算它对应的最大回文子串长度(包括字符本身)，例如，<table>  <tr>      <td>S[i]</td>      <td>`$#a#b#c#d#c#d#a#^`</td>  </tr>  <tr>      <td>P[i]</td>      <td>`01212121414121210`</td>  </tr></table></li></ul><p>这样子计算的P[i]对应的值和初始化前字符的回文长度关系是：<code>old[i] = P[i]-1</code>.</p><p>*重点来了，如果分别计算每一个长度，那么其实效率并不高，那么有没有什么特征能快速计算每个字符对应的最长回文长度呢？<code>Manacher</code>算法告诉我们是有的。</p><p>假设：id是当前求得的最长回文子串中心的位置，mx为当前最长回文子串的右边界（回文子串不包括该右边界），即mx = id + P[id]。记j = id - (i-id) = 2*id – i ，即 j 是 i 关于 id 的对称点。</p><ol><li>当i <code>&lt;</code> mx 时；存在一个非常神奇的结论P[i] &gt;= min(P[2*id - i], mx - i)，证明略。</li><li>当i &gt;= mx, 无法对P[i]做更多的假设，只能P[i] = 1,然后按照原始方法再去匹配计算长度。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java一些小Tips</title>
      <link href="2014/11/24/2014-11-24-java-some-tips/"/>
      <url>2014/11/24/2014-11-24-java-some-tips/</url>
      
        <content type="html"><![CDATA[<p>插播广告：ubuntu系统的sublime text 3 中文无法输入，需要修复一些so库。参考：<a href="http://jingyan.baidu.com/article/f3ad7d0ff8731609c3345b3b.html">http://jingyan.baidu.com/article/f3ad7d0ff8731609c3345b3b.html</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>虽然java开发已经快两年了，但是对于java内部一些小的技巧和坑还是会有些不了解。这里记录下。</p><h2 id="java-Integer并发问题"><a href="#java-Integer并发问题" class="headerlink" title="java Integer并发问题"></a><a id="Integer">java Integer并发问题</a></h2><p>前段时间看书，顺带提到说<code>Integer.valueOf( )会导致死锁问题</code>很是惊讶。于是，查看了JDK源码，果然如此。</p><p>JDK代码对把-128 到127 之间的整数转换成<code>Integer</code>的时候，并不会new一个新的Integer对象，而是从 内部的<code>IntegerCache</code>中直接获取已经创建好的对象（第一次调用时会创建这个<code>IntegerCache</code>）。</p><blockquote><p>由于内部<code>IntegerCache</code>共用，所以在不同的地方对同一个数值调用<code>valueOf</code>获取cache中同一个对象，这样很可能会导致死锁。此外，关于整数范围可以使用VM初始设置（-XX:AutoBoxCacheMax=<size>，但是不能比127小）</p></blockquote><h3 id="valueOf方法实现代码"><a href="#valueOf方法实现代码" class="headerlink" title="valueOf方法实现代码"></a>valueOf方法实现代码</h3><p><code>valueOf</code>方法实际上就是调用<code>IntegerCache</code>获取对应下标的对象，而<code>IntegerCache</code>实际上就是一个Integer对象数组。关于<code>IntegerCache</code>实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];<span class="comment">//大小为正负两边总的数量</span></span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>之所以会导致死锁，主要原因是因为当两个线程不断的调用valueOf时，比如一个为 <code>Integer a=Integer.valueOf(10) + Integer.valueOf(20)</code>，另外一个线程调用<code>Integer b= Integer.valueOf(20) +Integer.valueOf(10)</code>，while中不停的调用，就可能出现死锁异常。</p></blockquote><span id="more"></span><h2 id="String-可变性方法"><a href="#String-可变性方法" class="headerlink" title="String 可变性方法"></a><a id="StringChange">String 可变性方法</a></h2><h3 id="String属性"><a href="#String属性" class="headerlink" title="String属性"></a>String属性</h3><p>在一般的代码逻辑中，String 显然是不可以改变的，其实际上是一个final属性的值类型。也就是说，我们申明一个变量为String 常量，只要不替换变量的String引用，其具体字符串内容是不会改变的。但是，一个有趣的方法可以改变这些。</p><p>###改变String 值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: StringChange.java</span></span><br><span class="line"><span class="comment">    &gt; Author: ketao1989</span></span><br><span class="line"><span class="comment">    &gt; Mail: ketao1989@gmail.com</span></span><br><span class="line"><span class="comment">    &gt; Created Time: 2014年12月10日 星期三 20时48分37秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringChange</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Field valueField;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueField = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (valueField != <span class="keyword">null</span>) &#123;</span><br><span class="line">                valueField.setAccessible(<span class="keyword">true</span>);                                                            </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// (1)</span></span><br><span class="line">            valueField.set(<span class="string">&quot;Immutable String&quot;</span>, <span class="string">&quot;Change Now！&quot;</span>.toCharArray()); </span><br><span class="line">                                                </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">                                    </span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Immutable String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Note: 其实就是一个反射特性的有趣应用。其内部运行流程为：当运行(1)的时候，应用会去String池中寻找该字符串常量对应的引用，如果没有则新建一个，并且会把引用对应的值更改为新设置的值<code>Change Now！</code>。</p><p>然后在程序运行main的时候，会去String池中寻找<code>Immutable String</code>对应的引用，但是这个引用内部的值以及被更改为<code>Change Now！</code>，所以打印的时候就会输出<code>Change Now！</code>.</p></blockquote><h2 id="volatile-非线程安全性"><a href="#volatile-非线程安全性" class="headerlink" title="volatile 非线程安全性"></a><a id="VolatileUnsafe">volatile 非线程安全性</a></h2><h3 id="volatile-属性"><a href="#volatile-属性" class="headerlink" title="volatile 属性"></a>volatile 属性</h3><p><code>volatile</code> 在java中是一种力度比较轻的synchronized，使用简单，相应编码也比较少；显然，其对应的同步功能也会比synchronized少一部分。</p><p>在一般地代码使用过程中，经常会存在一些错误的使用方法，由于涉及多线程的方面的使用，有时候测试不严谨，就会存在一些线上不易发现的错误数据。</p><p><code>volatile</code>变量保证的是，定义属性字段在java内存模型中数据一致性，也就是说，当其他线程操作更新了该属性字段，所有读取该属性字段的线程都会去全局内存上去获取最新值。关于内存模型一致性参考下面这张图就可以明白了，文章可以看看改图对应的博文：<a href="http://www.infoq.com/cn/articles/java-memory-model-1">深入理解Java内存模型</a></p><img src="/images/2014/11/jmm.png" /><h3 id="volatile-非线程安全"><a href="#volatile-非线程安全" class="headerlink" title="volatile 非线程安全"></a>volatile 非线程安全</h3><p>虽然，<code>volatile</code>虽然保证内存一致性，但是并不是线程安全的，这两个特性是不对应的。下面给出一个代码说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ketao Date: 14/12/14 Time: 下午8:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: \$Id$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> COUNT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    stopSecond(<span class="number">1</span>);</span><br><span class="line">                    COUNT += <span class="number">100</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stopSecond(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;100 times increase sum is :&quot;</span> + COUNT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stopSecond</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(a * <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码写的很简单，但是足以说明 <code>volatile</code>确实是无法保证线程安全性的。</p><p><code>volatile</code>确实可以保证线程变量内存一致性，但是对于上述这种多线程对变量更新操作的问题是无法保证的。在代码执行的时候，每个线程启动有先后，但是在sleep的时候，很多线程都取得了最新的值，这些值计算完了之后会写入内存，但是这个时候如果变量值改变了，线程并不知道，因为<code>volatile</code>只能保证读变量时是内存中最新的值，写的时候写入共享内存中；但是无法保证写入的时候去判断先前获取的值是否还是计算完之后还是最新的，因此也就无法保证线程安全性。</p><p>综上所述，<code>volatile</code>是无法保证线程安全性的；如果有这种需求，请使用<code>AtomicXxx</code>或者<code>synchronized</code>属性来实现。</p><p>此外，关于<code>volatile</code>变量一些优点和使用技巧，请参考IBM计数博客：<a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html">Java 理论与实践: 正确使用 Volatile 变量</a></p><h2 id="Math-abs-可能返回负数"><a href="#Math-abs-可能返回负数" class="headerlink" title="Math.abs 可能返回负数"></a><a id="MathAbs">Math.abs 可能返回负数</a></h2><p>在有些应用场景下，我们需要对数值进行绝对值操作，保证是正数返回，一般我们都是使用<code>Math.abs()</code>函数来完成。但是，在使用kafka进行分区自定义的时候，我们实现是对key进行hash操作，然后对当前分区取mod，由于要求返回的分区必须是整数，所以hash后特别进行了abs操作，结果竟然发现还有负值出现。</p><p>然后，Google发现，abs在某种情况下，竟然会返回负值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the absolute value of an &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment"> * If the argument is not negative, the argument is returned.</span></span><br><span class="line"><span class="comment"> * If the argument is negative, the negation of the argument is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that if the argument is equal to the value of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Integer#MIN_VALUE&#125;, the most negative representable</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125; value, the result is that same value, which is</span></span><br><span class="line"><span class="comment"> * negative.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   a   the argument whose absolute value is to be determined</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the absolute value of the argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &lt; <span class="number">0</span>) ? -a : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的jdk源码注释中，可以看出，当 a的值为<code>Integer#MIN_VALUE</code>时，返回原值。原因是因为 int 值的范围是 <code>-2^31 ~ 2^31-1</code>，也就是说最小的负数，没有对应的正整数，所以jdk实现中只有原样返回了。</p><p>实现中，由于 <code>Integer#MIN_VALUE</code> 二进制表示为 <code>10000000000000000000000000000000</code>，取负数之后，还是<code>10000000000000000000000000000000</code>,所以，原值返回了。</p><p>如果有兴趣，你可以写个小代码测试下。^_^</p><h2 id="java-向上取证"><a href="#java-向上取证" class="headerlink" title="java 向上取证"></a><a id="IntMath">java 向上取证</a></h2><p>在开发的时候，经常有<code>对两个整数向上取整</code>，一般我们都会把问题收缩到两个正整数取整，下来来看下<code>Guava</code>的时候吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q, RoundingMode mode)</span> </span>&#123;</span><br><span class="line">    checkNotNull(mode);</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">&quot;/ by zero&quot;</span>); <span class="comment">// for GWT</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> div = p / q;</span><br><span class="line">    <span class="keyword">int</span> rem = p - q * div; <span class="comment">// equal to p % q</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rem == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> div;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * signum 如果p,q都是整数或者负数的时候，这个值为1, and -1 otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> signum = <span class="number">1</span> | ((p ^ q) &gt;&gt; (Integer.SIZE - <span class="number">1</span>));<span class="comment">// 根据pq来看两个正负属性</span></span><br><span class="line">    <span class="keyword">boolean</span> increment;</span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">      <span class="keyword">case</span> UNNECESSARY:</span><br><span class="line">        checkRoundingUnnecessary(rem == <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// fall through</span></span><br><span class="line">      <span class="keyword">case</span> DOWN:</span><br><span class="line">        increment = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> UP:</span><br><span class="line">        increment = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CEILING:</span><br><span class="line">        increment = signum &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLOOR:</span><br><span class="line">        increment = signum &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> HALF_EVEN:</span><br><span class="line">      <span class="keyword">case</span> HALF_DOWN:</span><br><span class="line">      <span class="keyword">case</span> HALF_UP:</span><br><span class="line">        <span class="keyword">int</span> absRem = abs(rem);</span><br><span class="line">        <span class="keyword">int</span> cmpRemToHalfDivisor = absRem - (abs(q) - absRem);</span><br><span class="line">        <span class="comment">// subtracting two nonnegative ints can&#x27;t overflow</span></span><br><span class="line">        <span class="comment">// cmpRemToHalfDivisor has the same sign as compare(abs(rem), abs(q) / 2).</span></span><br><span class="line">        <span class="keyword">if</span> (cmpRemToHalfDivisor == <span class="number">0</span>) &#123; <span class="comment">// exactly on the half mark</span></span><br><span class="line">          increment = (mode == HALF_UP || (mode == HALF_EVEN &amp; (div &amp; <span class="number">1</span>) != <span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          increment = cmpRemToHalfDivisor &gt; <span class="number">0</span>; <span class="comment">// closer to the UP value</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> increment ? div + signum : div;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现参考guava的这个类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RoundingMode</span> </span>&#123;</span><br><span class="line">    UP(BigDecimal.ROUND_UP),</span><br><span class="line">    DOWN(BigDecimal.ROUND_DOWN),</span><br><span class="line">    CEILING(BigDecimal.ROUND_CEILING),</span><br><span class="line">    FLOOR(BigDecimal.ROUND_FLOOR),</span><br><span class="line">    HALF_UP(BigDecimal.ROUND_HALF_UP),</span><br><span class="line">    HALF_DOWN(BigDecimal.ROUND_HALF_DOWN),</span><br><span class="line">    HALF_EVEN(BigDecimal.ROUND_HALF_EVEN),</span><br><span class="line">    UNNECESSARY(BigDecimal.ROUND_UNNECESSARY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo provider 多组名注册问题分析</title>
      <link href="2014/10/22/2014-10-22-Dubbo-Provider-Groups-Bug-Analyse/"/>
      <url>2014/10/22/2014-10-22-Dubbo-Provider-Groups-Bug-Analyse/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>最近线上遇到一个很奇怪的现象，就是一个dubbo 服务被注册到了好几个<code>group</code>下面，并且这些<code>group</code>都是我们应用中，通过<code>dubbo:registry</code>来配置的。但是，显然这不是我们应用所期待的结果，因此，首先，我们需要修复这个问题；其次，我们需要找出原因。</p><h3 id="1-1-问题定位"><a href="#1-1-问题定位" class="headerlink" title="1.1 问题定位"></a>1.1 问题定位</h3><p>首先看配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;crm-message-registry&quot;</span> <span class="attr">group</span>=<span class="string">&quot;crm-message&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">address</span>=<span class="string">&quot;$&#123;qunar-public.zookeeper.address&#125;&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;$&#123;dubbo.protocol&#125; &quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.qxx.scm.message.api.IPushMessageBiz&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">ref</span>=<span class="string">&quot;pushMessageBiz&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;6000&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.1&quot;</span> /&gt;</span></span><br><span class="line">                   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>从上面的配置可以看到，我们实际上是有<code>dubbo:registry</code>，并且在其中也设置了<code>group</code>属性。</p><span id="more"></span><p>接下来，拿该xml配置和以前的 <code>dubbo provider</code>的配置进行比较，发现在<code>dubbo:service</code>的属性配置里面，缺少了指定<code>registry</code>的配置，猜想应该是该配置的缺失，导致应用把该<code>service</code>对应的服务，注册到了多个group下面。因此，为了正式推测，更改配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;crm-message-registry&quot;</span> <span class="attr">group</span>=<span class="string">&quot;crm-message&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">address</span>=<span class="string">&quot;$&#123;qxx-public.zookeeper.address&#125;&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;$&#123;dubbo.protocol&#125; &quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.qxx.scm.message.api.IPushMessageBiz&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">ref</span>=<span class="string">&quot;pushMessageBiz&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;6000&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.1&quot;</span> <span class="attr">registry</span>=<span class="string">&quot;crm-message-registry&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>启动应用，发现果然问题解决了。</p><h3 id="1-2-问题产生原因"><a href="#1-2-问题产生原因" class="headerlink" title="1.2 问题产生原因"></a>1.2 问题产生原因</h3><p>在<code>dubbo:service</code>没有明确设置<code>registry</code>，不会导致启动失败，或者注册不上，而是会在应用配置中声明的所有组名下面注册对应服务。于是，去dubbo的github：<a href="http://alibaba.github.io/dubbo-doc-static/Developer+Guide-zh.htm">http://alibaba.github.io/dubbo-doc-static/Developer+Guide-zh.htm</a>  上去看看wiki有木有说明。关于注册说明，如：<a href="http://alibaba.github.io/dubbo-doc-static/RegistryFactory+SPI-zh.htm">http://alibaba.github.io/dubbo-doc-static/RegistryFactory+SPI-zh.htm</a>.</p><p>其中，文档关于配置说明如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;xxx1&quot;</span> <span class="attr">address</span>=<span class="string">&quot;xxx://ip:port&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 定义注册中心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">registry</span>=<span class="string">&quot;xxx1&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 引用注册中心，如果没有配置registry属性，将在ApplicationContext中自动扫描registry配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">registry</span>=<span class="string">&quot;xxx1&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 引用注册中心缺省值，当&lt;dubbo:service&gt;没有配置registry属性时，使用此配置 --&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ok，到这里就明白了，<code>dubbo</code>在我们配置<code>&lt;dubbo:service&gt;</code>中没有指定registry时，会看看对应的<code>&lt;dubbo:provider&gt;</code>有木有配置<code>registry</code>,如果没有，则<em>在ApplicationContext中自动扫描registry配置</em>获取注册中心列表，然后进行注册。</p><h2 id="dubbo注册分析"><a href="#dubbo注册分析" class="headerlink" title="dubbo注册分析"></a><a id="Registry">dubbo注册分析</a></h2><p><code>dubbo</code>是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。当然，作为一个优秀的RPC框架，其涉及到服务注册和服务事件的订阅及发布。</p><h3 id="2-1-dubbo配置解析"><a href="#2-1-dubbo配置解析" class="headerlink" title="2.1 dubbo配置解析"></a>2.1 dubbo配置解析</h3><p>在Spring 中使用dubbo，会采用xml方式对dubbo相关属性进行配置，其加入了自己的命名空间，如<code>xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</code>，因此，你会知道必然存在一个继承实现<code>org.springframework.beans.factory.xml.NamespaceHandlerSupport</code>来完成自定义配置的解析工作，部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;application&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;registry&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;provider&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;consumer&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;protocol&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;service&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;reference&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean.class, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到<code>RegistryConfig.class</code>类，包含关于<code>注册中心</code>相关的属性变量配置；<code>ServiceBean.class</code>类，包含关于<code>对外服务</code>相关的属性变量配置。也就是说，通过<code>DubboBeanDefinitionParser</code>解析器会把对应xml节点解析成对应的对象实例。</p><p>Spring的自定义标签代码实现和内部原理，可以google一下。</p><blockquote><p>说明：<code>DubboNamespaceHandler</code>在初始化的时候，会把所有，针对不同xml节点的对应解析其注册到Spring <code>NamespaceHandlerSupport</code>的 <code>BeanDefinitionParser</code> Map上来。这样，在Spring 初始化解析xml配置时，就可以完成对自定义标签的兼容和实例化了。</p></blockquote><p>对于Dubbo 自定义解析器<code>DubboBeanDefinitionParser</code>的说明，如<a href="#End">附录</a>所示。</p><h3 id="2-2-dubbo注册解析"><a href="#2-2-dubbo注册解析" class="headerlink" title="2.2 dubbo注册解析"></a>2.2 dubbo注册解析</h3><p>阿里的dubbo提供了多种注册机制，比如：<code>Redis</code>注册中心，<code>ZooKeeper</code>注册中心，或者使用<code>广播</code>的方式等。而目前使用的比较多的是使用<code>ZookeeperRegistry</code>方式。</p><p>从代码结构可以看出，对于不同的注册机制，其主要流程还是一样的，只是在注册url的具体操作中，需要根据不同的部署实体来采用不同的注册操作。比如，对于<code>zookeeper</code>，则使用<code>zkclient</code>去连接zk注册中心；而对于<code>redis</code>，则直接使用<code>redis.clients.jedis.Jedis</code>在数据库上注册保持对应url。</p><p>在抽象类的<code>AbstractRegistryFactory</code>中，提供了连接注册中心的一些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 注册中心集合 Map&lt;RegistryAddress, Registry&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Registry&gt; REGISTRIES = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Registry&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有注册中心</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 所有注册中心</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Registry&gt; <span class="title">getRegistries</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里获取应用中配置的所有注册中心，如果dubbo:service里面没有配置registry属性时，应该会调用这个方法</span></span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableCollection(REGISTRIES.values());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接注册中心</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url 注册中心地址，不允许为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Registry <span class="title">getRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">url = url.setPath(RegistryService.class.getName())</span><br><span class="line">.addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())</span><br><span class="line">.removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);</span><br><span class="line">String key = url.toServiceString();</span><br><span class="line">    <span class="comment">// 锁定注册中心获取过程，保证注册中心单一实例</span></span><br><span class="line">    LOCK.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Registry registry = REGISTRIES.get(key);</span><br><span class="line">        <span class="keyword">if</span> (registry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> registry;</span><br><span class="line">        &#125;</span><br><span class="line">        registry = createRegistry(url);</span><br><span class="line">        <span class="keyword">if</span> (registry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Can not create registry &quot;</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里会把本应用所有不同的成功连接的注册配置放在全局concurrentMap中</span></span><br><span class="line">        REGISTRIES.put(key, registry);</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        LOCK.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Note：在Factory中会创建Registery对象，该对象中，会实现注册，取消注册，订阅，取消订阅等方法来提供给<code>service</code>和<code>reference</code>完成需要的注册和订阅服务。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册数据，比如：提供者地址，消费者地址，路由规则，覆盖规则，等数据。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 注册需处理契约：&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 1. 当URL设置了check=false时，注册失败后不报错，在后台定时重试，否则抛出异常。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 2. 当URL设置了dynamic=false参数，则需持久存储，否则，当注册者出现断电等情况异常退出时，需自动删除。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 3. 当URL设置了category=routers时，表示分类存储，缺省类别为providers，可按分类部分通知数据。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 4. 当注册中心重启，网络抖动，不能丢失数据，包括断线自动删除数据。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 5. 允许URI相同但参数不同的URL并存，不能覆盖。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 注册信息，不允许为空，如：dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消注册.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 取消注册需处理契约：&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 1. 如果是dynamic=false的持久存储数据，找不到注册数据，则抛IllegalStateException，否则忽略。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 2. 按全URL匹配取消注册。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 注册信息，不允许为空，如：dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅符合条件的已注册数据，当有注册数据变更时自动推送.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 订阅需处理契约：&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 1. 当URL设置了check=false时，订阅失败后不报错，在后台定时重试。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 2. 当URL设置了category=routers，只通知指定分类的数据，多个分类用逗号分隔，并允许星号通配，表示订阅所有分类数据。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 3. 允许以interface,group,version,classifier作为条件查询，如：interface=com.alibaba.foo.BarService&amp;version=1.0.0&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 4. 并且查询条件允许星号通配，订阅所有接口的所有分组的所有版本，或：interface=*&amp;group=*&amp;version=*&amp;classifier=*&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 5. 当注册中心重启，网络抖动，需自动恢复订阅请求。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 6. 允许URI相同但参数不同的URL并存，不能覆盖。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 7. 必须阻塞订阅过程，等第一次通知完后再返回。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 订阅条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 变更事件监听器，不允许为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消订阅.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 取消订阅需处理契约：&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 1. 如果没有订阅，直接忽略。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 2. 按全URL匹配取消订阅。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 订阅条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 变更事件监听器，不允许为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询符合条件的已注册数据，与订阅的推模式相对应，这里为拉模式，只返回一次结果。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.registry.NotifyListener#notify(List)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 查询条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 已注册信息列表，可能为空，含义同&#123;<span class="doctag">@link</span> com.alibaba.dubbo.registry.NotifyListener#notify(List&lt;URL&gt;)&#125;的参数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;URL&gt; <span class="title">lookup</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="dubbo服务分析"><a href="#dubbo服务分析" class="headerlink" title="dubbo服务分析"></a><a id="Service">dubbo服务分析</a></h2><p>从上面的解析配置文件，可以看到对于<code>&lt;dubbo:service&gt;</code>的解析，是使用<code>serviceBean</code>类来实现的。在<code>serviceConfig</code>（serviceBean的父类）类中对于service需要的一些属性进行说明，但是对于一些必须的属性没有设置会怎么样呢？！dubbo，首先会去上下文中，通过查找构造出对应的属性；当然如果构造不了，则返回null，这样在后期的时候就会抛出异常。</p><h3 id="3-1-dubbo服务配置处理分析"><a href="#3-1-dubbo服务配置处理分析" class="headerlink" title="3.1 dubbo服务配置处理分析"></a>3.1 dubbo服务配置处理分析</h3><p>对于一些容错处理，也就是未配置的自动完善的方法，在<code>serviceBean</code>中完成。部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用事件监听器ApplicationListener的接口方法，用来对监听到的事件进行处理。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 显然的观察者设计模式。事件驱动。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ContextRefreshedEvent.class.getName().equals(event.getClass().getName())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;The service ready on spring started. service: &quot;</span> + getInterface());</span><br><span class="line">                &#125;</span><br><span class="line">                export();<span class="comment">// 暴露服务</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法很重要！</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里会构造 服务提供方相关的服务设置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;deprecation&quot; &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在dubbo:service中没有配置Provider属性</span></span><br><span class="line">        <span class="keyword">if</span> (getProvider() == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从applicationContext中构造ProviderConfig类对象</span></span><br><span class="line">            Map&lt;String, ProviderConfig&gt; providerConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils</span><br><span class="line">                    .beansOfTypeIncludingAncestors(applicationContext, ProviderConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (providerConfigMap != <span class="keyword">null</span> &amp;&amp; providerConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 从applicationContext中构造ProtocolConfig类对象</span></span><br><span class="line">                Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils</span><br><span class="line">                        .beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取应用上下文中的所有providerConfig，然后保存到对应的service服务的protocol中</span></span><br><span class="line">                <span class="keyword">if</span> ((protocolConfigMap == <span class="keyword">null</span> || protocolConfigMap.size() == <span class="number">0</span>) &amp;&amp; providerConfigMap.size() &gt; <span class="number">1</span>) &#123; <span class="comment">// 兼容旧版本</span></span><br><span class="line">                    List&lt;ProviderConfig&gt; providerConfigs = <span class="keyword">new</span> ArrayList&lt;ProviderConfig&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() != <span class="keyword">null</span> &amp;&amp; config.isDefault().booleanValue()) &#123;</span><br><span class="line">                            providerConfigs.add(config);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (providerConfigs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        setProviders(providerConfigs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ProviderConfig providerConfig = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 难以详细这个逻辑，for多次竟然只set一个变量，多个则又抛异常</span></span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;<span class="comment">// 缺省状态，多次设置，则抛异常？？</span></span><br><span class="line">                            <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Duplicate provider configs: &quot;</span> + providerConfig</span><br><span class="line">                                        + <span class="string">&quot; and &quot;</span> + config);</span><br><span class="line">                            &#125;</span><br><span class="line">                            providerConfig = config;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        setProvider(providerConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对Application为空进行判断，并且只有provider为空或者provider的application为空，才会从应用的上下文去构造</span></span><br><span class="line">        <span class="keyword">if</span> (getApplication() == <span class="keyword">null</span> &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getApplication() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils</span><br><span class="line">                    .beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (applicationConfigMap != <span class="keyword">null</span> &amp;&amp; applicationConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ApplicationConfig applicationConfig = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (ApplicationConfig config : applicationConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Duplicate application configs: &quot;</span> + applicationConfig</span><br><span class="line">                                    + <span class="string">&quot; and &quot;</span> + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        applicationConfig = config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    setApplication(applicationConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getModule() == <span class="keyword">null</span> &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getModule() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils</span><br><span class="line">                    .beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (moduleConfigMap != <span class="keyword">null</span> &amp;&amp; moduleConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ModuleConfig moduleConfig = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (ModuleConfig config : moduleConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Duplicate module configs: &quot;</span> + moduleConfig + <span class="string">&quot; and &quot;</span></span><br><span class="line">                                    + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        moduleConfig = config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    setModule(moduleConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ok,这里就是注册中心的配置处理，对于service中没有配置registry属性的，dubbo会自己来完善</span></span><br><span class="line">        <span class="comment">// 还记得上面的dubbo wiki文档的说明吗？会查看provider是否配置了registry，如果没有才会调用全局应用上下文的配置。</span></span><br><span class="line">        <span class="comment">// 所以这里，会首先判断service是否配置registry，然后判断provider是否配置，然后在判断application是否配置registry，</span></span><br><span class="line">        <span class="comment">// 然后才会从applicationContext中获取已经在spring 中注册了的registry列表，作为本service的配置。</span></span><br><span class="line">        <span class="keyword">if</span> ((getRegistries() == <span class="keyword">null</span> || getRegistries().size() == <span class="number">0</span>)</span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getRegistries() == <span class="keyword">null</span> || getProvider().getRegistries()</span><br><span class="line">                        .size() == <span class="number">0</span>)</span><br><span class="line">                &amp;&amp; (getApplication() == <span class="keyword">null</span> || getApplication().getRegistries() == <span class="keyword">null</span> || getApplication()</span><br><span class="line">                        .getRegistries().size() == <span class="number">0</span>)) &#123;</span><br><span class="line">            Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils</span><br><span class="line">                    .beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (registryConfigMap != <span class="keyword">null</span> &amp;&amp; registryConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                List&lt;RegistryConfig&gt; registryConfigs = <span class="keyword">new</span> ArrayList&lt;RegistryConfig&gt;();</span><br><span class="line">                <span class="keyword">for</span> (RegistryConfig config : registryConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        registryConfigs.add(config);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里设置到了注册中心配置中，list哦。</span></span><br><span class="line">                <span class="keyword">if</span> (registryConfigs != <span class="keyword">null</span> &amp;&amp; registryConfigs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">super</span>.setRegistries(registryConfigs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ....................</span></span><br><span class="line">        </span><br><span class="line">         <span class="keyword">if</span> (!isDelay()) &#123;</span><br><span class="line">            <span class="comment">// 不延迟，可以开始暴露服务了</span></span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体，dubbo怎么把服务暴露出去，消费者怎样通过dubbo rpc调用服务等，不在本文所描述之内。后续会单独进行分析说明。</p><h3 id="3-2-问题原因解析"><a href="#3-2-问题原因解析" class="headerlink" title="3.2 问题原因解析"></a>3.2 问题原因解析</h3><p>从上面的代码逻辑，可以明白之所以出现多组注册的问题原因了。</p><p>回到代码中，在配置的dubbo xml文件里面，有三个不同的节点，<code>&lt;dubbo:registry&gt;</code>，<code>&lt;dubbo:protocol&gt;</code>和<code>&lt;dubbo:service&gt;</code>。由于<code>&lt;dubbo:service&gt;</code>中没有配置<code>registry</code>属性，所以按照dubbo的逻辑，会先查找<code>&lt;dubbo:provider&gt;</code>节点配置，但是因为配置文件中没有配置，所以接下来会查找<code>&lt;dubbo:application&gt;</code>节点，看看该节点下面是否有配置<code>registry</code>属性，依然没有配置该节点。</p><p>这样，就走进了dubbo来配置相关registry属性的代码内部。</p><p>代码会从spring的<code>applicationContext</code>中构造出<code>Map&lt;String, RegistryConfig&gt; </code>类型变量，然后获取<code>map.values()</code>从而拿到所有在spring中已经存在上下文中的注册信息了。这样，把结果（所有注册的registry信息）放到service配置中。</p><blockquote><p>Note：那么，为什么可以获取应用上下文环境中所有的<code>RegistryConfig</code>呢？还记得解析顺序吗！？最开始就是解析注册节点的数据哦！<code>registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true));</code>早于<code>registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true));</code>，此外，判断逻辑里面，其他节点数据解析，也是早于serviceBean的。</p></blockquote><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a><a id="End">附录</a></h2><p>dubbo 关于<code>DubboBeanDefinitionParser</code> 部分核心代码的注释说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DubboBeanDefinitionParser.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; beanClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> required;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboBeanDefinitionParser</span><span class="params">(Class&lt;?&gt; beanClass, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanClass = beanClass;</span><br><span class="line">        <span class="keyword">this</span>.required = required;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parse(element, parserContext, beanClass, required);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">        RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        beanDefinition.setBeanClass(beanClass);</span><br><span class="line">        beanDefinition.setLazyInit(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 解析 id标识</span></span><br><span class="line">        String id = element.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果id标识为空，则获取name标识</span></span><br><span class="line">        <span class="keyword">if</span> ((id == <span class="keyword">null</span> || id.length() == <span class="number">0</span>) &amp;&amp; required) &#123;</span><br><span class="line">            String generatedBeanName = element.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (generatedBeanName == <span class="keyword">null</span> || generatedBeanName.length() == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果使用ProtocolConfig 为bean ，则为dubbo，配置为dubbo:protocol</span></span><br><span class="line">                <span class="keyword">if</span> (ProtocolConfig.class.equals(beanClass)) &#123;</span><br><span class="line">                    generatedBeanName = <span class="string">&quot;dubbo&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ok，这里是没有id和name标识，并且正常config bean，则使用interface的标识value值</span></span><br><span class="line">                    <span class="comment">// 比如，一般我们写dubbo:service 可能会走到这个配置上。</span></span><br><span class="line">                    generatedBeanName = element.getAttribute(<span class="string">&quot;interface&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (generatedBeanName == <span class="keyword">null</span> || generatedBeanName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                generatedBeanName = beanClass.getName();</span><br><span class="line">            &#125;</span><br><span class="line">            id = generatedBeanName;</span><br><span class="line">            <span class="keyword">int</span> counter = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 如果存在该BeanDefinition，则重置id</span></span><br><span class="line">            <span class="keyword">while</span> (parserContext.getRegistry().containsBeanDefinition(id)) &#123;</span><br><span class="line">                id = generatedBeanName + (counter++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ok，这里再次判断，检查是否重复id在bean里面</span></span><br><span class="line">        <span class="keyword">if</span> (id != <span class="keyword">null</span> &amp;&amp; id.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parserContext.getRegistry().containsBeanDefinition(id)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Duplicate spring bean id &quot;</span> + id);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册到spring 的bean Map中去，其中id为key</span></span><br><span class="line">            parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);</span><br><span class="line">            <span class="comment">// 然后把id和对应value 作为Property放入bean里面</span></span><br><span class="line">            beanDefinition.getPropertyValues().addPropertyValue(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果使用ProtocolConfig的配置类，dubbo:protocol</span></span><br><span class="line">        <span class="keyword">if</span> (ProtocolConfig.class.equals(beanClass)) &#123;</span><br><span class="line">            <span class="comment">// 拿到注册在parser环境里所有getBeanDefinitionNames，他实际上是bean map的key部分</span></span><br><span class="line">            <span class="keyword">for</span> (String name : parserContext.getRegistry().getBeanDefinitionNames()) &#123;</span><br><span class="line">                BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);</span><br><span class="line">                PropertyValue property = definition.getPropertyValues().getPropertyValue(<span class="string">&quot;protocol&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (property != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Object value = property.getValue();</span><br><span class="line">                    <span class="comment">// 如果id 为protocol</span></span><br><span class="line">                    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ProtocolConfig &amp;&amp; id.equals(((ProtocolConfig) value).getName())) &#123;</span><br><span class="line">                        definition.getPropertyValues().addPropertyValue(<span class="string">&quot;protocol&quot;</span>, <span class="keyword">new</span> RuntimeBeanReference(id));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dubbo:service 对应的配置解析</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ServiceBean.class.equals(beanClass)) &#123;</span><br><span class="line">            String className = element.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (className != <span class="keyword">null</span> &amp;&amp; className.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                RootBeanDefinition classDefinition = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">                classDefinition.setBeanClass(ReflectUtils.forName(className));</span><br><span class="line">                classDefinition.setLazyInit(<span class="keyword">false</span>);</span><br><span class="line">                parseProperties(element.getChildNodes(), classDefinition);</span><br><span class="line">                beanDefinition.getPropertyValues().addPropertyValue(<span class="string">&quot;ref&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> BeanDefinitionHolder(classDefinition, id + <span class="string">&quot;Impl&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// provider配置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ProviderConfig.class.equals(beanClass)) &#123;</span><br><span class="line">            <span class="comment">// tag:service ;property:provider;ref:id</span></span><br><span class="line">            <span class="comment">// parserContext</span></span><br><span class="line">            parseNested(element, parserContext, ServiceBean.class, <span class="keyword">true</span>, <span class="string">&quot;service&quot;</span>, <span class="string">&quot;provider&quot;</span>, id, beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// consumer配置，对于consumer，找到对应的reference 标识</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ConsumerConfig.class.equals(beanClass)) &#123;</span><br><span class="line">            parseNested(element, parserContext, ReferenceBean.class, <span class="keyword">false</span>, <span class="string">&quot;reference&quot;</span>, <span class="string">&quot;consumer&quot;</span>, id, beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ok，以上都没有，接下来，正常解析了</span></span><br><span class="line">        Set&lt;String&gt; props = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        ManagedMap parameters = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Method setter : beanClass.getMethods()) &#123;</span><br><span class="line">            String name = setter.getName();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到set方法来设置beanclass对象的值</span></span><br><span class="line">            <span class="keyword">if</span> (name.length() &gt; <span class="number">3</span> &amp;&amp; name.startsWith(<span class="string">&quot;set&quot;</span>) &amp;&amp; Modifier.isPublic(setter.getModifiers())</span><br><span class="line">                    &amp;&amp; setter.getParameterTypes().length == <span class="number">1</span>) &#123; <span class="comment">// 判断set方法</span></span><br><span class="line">                Class&lt;?&gt; type = setter.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取属性的名称，并且把名称第一个大写字母 --&gt; 小写，并且各个驼峰使用‘_’连接</span></span><br><span class="line">                String property = StringUtils.camelToSplitName(name.substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + name.substring(<span class="number">4</span>),</span><br><span class="line">                        <span class="string">&quot;-&quot;</span>);</span><br><span class="line">                props.add(property);</span><br><span class="line">                Method getter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取get或者is等取值方法</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    getter = beanClass.getMethod(<span class="string">&quot;get&quot;</span> + name.substring(<span class="number">3</span>), <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        getter = beanClass.getMethod(<span class="string">&quot;is&quot;</span> + name.substring(<span class="number">3</span>), <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoSuchMethodException e2) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果没有get等取值方法，则不放到结果中，对于处理registry的bean，需要解析各个属性参数，比如address，port，timeout等</span></span><br><span class="line">                <span class="keyword">if</span> (getter == <span class="keyword">null</span> || !Modifier.isPublic(getter.getModifiers()) || !type.equals(getter.getReturnType())) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;parameters&quot;</span>.equals(property)) &#123;</span><br><span class="line">                    parameters = parseParameters(element.getChildNodes(), beanDefinition);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;methods&quot;</span>.equals(property)) &#123;</span><br><span class="line">                    parseMethods(id, element.getChildNodes(), beanDefinition, parserContext);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;arguments&quot;</span>.equals(property)) &#123;</span><br><span class="line">                    parseArguments(id, element.getChildNodes(), beanDefinition, parserContext);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ok，来解析每个属性参数了</span></span><br><span class="line">                    String value = element.getAttribute(property);</span><br><span class="line">                    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        value = value.trim();</span><br><span class="line">                        <span class="keyword">if</span> (value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// N/A配置，则采用new 新配置对象</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="string">&quot;registry&quot;</span>.equals(property) &amp;&amp; RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) &#123;</span><br><span class="line">                                RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">                                registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);</span><br><span class="line">                                beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 多注册中心配置？？</span></span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;registry&quot;</span>.equals(property) &amp;&amp; value.indexOf(<span class="string">&#x27;,&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                parseMultiRef(<span class="string">&quot;registries&quot;</span>, value, beanDefinition, parserContext);</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;provider&quot;</span>.equals(property) &amp;&amp; value.indexOf(<span class="string">&#x27;,&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                parseMultiRef(<span class="string">&quot;providers&quot;</span>, value, beanDefinition, parserContext);</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;protocol&quot;</span>.equals(property) &amp;&amp; value.indexOf(<span class="string">&#x27;,&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                parseMultiRef(<span class="string">&quot;protocols&quot;</span>, value, beanDefinition, parserContext);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                Object reference;</span><br><span class="line">                                <span class="keyword">if</span> (isPrimitive(type)) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (<span class="string">&quot;async&quot;</span>.equals(property) &amp;&amp; <span class="string">&quot;false&quot;</span>.equals(value) || <span class="string">&quot;timeout&quot;</span>.equals(property)</span><br><span class="line">                                            &amp;&amp; <span class="string">&quot;0&quot;</span>.equals(value) || <span class="string">&quot;delay&quot;</span>.equals(property) &amp;&amp; <span class="string">&quot;0&quot;</span>.equals(value)</span><br><span class="line">                                            || <span class="string">&quot;version&quot;</span>.equals(property) &amp;&amp; <span class="string">&quot;0.0.0&quot;</span>.equals(value)</span><br><span class="line">                                            || <span class="string">&quot;stat&quot;</span>.equals(property) &amp;&amp; <span class="string">&quot;-1&quot;</span>.equals(value)</span><br><span class="line">                                            || <span class="string">&quot;reliable&quot;</span>.equals(property) &amp;&amp; <span class="string">&quot;false&quot;</span>.equals(value)) &#123;</span><br><span class="line">                                        <span class="comment">// 兼容旧版本xsd中的default值</span></span><br><span class="line">                                        value = <span class="keyword">null</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    reference = value;</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;protocol&quot;</span>.equals(property)</span><br><span class="line">                                        &amp;&amp; ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(value)</span><br><span class="line">                                        &amp;&amp; (!parserContext.getRegistry().containsBeanDefinition(value) || !ProtocolConfig.class</span><br><span class="line">                                                .getName().equals(</span><br><span class="line">                                                        parserContext.getRegistry().getBeanDefinition(value)</span><br><span class="line">                                                                .getBeanClassName()))) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (<span class="string">&quot;dubbo:provider&quot;</span>.equals(element.getTagName())) &#123;</span><br><span class="line">                                        logger.warn(<span class="string">&quot;Recommended replace &lt;dubbo:provider protocol=\&quot;&quot;</span> + value</span><br><span class="line">                                                + <span class="string">&quot;\&quot; ... /&gt; to &lt;dubbo:protocol name=\&quot;&quot;</span> + value + <span class="string">&quot;\&quot; ... /&gt;&quot;</span>);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="comment">// 兼容旧版本配置</span></span><br><span class="line">                                    ProtocolConfig protocol = <span class="keyword">new</span> ProtocolConfig();</span><br><span class="line">                                    protocol.setName(value);</span><br><span class="line">                                    reference = protocol;</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;monitor&quot;</span>.equals(property)</span><br><span class="line">                                        &amp;&amp; (!parserContext.getRegistry().containsBeanDefinition(value) || !MonitorConfig.class</span><br><span class="line">                                                .getName().equals(</span><br><span class="line">                                                        parserContext.getRegistry().getBeanDefinition(value)</span><br><span class="line">                                                                .getBeanClassName()))) &#123;</span><br><span class="line">                                    <span class="comment">// 兼容旧版本配置</span></span><br><span class="line">                                    reference = convertMonitor(value);</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;onreturn&quot;</span>.equals(property)) &#123;</span><br><span class="line">                                    <span class="keyword">int</span> index = value.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                                    String returnRef = value.substring(<span class="number">0</span>, index);</span><br><span class="line">                                    String returnMethod = value.substring(index + <span class="number">1</span>);</span><br><span class="line">                                    reference = <span class="keyword">new</span> RuntimeBeanReference(returnRef);</span><br><span class="line">                                    beanDefinition.getPropertyValues().addPropertyValue(<span class="string">&quot;onreturnMethod&quot;</span>, returnMethod);</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;onthrow&quot;</span>.equals(property)) &#123;</span><br><span class="line">                                    <span class="keyword">int</span> index = value.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                                    String throwRef = value.substring(<span class="number">0</span>, index);</span><br><span class="line">                                    String throwMethod = value.substring(index + <span class="number">1</span>);</span><br><span class="line">                                    reference = <span class="keyword">new</span> RuntimeBeanReference(throwRef);</span><br><span class="line">                                    beanDefinition.getPropertyValues().addPropertyValue(<span class="string">&quot;onthrowMethod&quot;</span>, throwMethod);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (<span class="string">&quot;ref&quot;</span>.equals(property)</span><br><span class="line">                                            &amp;&amp; parserContext.getRegistry().containsBeanDefinition(value)) &#123;</span><br><span class="line">                                        BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);</span><br><span class="line">                                        <span class="keyword">if</span> (!refBean.isSingleton()) &#123;</span><br><span class="line">                                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The exported service ref &quot;</span> + value</span><br><span class="line">                                                    + <span class="string">&quot; must be singleton! Please set the &quot;</span> + value</span><br><span class="line">                                                    + <span class="string">&quot; bean scope to singleton, eg: &lt;bean id=\&quot;&quot;</span> + value</span><br><span class="line">                                                    + <span class="string">&quot;\&quot; scope=\&quot;singleton\&quot; ...&gt;&quot;</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    reference = <span class="keyword">new</span> RuntimeBeanReference(value);</span><br><span class="line">                                &#125;</span><br><span class="line">                                beanDefinition.getPropertyValues().addPropertyValue(property, reference);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有属性</span></span><br><span class="line">        <span class="comment">// ok,现在解析每一个节点对应的属性参数，比如 address，loadbalance等</span></span><br><span class="line">        NamedNodeMap attributes = element.getAttributes();</span><br><span class="line">        <span class="keyword">int</span> len = attributes.getLength();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            Node node = attributes.item(i);</span><br><span class="line">            String name = node.getLocalName();</span><br><span class="line">            <span class="keyword">if</span> (!props.contains(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parameters == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    parameters = <span class="keyword">new</span> ManagedMap();</span><br><span class="line">                &#125;</span><br><span class="line">                String value = node.getNodeValue();</span><br><span class="line">                <span class="comment">// 整了这么多，到这里终于放进ManagedMap里面去了</span></span><br><span class="line">                parameters.put(name, <span class="keyword">new</span> TypedStringValue(value, String.class));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里放到beanDefinition属性里面，进而在Context中就可以拿到了</span></span><br><span class="line">            beanDefinition.getPropertyValues().addPropertyValue(<span class="string">&quot;parameters&quot;</span>, parameters);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//.............................</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Dubbo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线上Mysql Delete 和 Insert 操作导致死锁问题分析</title>
      <link href="2014/10/09/2014-10-09-Mysql-Delete-Insert-Deadlock-Analyse/"/>
      <url>2014/10/09/2014-10-09-Mysql-Delete-Insert-Deadlock-Analyse/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>今天项目发布，上线上跟日志的时候，发现一些死锁信息的出现，查询了一下，发现日志里面虽然死锁出现很少，但是都是同一个代码<code>sql</code>语句产生的，如下图所示：</p><img src="/images/2014/10/deadlock-log.png" /><p>并且，一天产生死锁<code>31</code>次。</p><p>从DBA那边拿到了对应死锁的<code>Mysql</code>日志信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">------------------------</span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">141009 12:54:59</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION AEE50DCB, ACTIVE 0 sec starting index <span class="built_in">read</span></span><br><span class="line">mysql tables <span class="keyword">in</span> use 1, locked 1</span><br><span class="line">LOCK WAIT 2 lock struct(s), heap size 376, 1 row lock(s)</span><br><span class="line">MySQL thread id 6055694, OS thread handle 0x7f4345c8d700, query id 2443700084 192.168.249.154 crm_w updating</span><br><span class="line">DELETE FROM crm_business WHERE serial_number = <span class="string">&#x27;CH01313320&#x27;</span></span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 244 page no 817 n bits 824 index `uniq_serial_number_business_type` of table `crm`.`crm_business` trx id AEE50DCB lock_mode X waiting</span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION AEE50DCA, ACTIVE 0 sec inserting, thread declared inside InnoDB 500</span><br><span class="line">mysql tables <span class="keyword">in</span> use 1, locked 1</span><br><span class="line">3 lock struct(s), heap size 1248, 3 row lock(s), undo <span class="built_in">log</span> entries 1</span><br><span class="line">MySQL thread id 6055696, OS thread handle 0x7f4344941700, query id 2443700084 192.168.249.154 crm_w update</span><br><span class="line">INSERT INTO crm_business(serial_number, business_type) values (<span class="string">&#x27;CH01313318&#x27;</span>, 2)</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 244 page no 817 n bits 824 index `uniq_serial_number_business_type` of table `crm`.`crm_business` trx id AEE50DCA lock mode S</span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 244 page no 817 n bits 824 index `uniq_serial_number_business_type` of table `crm`.`crm_business` trx id AEE50DCA lock_mode X locks gap before rec insert intention waiting</span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br></pre></td></tr></table></figure><blockquote><p>Note: 数据库中，<code>CH01313318</code>和<code>CH01313320</code>序列号是连着的两个记录。</p></blockquote><h2 id="死锁问题定位"><a href="#死锁问题定位" class="headerlink" title="死锁问题定位"></a><a id="Problem">死锁问题定位</a></h2><p>之所以需要分析这个问题，主要原因是，这边代码并<em>没有</em>涉及到在一个事务内部sql操作导致死锁等常见的情况。</p><span id="more"></span><ul><li>首先，我们看看设计问题的代码片段：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> C c : cs) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    processOneC(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processOneC</span><span class="params">(C c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Strings.isNullOrEmpty(c.getSeqNumber())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除原合作业务</span></span><br><span class="line">            cBusinessDAO.deleteBySN(c.getSerialNumber()); <span class="comment">//delete操作</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//..........</span></span><br><span class="line">            </span><br><span class="line">            setTuanBusiness(c, hotelResult); <span class="comment">//insert操作</span></span><br><span class="line">            setDirectBusiness(c, hotelResult); <span class="comment">//insert操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        </span><br><span class="line">            logger.error(<span class="string">&quot;CustomerBusinessProcess.processOneCustomer error, Exception&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;==========&quot;</span> + co.addAndGet(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码的逻辑很简单，就是对一个列表对象，多线程来分别操作。每个对象的处理，删除原来的记录，然后添加新的记录。</p><ul><li>其次，设计到的SQL语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> </span><br><span class="line"><span class="keyword">FROM</span> crm_business </span><br><span class="line"><span class="keyword">WHERE</span> serial_number <span class="operator">=</span> <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">INTO</span> crm_business(</span><br><span class="line">serial_number, </span><br><span class="line">business_type</span><br><span class="line">) <span class="keyword">values</span> (</span><br><span class="line"><span class="string">&#x27;xxxx&#x27;</span>, </span><br><span class="line"><span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>最后，看看相关表的建表sql语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `crm_business` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `serial_number` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商户编号&#x27;</span>,</span><br><span class="line">  `business_type` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;业务类型&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uniq_serial_number_business_type` (`serial_number`,`business_type`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">34856774</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;合作业务&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据表里面，字段很简单，但是里面涉及一个唯一键索引。</p><blockquote><p>Note: 上面的代码，<code>delete</code>和<code>insert</code>操作不在一个事务里面，因为代码上没有添加@transaction 注解，也就是单纯delete<code>和</code>insert`操作在多线程环境下，竟然会产生死锁。此外，需要注意，操作唯一键相关字段，经常会不注意就产生死锁问题。</p></blockquote><h2 id="死锁问题分析"><a href="#死锁问题分析" class="headerlink" title="死锁问题分析"></a><a id="Analyse">死锁问题分析</a></h2><p>首先，给出一篇博客，mysql大神写的<a href="http://hedengcheng.com/?p=844">http://hedengcheng.com/?p=844</a>,一下分析，借鉴使用该博客的分析。</p><blockquote><p>Tips: 有兴趣，请直接阅读该博客的分析。</p></blockquote><h3 id="Mysql日志分析"><a href="#Mysql日志分析" class="headerlink" title="Mysql日志分析"></a>Mysql日志分析</h3><p>以上Mysql产生的死锁日志，包含两个事务。</p><p><em>事务1</em>：当前正在操作一张表（mysql tables in use 1），持有两把锁(2 lock structs，一个表级意向锁，一个行锁(1 row lock))，这个事务，当前正在处理的语句是一条delete语句。同时，这唯一的一个行锁，处于等待状态(WAITING FOR THIS LOCK TO BE GRANTED)。</p><p>事务1等待中的行锁，加锁的对象是唯一索引<code>uniq_serial_number_business_type</code>上页面号为<code>817</code>页面上的一行(注：具体是哪一行，无法看到。但是能够看到的是，这个行锁，一共有824个bits可以用来锁824个行记录，n bits 824：lock_rec_print()方法)。同时，等待的行锁模式为next key锁(lock_mode X)。简单来说，next key锁有两层含义，一是对当前记录加X锁，防止记录被并发修改，同时锁住记录之前的GAP，防止有新的记录插入到此记录之前。</p><p><em>事务2</em>：和事务1一样，事务2上面有三个行锁，三个行锁，<code>undo log entries 1</code>，两个锁都是唯一索引<code>uniq_serial_number_business_type</code>上页号<code>817</code>上的某一条记录。其中，一个锁处于持有状态，锁模式为S mode，即共享锁，同时，另外一把锁处于等待状态，锁模式为X mode，即互斥锁。因此，拥有锁S模式不代表可以获取接下来的X模式的锁。</p><p>事务1正在等待事务2释放锁的S模式，从而获取X模式的锁；但是事务2已经获取了S模式，但是其等待继续获取锁的X模型,这个模式事务1优先申请获取，因此就导致死锁。</p><blockquote><p>Note: 事务1优先去等待获取锁的X模式，是因为在Mysql中为了公平竞争，杜绝事务1发生饥饿现象。这样会导致上述死锁出现。</p></blockquote><p>那么为什么会出现<code>delete</code>操作抛出死锁失败，事务回滚。</p><p>Mysql实现，会根据死锁冲突的两个事务的权重，事务1的权重会更低，然后被选为抛弃的对象，回滚该操作。</p><h3 id="Delete操作的加锁逻辑"><a href="#Delete操作的加锁逻辑" class="headerlink" title="Delete操作的加锁逻辑"></a>Delete操作的加锁逻辑</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> </span><br><span class="line"><span class="keyword">FROM</span> crm_business </span><br><span class="line"><span class="keyword">WHERE</span> serial_number <span class="operator">=</span> <span class="string">&#x27;xxxx&#x27;</span></span><br></pre></td></tr></table></figure><p><code> serial_number</code>是数据表里面的唯一键索引，一个二级索引键值。</p><p><code> serial_number</code>是unique索引，而主键是id列。因此delete语句会选择走<code>serial_number</code>列的索引进行where条件的过滤，在找到<code>serial_number = &#39;xxxx&#39;</code>的记录后，首先会将unique索引上的<code>serial_number = &#39;xxxx&#39;</code>索引记录加上X锁，同时，会根据读取到的<code>id</code>列，回主键索引(聚簇索引)，然后将聚簇索引上的<code>id = 10</code> 对应的主键索引项加X锁。为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：<code>update crm_business set serial_number = xyy where id = 10</code>; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。</p><blockquote><p>Note：和delete操作类似的加锁操作，还有：  </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? lock <span class="keyword">in</span> share mode;  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> update;  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span> (<span class="string">&#x27;xxx&#x27;</span>);  </span><br><span class="line">update <span class="keyword">table</span> <span class="keyword">set</span> ? <span class="keyword">where</span> ?;  </span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;  </span><br></pre></td></tr></table></figure><blockquote><p>上述操作都是当前读，需要读取记录的最新操作，读取之后，为了保证其他并发事务不能修改当前记录，会对读的记录加锁，可能是S模式锁，或者X模式锁。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jackson 工具类使用及配置指南</title>
      <link href="2014/09/09/2014-09-09-Jackson-Manual-and-Implementation-Analyzing/"/>
      <url>2014/09/09/2014-09-09-Jackson-Manual-and-Implementation-Analyzing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>Json数据格式这两年发展的很快，其声称相对XML格式有很对好处:</p><ul><li>容易阅读；</li><li>解析速度快；</li><li>占用空间更少。</li></ul><p>不过,JSON 和 XML两者纠结谁优谁劣,这里不做讨论,可以参见知乎上<a href="http://www.zhihu.com/question/20738607">为什么XML这么笨重的数据结构仍在广泛应用？</a></p><p>最近在项目中，会有各种解析JSON文本的需求，使用第三方<code>Jackson</code>工具来解析时，又担心当增加会减少字段，会不会出现非预期的情况，因此，研究下<code>jackson</code>解析json数据格式的代码，很有需要。</p><h2 id="Jackson使用工具类"><a href="#Jackson使用工具类" class="headerlink" title="Jackson使用工具类"></a><a id="JsonUtils">Jackson使用工具类</a></h2><p>通常，我们对json格式的数据，只会进行解析和封装两种，也就是<code>json字符串---&gt;java对象</code>以及<code>java对象---&gt; json字符串</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">       </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Logger for this class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(JsonUtils.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.INTERN_FIELD_NAMES, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(JsonParser.Feature.CANONICALIZE_FIELD_NAMES, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JsonUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encode</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.writeValueAsString(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonGenerationException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;encode(Object)&quot;</span>, e); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonMappingException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;encode(Object)&quot;</span>, e); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;encode(Object)&quot;</span>, e); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将json string反序列化成对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> json</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> valueType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">decode</span><span class="params">(String json, Class&lt;T&gt; valueType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.readValue(json, valueType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonParseException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;decode(String, Class&lt;T&gt;)&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonMappingException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;decode(String, Class&lt;T&gt;)&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;decode(String, Class&lt;T&gt;)&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将json array反序列化为对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> json</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonTypeReference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">decode</span><span class="params">(String json, TypeReference&lt;T&gt; typeReference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) objectMapper.readValue(json, typeReference);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonParseException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;decode(String, JsonTypeReference&lt;T&gt;)&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonMappingException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;decode(String, JsonTypeReference&lt;T&gt;)&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;decode(String, JsonTypeReference&lt;T&gt;)&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">             </span><br></pre></td></tr></table></figure><h2 id="Jackson配置属性"><a href="#Jackson配置属性" class="headerlink" title="Jackson配置属性"></a><a id="JsonConfig">Jackson配置属性</a></h2><p>如果上面的工具类实例，在Jackson中存在一些属性配置，这些配置决定了最后在解析或者编码后数据视图。因此，在分析Jackson之前，先了解下，Jackson具有的一些配置含义。</p><span id="more"></span><h3 id="JsonParser解析相关配置属性"><a href="#JsonParser解析相关配置属性" class="headerlink" title="JsonParser解析相关配置属性"></a>JsonParser解析相关配置属性</h3><p><code>JsonParser</code>将JSON 数据格式的String字符串，解析成为Java对象。Jackson在解析的时候，对于一些非JSON官方文档支持的属性，则需要通过一些配置才可以被Jackson工具解析成对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Enumeration that defines all togglable features for parsers.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Feature</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// // // Low-level I/O handling features:</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 这个特性，决定了解析器是否将自动关闭那些不属于parser自己的输入源。 如果禁止，则调用应用不得不分别去关闭那些被用来创建parser的基础输入流InputStream和reader；</span></span><br><span class="line"><span class="comment">        * 如果允许，parser只要自己需要获取closed方法（当遇到输入流结束，或者parser自己调用 JsonParder#close方法），就会处理流关闭。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 注意：这个属性默认是true，即允许自动关闭流</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       AUTO_CLOSE_SOURCE(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">// // // Support for non-standard data format constructs</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定parser将是否允许解析使用Java/C++ 样式的注释（包括&#x27;/&#x27;+&#x27;*&#x27; 和&#x27;//&#x27; 变量）。 由于JSON标准说明书上面没有提到注释是否是合法的组成，所以这是一个非标准的特性；</span></span><br><span class="line"><span class="comment">        * 尽管如此，这个特性还是被广泛地使用。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 注意：该属性默认是false，因此必须显式允许，即通过JsonParser.Feature.ALLOW_COMMENTS 配置为true。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       ALLOW_COMMENTS(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 这个特性决定parser是否将允许使用非双引号属性名字， （这种形式在Javascript中被允许，但是JSON标准说明书中没有）。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 注意：由于JSON标准上需要为属性名称使用双引号，所以这也是一个非标准特性，默认是false的。</span></span><br><span class="line"><span class="comment">        * 同样，需要设置JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES为true，打开该特性。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       ALLOW_UNQUOTED_FIELD_NAMES(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定parser是否允许单引号来包住属性名称和字符串值。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 注意：默认下，该属性也是关闭的。需要设置JsonParser.Feature.ALLOW_SINGLE_QUOTES为true</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       ALLOW_SINGLE_QUOTES(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定parser是否允许JSON字符串包含非引号控制字符（值小于32的ASCII字符，包含制表符和换行符）。 如果该属性关闭，则如果遇到这些字符，则会抛出异常。</span></span><br><span class="line"><span class="comment">        * JSON标准说明书要求所有控制符必须使用引号，因此这是一个非标准的特性。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 注意：默认时候，该属性关闭的。需要设置：JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS为true。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       ALLOW_UNQUOTED_CONTROL_CHARS(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性可以允许接受所有引号引起来的字符，使用‘反斜杠\’机制：如果不允许，只有JSON标准说明书中 列出来的字符可以被避开约束。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 由于JSON标准说明中要求为所有控制字符使用引号，这是一个非标准的特性，所以默认是关闭的。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 注意：一般在设置ALLOW_SINGLE_QUOTES属性时，也设置了ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER属性，</span></span><br><span class="line"><span class="comment">        * 所以，有时候，你会看到不设置ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER为true，但是依然可以正常运行。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定parser是否允许JSON整数以多个0开始(比如，如果000001赋值给json某变量，</span></span><br><span class="line"><span class="comment">        * 如果不设置该属性，则解析成int会抛异常报错：org.codehaus.jackson.JsonParseException: Invalid numeric value: Leading zeroes not</span></span><br><span class="line"><span class="comment">        * allowed)</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 注意：该属性默认是关闭的，如果需要打开，则设置JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS为true。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       ALLOW_NUMERIC_LEADING_ZEROS(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性允许parser可以识别&quot;Not-a-Number&quot; (NaN)标识集合作为一个合法的浮点数。 例如： allows (tokens are quoted contents, not including</span></span><br><span class="line"><span class="comment">        * quotes):</span></span><br><span class="line"><span class="comment">        * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">        * &lt;li&gt;&quot;INF&quot; (for positive infinity), as well as alias of &quot;Infinity&quot;</span></span><br><span class="line"><span class="comment">        * &lt;li&gt;&quot;-INF&quot; (for negative infinity), alias &quot;-Infinity&quot;</span></span><br><span class="line"><span class="comment">        * &lt;li&gt;&quot;NaN&quot; (for other not-a-numbers, like result of division by zero)</span></span><br><span class="line"><span class="comment">        * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       ALLOW_NON_NUMERIC_NUMBERS(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">// // // Controlling canonicalization (interning etc)</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定JSON对象属性名称是否可以被String#intern 规范化表示。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 如果允许，则JSON所有的属性名将会 intern() ；如果不设置，则不会规范化，</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 默认下，该属性是开放的。此外，必须设置CANONICALIZE_FIELD_NAMES为true</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 关于intern方法作用：当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串 （该对象由 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String</span></span><br><span class="line"><span class="comment">        * 对象添加到池中， 并且返回此 String 对象的引用。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.3</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       INTERN_FIELD_NAMES(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定JSON对象的属性名称是否被规范化。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       CANONICALIZE_FIELD_NAMES(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       ;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> _defaultState;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Method that calculates bit set (flags) of all features that are enabled by default.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">collectDefaults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (Feature f : values()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (f.enabledByDefault()) &#123;</span><br><span class="line">                   flags |= f.getMask();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> flags;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">Feature</span><span class="params">(<span class="keyword">boolean</span> defaultState)</span> </span>&#123;</span><br><span class="line">           _defaultState = defaultState;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enabledByDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> _defaultState;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enabledIn</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> (flags &amp; getMask()) != <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; ordinal());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Note: 在枚举最后有一个公共静态方法<code>collectDefaults()</code>，这个方法返回一个整形，整形包含的是所有枚举项对应位bit为初始默认值（true：1；false：0），如果默认属性为true，则通过对<code>1 &lt;&lt; ordinal()</code>的值和flags进行亦或来置位。</p></blockquote><h3 id="DeserializationConfig反序列化相关配置属性"><a href="#DeserializationConfig反序列化相关配置属性" class="headerlink" title="DeserializationConfig反序列化相关配置属性"></a>DeserializationConfig反序列化相关配置属性</h3><p>将Java 对象序列化为Json字符串。Jackson在序列化Java对象的时候，对于有些不存在的属性处理，以及一些类型转换等，都可以通过配置来设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Enumeration that defines togglable features that guide the serialization feature.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Feature</span> <span class="keyword">implements</span> <span class="title">MapperConfig</span>.<span class="title">ConfigFeature</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * /****************************************************** Introspection features</span></span><br><span class="line"><span class="comment">        * /******************************************************</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定是否启动内部注解功能支持配置；如果允许，则使用AnnotationIntrospector扫描配置，否则，不考了注解配置。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 默认启动该功能配置属性。</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       USE_ANNOTATIONS(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定是否使用“getter”方法来根据标准bean命名转换方式来自动检测。如果true，则所有公共的带有一个参数</span></span><br><span class="line"><span class="comment">        * 并且前缀为set的方法都将被当做setter方法。如果false，只会把显式注解的作为setter方法。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 注意: 这个特性的优先级低于显式注解，并且只会在获取不到更细粒度配置的情况下。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       AUTO_DETECT_GETTERS(<span class="keyword">true</span>),                        DETECT_IS_GETTERS(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定是否使用creator方法来根据公共构造函数以及名字为“valueOf”的静态单参数方法自动检测。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 注意：这个特性比每个类上注解的优先级要低。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       AUTO_DETECT_CREATORS(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 这个特性决定是否非静态field被当做属性。如果true，则所有公共成员field都被当做属性， 否则只有注解，才会被当做属性field。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       AUTO_DETECT_FIELDS(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 使用getter方法来作为setter方法（一般只处理集合和Maps，和其他没有setter的类型）。 该属性决定是否不需要setter方法，而只需要getter方法来修改属性。</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * 注意：该配置优先级低于setter。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       USE_GETTERS_AS_SETTERS(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定当访问属性时候，方法和field访问是否修改设置。 如果设置为true，则通过反射调用方法AccessibleObject#setAccessible 来允许访问不能访问的对象。</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       CAN_OVERRIDE_ACCESS_MODIFIERS(<span class="keyword">true</span>),                GETTERS(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * /****************************************************** /* Type conversion features</span></span><br><span class="line"><span class="comment">        * /******************************************************</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定对于json浮点数，是否使用BigDecimal来序列化。如果不允许，则使用Double序列化。</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * 注意：该特性默认是关闭的，因为性能上来说，BigDecimal低于Double。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       USE_BIG_DECIMAL_FOR_FLOATS(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定对于json整形（非浮点），是否使用BigInteger来序列化。如果不允许，则根据数值大小来确定 是使用Integer&#125;, &#123;<span class="doctag">@link</span> Long&#125; 或者</span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> java.math.BigInteger&#125;</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       USE_BIG_INTEGER_FOR_INTS(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">// [JACKSON-652]</span></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定JSON ARRAY是映射为Object[]还是List&lt;Object&gt;。如果开启，都为Object[]，false时，则使用List。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.9</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       USE_JAVA_ARRAY_FOR_JSON_ARRAY(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定了使用枚举值的标准序列化机制：如果允许，则枚举假定使用Enum.toString()返回的值作为序列化结构；如果禁止, 则返回Enum.name()的值。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 注意：默认使用的时Enum.name()的值作为枚举序列化结果。这个的设置和WRITE_ENUMS_USING_TO_STRING需要一致。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * For further details, check out [JACKSON-212]</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       READ_ENUMS_USING_TO_STRING(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * /****************************************************** Error handling features</span></span><br><span class="line"><span class="comment">        * /****************************************************** 错误处理特性</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定了当遇到未知属性（没有映射到属性，没有任何setter或者任何可以处理它的handler），是否应该抛出一个</span></span><br><span class="line"><span class="comment">        * JsonMappingException异常。这个特性一般式所有其他处理方法对未知属性处理都无效后才被尝试，属性保留未处理状态。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 默认情况下，该设置是被打开的。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       FAIL_ON_UNKNOWN_PROPERTIES(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定当遇到JSON null的对象是java 原始类型，则是否抛出异常。当false时，则使用0 for &#x27;int&#x27;, 0.0 for double 来设定原始对象初始值。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 默认情况下，允许原始类型可以使用null。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.7</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       FAIL_ON_NULL_FOR_PRIMITIVES(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定JSON 整数是否是一个有效的值，当被用来反序列化Java枚举值。如果false，数字可以接受，并且映射为枚举的值ordinal()；</span></span><br><span class="line"><span class="comment">        * 如果true，则数字不允许并且抛出JsonMappingException异常。后面一种行为原因是因为大部分情况下，枚举被反序列化为 JSON 字符串， 从而造成从整形到枚举的意外映射关系。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * Feature is disabled by default (to be consistent with behavior of Jackson 1.6), i.e. to allow use of JSON</span></span><br><span class="line"><span class="comment">        * integers for Java enums.</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.7</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       FAIL_ON_NUMBERS_FOR_ENUMS(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 异常封装，不封装Error,catch异常之后，抛出IOException。默认封装异常。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.7</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       WRAP_EXCEPTIONS(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * /****************************************************** Structural conversion features</span></span><br><span class="line"><span class="comment">        * /****************************************************** 数据结构转换特性</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定是否接受强制非数组（JSON）值到Java集合类型。如果允许，集合反序列化将尝试处理非数组值。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * Feature that determines whether it is acceptable to coerce non-array (in JSON) values to work with Java</span></span><br><span class="line"><span class="comment">        * collection (arrays, java.util.Collection) types. If enabled, collection deserializers will try to handle</span></span><br><span class="line"><span class="comment">        * non-array values as if they had &quot;implicit&quot; surrounding JSON array. This feature is meant to be used for</span></span><br><span class="line"><span class="comment">        * compatibility/interoperability reasons, to work with packages (such as XML-to-JSON converters) that leave out</span></span><br><span class="line"><span class="comment">        * JSON array in cases where there is just a single element in array.</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       ACCEPT_SINGLE_VALUE_AS_ARRAY(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特征允许 unwrap根级别JSON 值，来匹配WRAP_ROOT_VALUE 序列化设置。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.9</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       UNWRAP_ROOT_VALUE(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * /****************************************************** Value conversion features</span></span><br><span class="line"><span class="comment">        * /****************************************************** 值转换特性</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性可以允许JSON空字符串转换为POJO对象为null。如果禁用，则标准POJO只会从JSON null或者JSON对象转换过来；</span></span><br><span class="line"><span class="comment">        * 如果允许，则空JSON字符串可以等价于JSON null。</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       ACCEPT_EMPTY_STRING_AS_NULL_OBJECT(<span class="keyword">false</span>)</span><br><span class="line"></span><br><span class="line">       ;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> _defaultState;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">Feature</span><span class="params">(<span class="keyword">boolean</span> defaultState)</span> </span>&#123;</span><br><span class="line">           _defaultState = defaultState;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enabledByDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> _defaultState;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; ordinal());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SerializationConfig-序列化相关配置属性"><a href="#SerializationConfig-序列化相关配置属性" class="headerlink" title="SerializationConfig 序列化相关配置属性"></a>SerializationConfig 序列化相关配置属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 定义序列化对象所需配置的一些枚举.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Feature</span> <span class="keyword">implements</span> <span class="title">MapperConfig</span>.<span class="title">ConfigFeature</span></span></span><br><span class="line"><span class="class">   </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       /******************************************************</span></span><br><span class="line"><span class="comment">       /*  Introspection features</span></span><br><span class="line"><span class="comment">       /******************************************************</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 注解扫描配置</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       USE_ANNOTATIONS(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取getter方法，前缀为get</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       AUTO_DETECT_GETTERS(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取getter方法，前缀为is</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       AUTO_DETECT_IS_GETTERS(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将对象所有的field作为json属性</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        AUTO_DETECT_FIELDS(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定当访问属性时候，方法和field访问是否修改设置。 如果设置为true，</span></span><br><span class="line"><span class="comment">        * 则通过反射调用方法AccessibleObject#setAccessible 来允许访问不能访问的对象。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       CAN_OVERRIDE_ACCESS_MODIFIERS(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取的getter方法需要setter方法，否则，所有发现的getter都可以作为getter方法。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       REQUIRE_SETTERS_FOR_GETTERS(<span class="keyword">false</span>),</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       /******************************************************</span></span><br><span class="line"><span class="comment">       /* Generic output features</span></span><br><span class="line"><span class="comment">       /******************************************************</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 属性对应的值为null，是否需要写出来，write out。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@Deprecated</span></span><br><span class="line">       WRITE_NULL_PROPERTIES(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 特征决定是使用运行时动态类型，还是声明的静态类型。</span></span><br><span class="line"><span class="comment">        * 也可以使用&#123;<span class="doctag">@link</span> JsonSerialize#typing&#125; 注解属性</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       USE_STATIC_TYPING(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定拥有view注解&#123;<span class="doctag">@link</span> org.codehaus.jackson.map.annotate.JsonView&#125;的属性是否在JSON序列化视图中。如果true，则非注解视图，也包含；</span></span><br><span class="line"><span class="comment">        * 否则，它们将会被排除在外。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       DEFAULT_VIEW_INCLUSION(<span class="keyword">true</span>),</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 在JAVA中配置XML root&#123;<span class="doctag">@XmlRootElement</span>.name&#125;注解,最后xml数据中会出现对应root根name.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       WRAP_ROOT_VALUE(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性对于最基础的生成器，使用默认pretty printer &#123;<span class="doctag">@link</span> org.codehaus.jackson.JsonGenerator#useDefaultPrettyPrinter&#125;</span></span><br><span class="line"><span class="comment">        * 这只会对&#123;<span class="doctag">@link</span> org.codehaus.jackson.JsonGenerator&#125;有影响.该属性值允许使用默认的实现。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       INDENT_OUTPUT(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 是否对属性使用排序，默认排序按照字母顺序。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       SORT_PROPERTIES_ALPHABETICALLY(<span class="keyword">false</span>),</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       /******************************************************</span></span><br><span class="line"><span class="comment">       /*  Error handling features</span></span><br><span class="line"><span class="comment">       /******************************************************</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 是否允许一个类型没有注解表明打算被序列化。默认true，抛出一个异常；否则序列化一个空对象，比如没有任何属性。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * Note that empty types that this feature has only effect on</span></span><br><span class="line"><span class="comment">        * those &quot;empty&quot; beans that do not have any recognized annotations</span></span><br><span class="line"><span class="comment">        * (like &lt;code&gt;<span class="doctag">@JsonSerialize</span>&lt;/code&gt;): ones that do have annotations</span></span><br><span class="line"><span class="comment">        * do not result in an exception being thrown.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       FAIL_ON_EMPTY_BEANS(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 封装所有异常</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       WRAP_EXCEPTIONS(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       /******************************************************</span></span><br><span class="line"><span class="comment">       /* Output life cycle features</span></span><br><span class="line"><span class="comment">       /******************************************************</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该特性决定序列化root级对象的实现closeable接口的close方法是否在序列化后被调用。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 注意：如果true，则完成序列化后就关闭；如果，你可以在处理最后，调用排序操作等，则为false。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       CLOSE_CLOSEABLE(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定是否在writeValue()方法之后就调用JsonGenerator.flush()方法。</span></span><br><span class="line"><span class="comment">        * 当我们需要先压缩，然后再flush，则可能需要false。</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       FLUSH_AFTER_WRITE_VALUE(<span class="keyword">true</span>),</span><br><span class="line">        </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       /******************************************************</span></span><br><span class="line"><span class="comment">       /* Data type - specific serialization configuration</span></span><br><span class="line"><span class="comment">       /******************************************************</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定是否将基于Date的值序列化为timestamp数字式的值，或者作为文本表示。</span></span><br><span class="line"><span class="comment">        * 如果文本表示，则实际格式化的时候会调用&#123;<span class="doctag">@link</span> #getDateFormat&#125;方法。</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * 该特性可能会影响其他date相关类型的处理，虽然我们理想情况是只对date起作用。</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       WRITE_DATES_AS_TIMESTAMPS(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 是否将Map中得key为Date的值，也序列化为timestamps形式（否则，会被序列化为文本形式的值）。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       WRITE_DATE_KEYS_AS_TIMESTAMPS(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定怎样处理类型char[]序列化，是否序列化为一个显式的JSON数组，还是默认作为一个字符串。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 该特性决定对Enum 枚举值使用标准的序列化机制。如果true，则返回Enum.toString()值，否则为Enum.name()</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       WRITE_ENUMS_USING_TO_STRING(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 这个特性决定Java枚举值是否序列化为数字（true）或者文本值（false）.如果是值的话，则使用Enum.ordinal().</span></span><br><span class="line"><span class="comment">        * 该特性优先级高于上面的那个。</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.9</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       WRITE_ENUMS_USING_INDEX(<span class="keyword">false</span>),</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 决定是否Map的带有null值的entry被序列化（true）</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       WRITE_NULL_MAP_VALUES(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 决定容器空的属性（声明为Collection或者array的值）是否被序列化为空的JSON数组（true），否则强制输出。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * Note that this does not change behavior of &#123;<span class="doctag">@link</span> java.util.Map&#125;s, or</span></span><br><span class="line"><span class="comment">        * &quot;Collection-like&quot; types.</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@since</span> 1.9</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       WRITE_EMPTY_JSON_ARRAYS(<span class="keyword">true</span>)</span><br><span class="line">       </span><br><span class="line">           ;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> _defaultState;</span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">Feature</span><span class="params">(<span class="keyword">boolean</span> defaultState)</span> </span>&#123;</span><br><span class="line">           _defaultState = defaultState;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enabledByDefault</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _defaultState; &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMask</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; ordinal()); &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Jackson解析JSON数据"><a href="#Jackson解析JSON数据" class="headerlink" title="Jackson解析JSON数据"></a><a id="JsonParser">Jackson解析JSON数据</a></h2><p>Jackson对外提供了多种解析json数据格式的方法，例如，<code>String context</code>、<code>Reader src</code>、<code>Url src</code>等，此外，对于Java POJO类型也提供了三种方式：<code>Class&lt;T&gt; valueType</code>和<code>TypeReference valueTypeRef</code>以及<code>JavaType valueType</code>。为了简单，这里分析通常应用最多的一种，即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(String content, Class&lt;T&gt; valueType)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p><code>readValue()</code>和其他解析方法一样，内部都是通过构造<code>_readMapAndClose(JsonParser jp, JavaType valueType)</code>方法所需要的参数，来调用解析JSON数据的。</p><p>首先，来看下如何构造方法的两个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonParser <span class="title">createJsonParser</span><span class="params">(String content)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IOException, JsonParseException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line"><span class="comment">// true -&gt; we own the Reader (and must close); not a big deal（还记得上面的配置吗:)）</span></span><br><span class="line">Reader r = <span class="keyword">new</span> StringReader(content);</span><br><span class="line"><span class="keyword">return</span> _createJsonParser(r, _createContext(r, <span class="keyword">true</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 构造实际使用的parser的工厂方法。</span></span><br><span class="line">   <span class="comment">// _parserFeatures就是上面默认的属性int，collectDefaults()方法返回值。</span></span><br><span class="line">   <span class="comment">// _objectCodec：实现在JAVA对象和JSON内容之间的转换功能，没有默认，需要显式去设置。一般我们直接使用MappingJsonFactory构造。</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> JsonParser <span class="title">_createJsonParser</span><span class="params">(Reader r, IOContext ctxt)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, JsonParseException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ReaderBasedParser(ctxt, _parserFeatures, r, _objectCodec,</span><br><span class="line">               _rootCharSymbols.makeChild(isEnabled(JsonParser.Feature.CANONICALIZE_FIELD_NAMES),</span><br><span class="line">                   isEnabled(JsonParser.Feature.INTERN_FIELD_NAMES)));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 直接调用构造函数构造一个JsonParser实现类实例</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ReaderBasedParser</span><span class="params">(IOContext ioCtxt, <span class="keyword">int</span> features, Reader r,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ObjectCodec codec, CharsToNameCanonicalizer st)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(ioCtxt, features, r);</span><br><span class="line">       _objectCodec = codec;</span><br><span class="line">       _symbols = st;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>在上面实现中，还可以看看<code>_createContext(r, true)</code>的实现，它会构造出一个<code>IOConetxt</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IOContext</span><span class="params">(BufferRecycler br, Object sourceRef, <span class="keyword">boolean</span> managedResource)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       _bufferRecycler = br;</span><br><span class="line">       _sourceRef = sourceRef;</span><br><span class="line">       _managedResource = managedResource;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//  _recyclerRef 是一个定义全局的ThreadLocal&lt;SoftReference&lt;BufferRecycler&gt;&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BufferRecycler <span class="title">_getBufferRecycler</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       SoftReference&lt;BufferRecycler&gt; ref = _recyclerRef.get();</span><br><span class="line">       BufferRecycler br = (ref == <span class="keyword">null</span>) ? <span class="keyword">null</span> : ref.get();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (br == <span class="keyword">null</span>) &#123;</span><br><span class="line">           br = <span class="keyword">new</span> BufferRecycler();</span><br><span class="line">           _recyclerRef.set(<span class="keyword">new</span> SoftReference&lt;BufferRecycler&gt;(br));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> br;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>构造函数有三个参数，<code>managedResource</code>，我们在配置上讲过，Jackson对于外部的资源会默认自动关闭流，但是对<code>自己拥有的流Reader</code>，会自动关闭，无论设置与否。<code>Object sourceRef</code>参数其实就是我们通过<code>content</code>构造出来的Reader引用。<code>BufferRecycler br</code>这是一个很重要的参数，涉及到内存分配优化。</p><blockquote><p>Note： <code>BufferRecycler</code>其实就是一个小的工具类，主要负责初始字节/字符缓存的重复使用。在Jackson中，主要用来通过引用该类的<code>SoftReference</code>形式作为<code>ThreadLocal</code>成员，这样可以达到低负载GC循环的效果，显然是使用流reader所期待的结果。<br>其主要定义四种类型缓存：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CharBufferType</span> </span>&#123;</span><br><span class="line">       TOKEN_BUFFER(<span class="number">2000</span>) <span class="comment">// Tokenizable input</span></span><br><span class="line">           ,CONCAT_BUFFER(<span class="number">2000</span>) <span class="comment">// concatenated output</span></span><br><span class="line">           ,TEXT_BUFFER(<span class="number">200</span>) <span class="comment">// Text content from input</span></span><br><span class="line">           ,NAME_COPY_BUFFER(<span class="number">200</span>) <span class="comment">// Temporary buffer for getting name characters</span></span><br><span class="line">           ;</span><br><span class="line">       </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">CharBufferType(<span class="keyword">int</span> size) &#123; <span class="keyword">this</span>.size = size; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>上面的<code>JsonParser</code>就完成的参数构造，接下来就是<code>JavaType</code>了，两种类型都最后调用<code>_constructType</code>来构造<code>JavaType</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaType <span class="title">constructType</span><span class="params">(Type type)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> _constructType(type, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Factory method that can be used if type information is passed</span></span><br><span class="line"><span class="comment">    * as Java typing returned from &lt;code&gt;getGenericXxx&lt;/code&gt; methods</span></span><br><span class="line"><span class="comment">    * (usually for a return or argument type).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JavaType <span class="title">_constructType</span><span class="params">(Type type, TypeBindings context)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       JavaType resultType;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// simple class?</span></span><br><span class="line">       <span class="keyword">if</span> (type <span class="keyword">instanceof</span> Class&lt;?&gt;) &#123;</span><br><span class="line">           Class&lt;?&gt; cls = (Class&lt;?&gt;) type;</span><br><span class="line">           <span class="comment">/* 24-Mar-2010, tatu: Better create context if one was not passed;</span></span><br><span class="line"><span class="comment">            *   mostly matters for root serialization types</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">               context = <span class="keyword">new</span> TypeBindings(<span class="keyword">this</span>, cls);</span><br><span class="line">           &#125;</span><br><span class="line">           resultType = _fromClass(cls, context);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// But if not, need to start resolving.</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;<span class="comment">//带有参数化的类型，比如Collection&lt;String&gt;</span></span><br><span class="line">           resultType = _fromParamType((ParameterizedType) type, context);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> GenericArrayType) &#123;<span class="comment">//表示一个数组类型，成员有参数化类型或者type变量</span></span><br><span class="line">           resultType = _fromArrayType((GenericArrayType) type, context);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> TypeVariable&lt;?&gt;) &#123;<span class="comment">//其他类型的父接口</span></span><br><span class="line">           resultType = _fromVariable((TypeVariable&lt;?&gt;) type, context);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> WildcardType) &#123;<span class="comment">//通配符类型，比如? 或者 ? extends Number</span></span><br><span class="line">           resultType = _fromWildcard((WildcardType) type, context);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 最后类型都不符合，就会抛出非法参数异常Unrecognized Type</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unrecognized Type: &quot;</span>+type.toString());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* </span></span><br><span class="line"><span class="comment">        * 目前只会被 simple types调用 (i.e. not for arrays, map or collections).</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (_modifiers != <span class="keyword">null</span> &amp;&amp; !resultType.isContainerType()) &#123;</span><br><span class="line">           <span class="keyword">for</span> (TypeModifier mod : _modifiers) &#123;</span><br><span class="line">               resultType = mod.modifyType(resultType, type, context, <span class="keyword">this</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> resultType;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>代码逻辑很简单，就是通过对参数类型进行不同的处理构造，最后返回<code>JavaType</code>某一具体的实现类实例。和其他处理一样，一般都是从精确类型开始匹配，慢慢抽象。</p></blockquote><p>接下来，为了简单起见，我们不对非常用设置进行分析，看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">_readMapAndClose</span><span class="params">(JsonParser jp, JavaType valueType)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IOException, JsonParseException, JsonMappingException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Object result;</span><br><span class="line">           JsonToken t = _initForReading(jp);</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// 省略一部分非重点代码。。。。。。</span></span><br><span class="line">           </span><br><span class="line">           DeserializationConfig cfg = copyDeserializationConfig();<span class="comment">//创建一个反序列化配置的副本，内部采用copy-on-write模式，所以使用副本。</span></span><br><span class="line">               DeserializationContext ctxt = _createDeserializationContext(jp, cfg);<span class="comment">//反序列化上下文</span></span><br><span class="line">               JsonDeserializer&lt;Object&gt; deser = _findRootDeserializer(cfg, valueType);</span><br><span class="line">               <span class="keyword">if</span> (cfg.isEnabled(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE)) &#123;</span><br><span class="line">                   result = _unwrapAndDeserialize(jp, valueType, ctxt, deser);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   result = deser.deserialize(jp, ctxt);</span><br><span class="line">               &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// Need to consume the token too</span></span><br><span class="line">           jp.clearCurrentToken();</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               jp.close();<span class="comment">//关闭资源</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException ioe) &#123; &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中有几点重要的方法：</p><ul><li><code>JsonToken _initForReading(JsonParser jp)</code>方法:</li></ul><p>该方法主要是在反序列化开始的时候，获取JsonToken标识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> JsonToken <span class="title">_initForReading</span><span class="params">(JsonParser jp)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IOException, JsonParseException, JsonMappingException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">/* 首先：必须只想一个token；没有token的情况只可以出现在第一次，和当前token被清除。</span></span><br><span class="line"><span class="comment">        * 此外，这里的JsonParser具体是指ReaderBaseParser实例，（还记得把String Reader处理吗？！）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       JsonToken t = jp.getCurrentToken(); <span class="comment">//内部使用了简单地缓存ConcurrentHashMap实现</span></span><br><span class="line">       <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// and then we must get something...</span></span><br><span class="line">           t = jp.nextToken(); <span class="comment">// 判断当前是什么类型的JSON标识，比如对象JSON刚开始为&quot;START_OBJECT&quot;</span></span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">/* [JACKSON-99] Should throw EOFException, closest thing</span></span><br><span class="line"><span class="comment">                *   semantically</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> EOFException(<span class="string">&quot;No content to map to Object due to end of input&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> t;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>_findRootDeserializer(DeserializationConfig cfg, JavaType valueType)</code>方法：</li></ul><p>该方法在反序列化root-level值时调用。该方法使用了ConcurrentHashMap缓存来优化，只有root-level的反序列化才会被缓存，这主要是因为反序列化的输入和解决方案都是静态的，但是序列化却是动态的，所以做缓存只对反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Method called to locate deserializer for the passed root-level value.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> JsonDeserializer&lt;Object&gt; <span class="title">_findRootDeserializer</span><span class="params">(DeserializationConfig cfg, JavaType valueType)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> JsonMappingException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// First: have we already seen it?</span></span><br><span class="line">      JsonDeserializer&lt;Object&gt; deser = _rootDeserializers.get(valueType);<span class="comment">//从缓存中获取对应类型的反序列化实例</span></span><br><span class="line">      <span class="keyword">if</span> (deser != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> deser;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Nope: need to ask provider to resolve it</span></span><br><span class="line">      deser = _deserializerProvider.findTypedValueDeserializer(cfg, valueType, <span class="keyword">null</span>);<span class="comment">//使用StdDeserializationContext默认的DeserializationContext实现。反序列化类实际上就是对某一类型进行详细描述，如下图。</span></span><br><span class="line">      <span class="keyword">if</span> (deser == <span class="keyword">null</span>) &#123; <span class="comment">// can this happen?</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> JsonMappingException(<span class="string">&quot;Can not find a deserializer for type &quot;</span>+valueType);</span><br><span class="line">      &#125;</span><br><span class="line">      _rootDeserializers.put(valueType, deser);<span class="comment">//放入缓存中</span></span><br><span class="line">      <span class="keyword">return</span> deser;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>反序列化类结构如图：<br><img src="/images/2014/09/deser.png" /></p><ul><li><code>deserialize(JsonParser jp, DeserializationContext ctxt)</code>方法:</li></ul><p>由于解析对象为简单地Bean，所以调用<code>BeanDeserializer</code>转换为POJO对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">deserialize</span><span class="params">(JsonParser jp, DeserializationContext ctxt)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IOException, JsonProcessingException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       JsonToken t = jp.getCurrentToken();</span><br><span class="line">       <span class="comment">// common case first:</span></span><br><span class="line">       <span class="keyword">if</span> (t == JsonToken.START_OBJECT) &#123;</span><br><span class="line">           jp.nextToken();</span><br><span class="line">           <span class="keyword">return</span> deserializeFromObject(jp, ctxt);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// and then others, generally requiring use of @JsonCreator</span></span><br><span class="line">       <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">       <span class="keyword">case</span> VALUE_STRING:</span><br><span class="line">           <span class="keyword">return</span> deserializeFromString(jp, ctxt);</span><br><span class="line">       <span class="keyword">case</span> VALUE_NUMBER_INT:</span><br><span class="line">           <span class="keyword">return</span> deserializeFromNumber(jp, ctxt);</span><br><span class="line">       <span class="keyword">case</span> VALUE_NUMBER_FLOAT:</span><br><span class="line">    <span class="keyword">return</span> deserializeFromDouble(jp, ctxt);</span><br><span class="line">       <span class="keyword">case</span> VALUE_EMBEDDED_OBJECT:</span><br><span class="line">           <span class="keyword">return</span> jp.getEmbeddedObject();</span><br><span class="line">       <span class="keyword">case</span> VALUE_TRUE:</span><br><span class="line">       <span class="keyword">case</span> VALUE_FALSE:</span><br><span class="line">           <span class="keyword">return</span> deserializeFromBoolean(jp, ctxt);</span><br><span class="line">       <span class="keyword">case</span> START_ARRAY:</span><br><span class="line">           <span class="comment">// these only work if there&#x27;s a (delegating) creator...</span></span><br><span class="line">           <span class="keyword">return</span> deserializeFromArray(jp, ctxt);</span><br><span class="line">       <span class="keyword">case</span> FIELD_NAME:</span><br><span class="line">       <span class="keyword">case</span> END_OBJECT: <span class="comment">// added to resolve [JACKSON-319], possible related issues</span></span><br><span class="line">           <span class="keyword">return</span> deserializeFromObject(jp, ctxt);</span><br><span class="line">&#125;</span><br><span class="line">       <span class="keyword">throw</span> ctxt.mappingException(getBeanClass());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是具体的反序列化方法,如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deserializeFromObject</span><span class="params">(JsonParser jp, DeserializationContext ctxt)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, JsonProcessingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_nonStandardCreation) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_unwrappedPropertyHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> deserializeWithUnwrapped(jp, ctxt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_externalTypeIdHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> deserializeWithExternalTypeId(jp, ctxt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserializeFromObjectUsingNonDefault(jp, ctxt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object bean = _valueInstantiator.createUsingDefault();<span class="comment">// 构造一个默认的初始化类型对象，对象属性值使用初始化默认值。</span></span><br><span class="line">    <span class="keyword">if</span> (_injectables != <span class="keyword">null</span>) &#123;</span><br><span class="line">        injectValues(ctxt, bean);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) &#123; <span class="comment">//迭代输入流来设置各个属性的值</span></span><br><span class="line">        String propName = jp.getCurrentName();</span><br><span class="line">        <span class="comment">// Skip field name:</span></span><br><span class="line">        jp.nextToken();<span class="comment">// 迭代到下一个输入流的token名字，即使在POJO中没有对应属性，则会调用_handleUnknown来处理。</span></span><br><span class="line">        SettableBeanProperty prop = _beanProperties.find(propName); <span class="comment">//具体实现如下</span></span><br><span class="line">        <span class="keyword">if</span> (prop != <span class="keyword">null</span>) &#123; <span class="comment">// 如果在POJO中有对应属性，则返回kv</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                prop.deserializeAndSet(jp, ctxt, bean);<span class="comment">//根据类型调用具体的方法设置属性值，比如StringDeserializer类对字符串。</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                wrapAndThrow(e, bean, propName, ctxt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _handleUnknown(jp, ctxt, bean, propName);<span class="comment">//这里会根据上面的配置来决定处理方案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanPropertyMap类是一个存储属性名到SettableBeanProperty实例之间的映射的工具类。该类主要代替HashMap，做了一些业务优化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SettableBeanProperty <span class="title">find</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = key.hashCode() &amp; _hashMask;<span class="comment">//hash找到bucket位置</span></span><br><span class="line">    Bucket bucket = _buckets[index];<span class="comment">//</span></span><br><span class="line">    <span class="comment">// Let&#x27;s unroll first lookup since that is null or match in 90+% cases</span></span><br><span class="line">    <span class="keyword">if</span> (bucket == <span class="keyword">null</span>) &#123;<span class="comment">//如果不存在，则返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Primarily we do just identity comparison as keys should be interned</span></span><br><span class="line">    <span class="keyword">if</span> (bucket.key == key) &#123; <span class="comment">// 当没有hash碰撞时，则会相等</span></span><br><span class="line">        <span class="keyword">return</span> bucket.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((bucket = bucket.next) != <span class="keyword">null</span>) &#123;<span class="comment">//不能直接相等，则遍历找到bucket里面所有的key</span></span><br><span class="line">        <span class="keyword">if</span> (bucket.key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> bucket.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Do we need fallback for non-interned Strings?</span></span><br><span class="line">    <span class="keyword">return</span> _findWithEquals(key, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Jackson序列化Java对象"><a href="#Jackson序列化Java对象" class="headerlink" title="Jackson序列化Java对象"></a><a id="JsonDeserializer">Jackson序列化Java对象</a></h2><p><code>Jackson</code>工具包对外提供看好几种序列化接口，比如转换为String对象，Byte[]数组，或者直接写到stream中等等，但是不管如何，其内部实现的核心方法都是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">_configAndWriteValue</span><span class="params">(JsonGenerator jgen, Object value)</span></span></span><br></pre></td></tr></table></figure><p>因此，这里就选择常用的<code>writeValueAsString(Object value)</code>来解析器内部实现。</p><blockquote><p>Note：虽然在<code>Jackson</code>中提供了<code>public void writeValue(Writer w, Object value)</code>的通用方法来序列化java对象，对于需要转换为String类型的需求，只需要<code>StringWriter</code>就可以调用writeValue，但是由于这种序列化对性能要求高，并且使用频繁，所以单独提供更高效的实现方式。而正由于在项目代码中AsString 场景十分多，所以这里选择<code>writeValueAsString</code>方法分析。</p></blockquote><h3 id="序列化方法处理流程"><a href="#序列化方法处理流程" class="headerlink" title="序列化方法处理流程"></a>序列化方法处理流程</h3><p><code>writeValueAsString(Object value)</code>其处理和反序列化很相似，基本流程为：</p><ol><li><em>首先，构建通用序列化基础方法所需要的参数类型对象；</em></li><li><em>其次，对序列化类型进行分析，根据注解或者”get方法名(比如getXxx,isXxx)”等来构建需要序列化的属性</em></li><li><em>然后，通过反射机制分别对所有的序列化属性进行处理：通过发现拿到对应的值,getxxx方法等</em></li><li><em>拼接字符串：其内部是根据类型写入一些开始结束符号，例如{,[等，在其中嵌入步骤3的解析设值</em></li><li><em>返回最后得到的字符串内容</em></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Json </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac OS系统Vim酷炫插件安装</title>
      <link href="2014/08/26/2014-08-26-Vim-Plugin-On-Mac/"/>
      <url>2014/08/26/2014-08-26-Vim-Plugin-On-Mac/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>vim工具，对于一个程序猿来讲，是使用非常普遍的。以前在Ubuntu上安装<code>ma6174</code>大神提供的安装脚本，一键安装一些非常好用的插件，但是对于Mac来说，一直不能很好地执行一件安装。</p><p>这里，记录一下，使用大神提供的安装脚本出现问题的解决方法。</p><h2 id="Vim一键安装脚本"><a href="#Vim一键安装脚本" class="headerlink" title="Vim一键安装脚本"></a><a id="Shell">Vim一键安装脚本</a></h2><p><code>ma6174</code>大神提供的安装脚本，不能直接在Mac 上运行，直接copy到本地，脚本为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">brew install vim ctags git astyle</span><br><span class="line">sudo ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future easy_install twisted</span><br><span class="line"></span><br><span class="line">sudo easy_install -ZU autopep8 twisted</span><br><span class="line">sudo ln -s /usr/bin/ctags /usr/<span class="built_in">local</span>/bin/ctags</span><br><span class="line">mv -f ~/vim ~/vim_old</span><br><span class="line"><span class="built_in">cd</span> ~/ &amp;&amp; git <span class="built_in">clone</span> https://github.com/ma6174/vim.git</span><br><span class="line">mv -f ~/.vim ~/.vim_old</span><br><span class="line">mv -f ~/vim ~/.vim</span><br><span class="line">mv -f ~/.vimrc ~/.vimrc_old</span><br><span class="line">mv -f ~/.vim/.vimrc ~/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle</span><br><span class="line">vim vim_mac -c <span class="string">&quot;BundleInstall&quot;</span> -c <span class="string">&quot;q&quot;</span> -c <span class="string">&quot;q&quot;</span></span><br><span class="line">rm vim_mac</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;安装完成&quot;</span></span><br><span class="line">            </span><br></pre></td></tr></table></figure><blockquote><p>Note：上面的脚本是直接从一键安装命令中的build脚本部分拷贝的，因为我的Mac无法直接执行一键安装命令。此外，Mac必须安装HomeBrew工具，关于该工具的安装使用，请参考 <a href="http://brew.sh/index_zh-cn.html">http://brew.sh/index_zh-cn.html</a></p></blockquote><span id="more"></span><h2 id="手动安装zope"><a href="#手动安装zope" class="headerlink" title="手动安装zope"></a><a id="Zope">手动安装zope</a></h2><p>在上面的脚本安装完成之后，控制台执行<code>vim</code>命令，会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Error detected while processing /Users/rum/.vim/plugin/client.vim:</span><br><span class="line">line 314:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File &quot;&quot;, line 2, in </span><br><span class="line">File &quot;/Library/Python/2.7/site-packages/Twisted-14.0.0-py2.7-macosx-10.9-intel.egg/twisted/init.py&quot;, line 53, in </span><br><span class="line">checkRequirements()</span><br><span class="line">File &quot;/Library/Python/2.7/site-packages/Twisted-14.0.0-py2.7-macosx-10.9-intel.egg/twisted/__init_.py&quot;, line 37, in _checkRequirements</span><br><span class="line">raise ImportError(required + &quot;: no module named zope.interface.&quot;)</span><br><span class="line">ImportError: Twisted requires zope.interface 3.6.0 or later: no module named zope.interface.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，Google搜了各种方法都不生效，无奈执行，只能源码安装了。安装起来很简单，直接执行就好了。</p><ol><li>源码下载地址：<a href="https://pypi.python.org/packages/source/z/zope.interface/zope.interface-4.1.0.tar.gz#md5=ac63de1784ea0327db876c908af07a94">https://pypi.python.org/packages/source/z/zope.interface/zope.interface-4.1.0.tar.gz#md5=ac63de1784ea0327db876c908af07a94</a></li><li>解压缩之后，执行安装命令:<code>sudo python setup.py install</code>。</li></ol><p>完成之后，在执行    <code>vim</code>命令，就不会报错了。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a><a id="End">后记</a></h2><p>安装完插件之后，果然用起来十分爽哇！！此外，<code>ma6174</code>大神还提供了一些使用<code>Tips</code>。</p><h3 id="编写python程序"><a href="#编写python程序" class="headerlink" title="编写python程序"></a>编写python程序</h3><ol><li>自动插入头信息：<ul><li><code>#!/usr/bin/env python</code></li><li><code># coding=utf-8</code></li></ul></li></ol><ul><li>输入<code>.</code>或按<code>TAB</code>键会触发代码补全功能</li><li><code>:w</code>保存代码之后会自动检查代码错误与规范</li><li>按<code>F6</code>可以按<code>pep8</code>格式对代码格式优化</li><li>按<code>F5</code>可以一键执行代码</li></ul><h3 id="多窗口操作"><a href="#多窗口操作" class="headerlink" title="多窗口操作"></a>多窗口操作</h3><ol><li>使用<code>:sp + 文件名</code>可以水平分割窗口</li></ol><ul><li>使用<code>:vs + 文件名</code>可以垂直分割窗口</li><li>使用<code>Ctrl + w</code>可以快速在窗口间切换</li></ul><h3 id="编写markdown文件"><a href="#编写markdown文件" class="headerlink" title="编写markdown文件"></a>编写markdown文件</h3><ol><li>编写markdown文件(<code>*.md</code>)的时候，在normal模式下按 <code>md</code> 即可在当前目录下生成相应的<code>html</code>文件</li></ol><ul><li>生成之后还是在normal模式按<code>fi</code>可以使用firefox打开相应的<code>html</code>文件预览</li><li>当然也可以使用万能的<code>F5</code>键来一键转换并打开预览</li><li>如果打开过程中屏幕出现一些混乱信息，可以按<code>Ctrl + l</code>来恢复</li></ul><h3 id="快速注释"><a href="#快速注释" class="headerlink" title="快速注释"></a>快速注释</h3><ul><li>按<code>\</code> 可以根据文件类型自动注释</li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis Cookbook 之 基于Redis 实现Oauth协议</title>
      <link href="2014/08/11/2014-08-11-Redis-Cookbook-Implementing-OAuth/"/>
      <url>2014/08/11/2014-08-11-Redis-Cookbook-Implementing-OAuth/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a id="Problem">问题</a></h2><p>在我们案例里，我们将实现一个数据模型和交互来支持Oauth v1.0a API。一般常常是基于MySQL或者其他的RDBMS实现，但是我们可以利用Redis的数据结构更高效的实现Oauth协议。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><a id="Solution">解决方法</a></h2><p>我们不会去实现Oauth的API或者交互。这里我们仅仅感兴趣的是这种类型场景里所需要的数据。我们将在Redis里面存储五种类型的数据：</p><ul><li>consumer keys</li><li>consumer secrets</li><li>request tokens</li><li>access tokens</li><li>nonces</li></ul><p> 所以我们的需求如下：通过一对<code>key</code>和<code>secret</code>标识的应用（客户）。这些客户根据他们的需求会有许多次的请求和访问token，并且每个用户/时间戳对是唯一的。</p><p>根据他们的要求和交互情况，这种类型的数据可以被存储在<code>hashes</code>、<code>sets</code>和<code>strings</code>。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a><a id="Discussion">讨论</a></h2><h3 id="初始设置"><a href="#初始设置" class="headerlink" title="初始设置"></a>初始设置</h3><p>一开始，在客户发出一个请求之前，他们必须输入他们的数据。我们将这个数据和客户信息放入hash中。当他注册我们系统的时候，key是我们为特定的商户存储的数据之一：</p><span id="more"></span><pre><code>HMSET /consumers/key:dpf43f3p2l4k3l03 secret kd94hf93k423kf44 created_at 201103060000 redirect_url http://www.example.com/oauth_redirect name test_application</code></pre><p>   如同命令所示，这个hash包含它的正常的数据，并且可以随着时间进行扩展。这样，和Memcache一样，或者以不同的keys来存储所有的值，或者存储像JSON一样的数据。</p><pre><code>HSET hash-name key value    Sets a value on a hash with the given key. As with other Redis commands, if the hash doesn’t exist, it’s created.    HMSET hash-name key1 value1 [key2 value2 ...]    Allows you to set several values in a hash with a single command</code></pre><h3 id="获取一个请求token"><a href="#获取一个请求token" class="headerlink" title="获取一个请求token"></a>获取一个请求token</h3><p>为了获取一个请求token，客户发送他们的key、时间戳、唯一生成随机数、回调url和一个请求的签名（使用客户的secret对请求路径和参数hash计算结果）。</p><p>API提供者需要验证签名是否正确，检查随机数/时间戳在之前是否使用过，并且生成一个新的请求token。</p><p>为了做到这样，server需要获取客户的数据：</p><pre><code>HGETALL /consumers/key:dpf43f3p2l4k3l03</code></pre><p>然后检查这个随机数是否以前使用过：</p><pre><code>SADD /nonces/key:dpf43f3p2l4k3l03/timestamp:20110306182600 dji430splmx33448</code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> Redis Cookbook </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis Cookbook 之 Redis数据类型</title>
      <link href="2014/08/10/2014-08-10-Redis-CookBook-Redis-Data-Types/"/>
      <url>2014/08/10/2014-08-10-Redis-CookBook-Redis-Data-Types/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a id="Problem">问题</a></h2><p>首先，你需要了解<code>Redis</code>的数据类型，这样才能够为特定的应用提供更好的<code>Redis</code>使用方式和性能。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><a id="Solution">解决方法</a></h2><p>和大部分其他的<code>NoSQL</code>方案和<code>key-value</code>存储引擎不同，<code>Redis</code>包含一些内建的数据类型，允许开发者可以使用有意义的语义方式来构建他们的数据。在<code>Redis</code>内部操作指定类型的数据时，预定义的数据类型一般会比外部定义数据类型要操作更快。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a><a id="Discussion">讨论</a></h2><p>在我们深入特定的数据类型之前，先来了解一些在设计<code>Key</code>数据结构的时候需要关注的事情：</p><ul><li>定义<code>key</code>空间时需要一致。由于一个key可以包含任意的字符，你可以使用分隔符去为自己的业务定义有意义的命名。例如：<code> cache:project:319:tasks</code>，每一个冒号就是一个命名分隔符。</li><li>当定义自己的<code>key</code>时，尝试限制合适的大小。从存储中检索一个key是需要比较操作的，所以保证<code>key</code>长度足够的小是一个很好的建议。此外，更小的<code>key</code>长度还会节省内存的使用。</li><li>即使<code>key</code>不能够特别的大，但是保持特别小的<code>key</code>并不会带来非常大的性能提升。这意味着，你设计自己的<code>key</code>时需要综合考虑<code>key</code>的易读性和正常的键长度。</li></ul><p>因此，当键设计成<code>c:p:319:t</code>或者<code>user 123</code>是相当失败的，前面一个可读性很差，后面一个包含空格。另一方面，像<code>cache:project:319:tasks</code>，<code>lastchatmessage</code>，<code>464A1E96B2D217EBE87449FA8B70E6C7D112560C</code>的<code>key</code>都是很好的，因为他们都是有语义的词（最后一个是SHA1哈希值，虽然很难猜测他的语义，但是这对于存储了对应的对象，你就可以计算出hash值了）。</p><span id="more"></span><h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><p>这是<code>Redis</code>里面最简单的数据类型：字符串。<code>Strings</code>也是其他<code>key-value</code>存储引擎中典型的数据类型。你可以存储任意类型的字符串，包括二进制数据。比如：你可能想要为<code>社交网络中的头像</code>缓存图片数据。你需要考虑的唯一一件事情就是在<code>Redis</code>里面不允许特定的值大小超过<code>512M</code>。</p><h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>在<code>Redis</code>存储里面，<code>  Lists</code>是一个有序的二进制安全的字符串列表，使用<code>linked list</code>来实现。这意外者，当通过一个指定的索引获取元素的时候，会是一个很慢的操作，但是在这个数据结构的头部或者尾部增加元素是非常快的。你可能想要基于<code>Lists</code>去实现<code>queues</code>之类的数据结构。关于这点，后文会说到。</p><h3 id="Hashes"><a href="#Hashes" class="headerlink" title="Hashes"></a>Hashes</h3><p>和传统的hash表很像，在<code>Redis</code>中<code>hashes</code>在特定的key里面存储一些<code>fields</code>和他们对应的值。<code>hashes</code>是需要映射复杂对像的完美选项，通过使用对象属性的<code>fields</code>（比如一个对象有多个属性：“color”,“brand”, “license plate”）。</p><h3 id="Sets-and-Sorted-Sets"><a href="#Sets-and-Sorted-Sets" class="headerlink" title="Sets and Sorted Sets"></a>Sets and Sorted Sets</h3><p>在<code>Redis</code>中，<code>sets</code>是一个无序的二进制安全的字符串集合。在给定的<code>set</code>中是不存在重复的元素的。比如，当你尝试在一个<code>set</code>中添加两次<code>wheel</code>时，<code>Redis</code>会忽略第二次插入操作。<code>sets</code>允许你执行传统语言中<code>set</code>的相关操作，比如获取集合的交集和并集。</p><p>虽然这个和<code>lists</code>看起来很相似，但是他们实现是非常不同的，并且由于他们不同的特性而决定适应不同的应用需求。此外，set的内存占用要比<code>lists</code>高一些。</p><p><code>Sorted sets</code>是<code>sets</code>的特例，通过定义<code>score</code>来实现排序，此外也是经典的二进制安全字符串。这个<code>score</code>允许你通过使用<code>ZRANGE</code>命令查询一个有序的元素列表。后面，会介绍一些关于<code>sets and sorted sets</code>的使用实例。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> Redis Cookbook </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis Cookbook 之 Redis 键值对存储服务</title>
      <link href="2014/08/10/2014-08-10-Redis-Cookbook-Redis-KeyValue-Store/"/>
      <url>2014/08/10/2014-08-10-Redis-Cookbook-Redis-KeyValue-Store/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a id="Problem">问题</a></h2><p>许多的应用服务都需要存储关于使用，配置或者其他相关的信息的临时数据，这些数据结构并不适合存储在关系数据库中。<br>通常情况下，开发者会是MySQL或者其他RDBMS来存储这种数据。在这里，我们将使用Redis和它内建的数据结构，以一种更轻量级、更快速、更宽松的方式完成存储应用临时数据的功能。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><a id="Solution">解决方法</a></h2><p>Redis本身的定位并不仅仅是<code>key/value</code>存储服务，同时也可以作为存储数据结构的服务器。这意味着，在传统的<code>key/value</code>存储功能之上，它还提供给你一些存储和操作应用数据的方式。<br>我们将使用这些数据结构和命令来存储应用示例数据：比如，我们在一些<code>regular keys</code>里面存储有用的计数器，在<code>Redis hashes</code>里面存储用户对象，以及使用<code>sets</code>实现朋友圈（像Google+）。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a><a id="Discussion">讨论</a></h2><h3 id="存储应用使用计数器"><a href="#存储应用使用计数器" class="headerlink" title="存储应用使用计数器"></a>存储应用使用计数器</h3><p>首先，让我们开始存储一些非常基础的事情：计数器。想象我们运营一个商业的社交网络，然后想要追踪<code>profile/page</code>的访问数据。我们可以在RDBMS的存储我们页数据的表里面增加一列，<br>但是希望我们的流量足够高以至于每次更新这一列会带来一些麻烦。因此，我们需要更快的工具来更新和查询，所以我们使用Redis来代替。</p><p>由于Redis命令的原子性，我们知道如果我们存储一个计数器的key，则我们可以使用命令，比如：<code>INCR(或者INCRBY)和DECR(或者DECRBY)</code>，来增加增加或者减少它包含的值。所以，通过为我们的数据设计一个合适的命名保证我们的计数器单次操作成本微乎其微。</p><p>Redis系统内实际上并没有约定的方法来组织keys，但是许多人（包括作者）都喜欢使用<code>冒号：</code>来区分关键字从而创建keys，因此在这里也这样约定。为了存储我们的社交网络页面访问数据，我们可以有一个像<code>visits:pageid:totals</code>的命名，比如页面id为635，则命名为<code>visits:635:totals</code>。如果我们已经在一些地方存储访问数据，我们可以首先根据这些数据产生redis的keys，并且设置对应的值，比如：</p><pre><code>    SET visits:1:totals 21389     SET visits:2:totals 1367894     (...)</code></pre><p>当访问一个给定的页面，一个简单地<code>INCR</code>命令将更新Redis中的计数器：</p><pre><code>    INCR visits:635:totals    </code></pre><p>然后我们可以获取任何页面在任何时候的访问次数，这只需要通过简单地<code>GET</code>命令：</p><pre><code>    GET visits:635:totals    </code></pre><p>你也可以让你的命令更智能，比如你可以在人们查看页面的时候，显示当前该页面被访问的次数给他看。当然，你也可以计算他自己访问的次数，所以你甚至不需要执行最后的<code>GET</code>命令：你可以利用<code>INCR</code>命令返回值的特点，因为<code>INCR</code>命令会返回自增之后的计数值。一个简单地关于访问和计数器的伪代码如下所示：</p><pre><code>    1. 访问者访问页面.    2. 我们 INCR 相关页面的访问计数器 (比如：INCR visits:635:totals）        3. 我们获取INCR命令的返回值。    4. 我们展示返回的值在用户页面上。</code></pre><p>这种方式我们保证用户在查看页面的时候，常常可以看见实时计数值，以及他自己访问的计数–着所有都可以使用Redis命令。</p><span id="more"></span><h3 id="存储对象数据在hashes内"><a href="#存储对象数据在hashes内" class="headerlink" title="存储对象数据在hashes内"></a>存储对象数据在hashes内</h3><p>Redis关于hashes的实现对于存储对象数据应用来说是一个很好的方案。在下面的例子里，我们将调查我们怎样使用<code>hashes</code>来在给定系统上存储用户相关的信息。</p><p>我们将开始设计一个key命名来存储我们的用户。在此之前，我们使用分号来分割我们的关键字，进而产生意义丰富的key。为了达到这个案例的目的，我们将构建一个简单的key，形如：<code>users:alias</code>，其中<code>alias</code>是二进制安全的字符串。所以，为了存储一个叫做<code>John Doe</code>的用户，我们将建一个hash叫做<code>users:jdoe</code>。</p><p>我们也假设我们将要存储关于用户的许多属性，比如全名、邮件地址、电话号码、以及访问我们英语的次数。我们将使用Redis的<code>hash管理命令</code>–像<code>HSET</code>、<code>HGET</code>和<code>HINCRBY</code>–存储用户的这些信息。</p><pre><code>    redis&gt; hset users:jdoe name &quot;John Doe&quot;     (integer) 1        redis&gt; hset users:jdoe email &quot;jdoe@test.com&quot;     (integer) 1        redis&gt; hset users:jdoe phone &quot;+1555313940&quot;     (integer) 1        redis&gt; hincrby users:jdoe visits 1     (integer) 1</code></pre><p>随着我们hash的建立，我们可以在合适的地方通过<code>HGET</code>获取简单地属性值或者通过<code>HGETALL</code>命令所有hash对象数据，如同下面的示例：</p><pre><code>    redis&gt; hget users:jdoe email     &quot;jdoe@test.com&quot;    redis&gt; hgetall users:jdoe    1) &quot;name&quot;    2) &quot;John Doe&quot;    3) &quot;email&quot;    4) &quot;jdoe@test.com&quot; 5) &quot;phone&quot;    6) &quot;+1555313940&quot; 7) &quot;visits&quot;    8) &quot;1&quot;</code></pre><p>还有辅助的命令，比如<code>HKEYS</code>，该命令返回一个特定的hash里面存储的所有keys；<code>HVALS</code>，该命令仅仅返回values。当从你应用的Redis中检索数据时，你可能会发现使用<code>HGETALL</code>或者其他命令很有用，这其实取决于你想怎样检索你的数据。</p><pre><code>    redis&gt; hkeys users:jdoe     1) &quot;name&quot;    2) &quot;email&quot;    3) &quot;phone&quot;    4) &quot;visits&quot;    redis&gt; hvals users:jdoe     1) &quot;John Doe&quot;    2) &quot;jdoe@test.com&quot;    3) &quot;+1555313940&quot;    4) &quot;1&quot;</code></pre><p>关于我们用户hash的其他命令列表，你可以详细阅读 <code>Redis official documentation for hash commands</code>，这里面包含他自己的使用<code>hashes</code>管理数据的示例。</p><h3 id="使用sets存储用户的朋友圈"><a href="#使用sets存储用户的朋友圈" class="headerlink" title="使用sets存储用户的朋友圈"></a>使用sets存储用户的朋友圈</h3><p>为了完成Redis特有的方式存储数据，我们看看怎么样使用Redis支持的sets来创建和google+相似的朋友圈功能。sets天生就适应朋友圈，因为sets代码数据的集合，并且有一些天生的功能来做一些有趣的事情，比如交集和并集。</p><p>首先，让我们定义一个朋友圈的命名。我们想要为我们每一个用户存储一些朋友圈，所以我们的key需要包含用户和实际的朋友圈。举个例子，<code>John Doe</code>的家庭圈可能有一个key像<code>circle:jdoe:family</code>样子。相似地，他的足球训练朋友可能在key为<code>circle:jdoe:soccer</code>的set里面。这里没有key设计的设置规则，所以常常以一种对我们应用有意义的方式来设计它们。</p><p>现在，我们知道存储我们sets里面的keys，接下来，我们来创建<code>John Doe</code>的家庭集和足球朋友集。在集合本身里面，我们可以通过用户id来获取Redis里其他的keys。如果我们想要获取属于<code>John Doe</code>家庭圈用户的列表，和它们的用户信息，我们可以使用我们set的操作结果，然后为每一个用户提取真实的hashes（使用hashes来存储用户信息）。</p><pre><code>    redis&gt; sadd circle:jdoe:family users:anna     (integer) 1    redis&gt; sadd circle:jdoe:family users:richard    (integer) 1         redis&gt; sadd circle:jdoe:family users:mike    (integer) 1         redis&gt; sadd circle:jdoe:soccer users:mike    (integer) 1         redis&gt; sadd circle:jdoe:soccer users:adam    (integer) 1         redis&gt; sadd circle:jdoe:soccer users:toby    (integer) 1         redis&gt; sadd circle:jdoe:soccer users:apollo    (integer) 1    </code></pre><p>需要记住的是，在上面的例子里，我们需要规范化我们set的成员通过使用实际的id数值而不是<code> users:name</code>。虽然上面的例子工作得很好，但它可能为了性能原因牺牲一些可读性而获取更快的速度和更高的内存使用效率。</p><p>现在我们有一个set叫做<code>circle:jdoe:family</code>,带有三个值（分别是：users:anna, users:richard, and users:mike），第二个叫做<code>    circle:jdoe:soccer</code>,带有四个值（分别是：users:mike, users:adam, users:toby, and users:apollo）。它们的值仅仅只是字符串，但是通过使用字符串对我们来说是有意义的（这和我们设计用户的hashes很相似），我们可以使用<code>SMEMBERS</code>命令的结果进而获取特点用户的信息。如下面的例子：</p><pre><code>    redis&gt; smembers circle:jdoe:family     1) &quot;users:richard&quot;    2) &quot;users:mike&quot;    3) &quot;users:anna&quot;    redis&gt; hgetall users:mike     (...)</code></pre><p>现在，我们已经知道了怎么在sets里面存储信息了，我们可以扩展这个只是，做一些有趣的事情，比如获取属于这两个sets里面的人，或者获取一个<code>John Doe</code>添加到我们系统朋友圈中的完整的用户列表。</p><pre><code>    redis&gt; sinter circle:jdoe:family circle:jdoe:soccer     1) &quot;users:mike&quot;    redis&gt; sunion circle:jdoe:family circle:jdoe:soccer     1) &quot;users:anna&quot;    2) &quot;users:mike&quot;    3) &quot;users:apollo&quot;     4) &quot;users:adam&quot;    5) &quot;users:richard&quot;     6) &quot;users:toby&quot;</code></pre><p>根据我们的结果，<code>Mike</code>在<code>John Doe</code>的家庭圈和足球圈里面，通过两个圈的并集，我们也可以获取完整地成员列表。</p><p>如你所见，Redis sets使得RDBMS一些查询变得非常简单。Redis完成得非常的快，使得对于那些管理集合操作的应用来说，<code>Redis sets</code>是一个理想的候选者。朋友圈就是一个例子，此外像 推荐或者甚至文本搜素也很适合。在随后的案例里面，将会看到更深入的例子。</p><pre><code>SET key value    Sets the key to hold the given value. Existing data is overwritten (even if of a dif- ferent data type).    GET key    Returns the content held by the key. Works only with string values.INCR key    Increments the integer stored at key by 1.INCRBY key value    Performs the same operation as INCR, but incrementing by value instead.    DECR key    Decrements the integer stored at key by 1.DECRBY key value    Performs the same operation as DECR, but decrementing by value instead</code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> Redis Cookbook </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Python操作线上数据库脚本</title>
      <link href="2014/07/03/2014-07-03-Query-DB-Python-Shell/"/>
      <url>2014/07/03/2014-07-03-Query-DB-Python-Shell/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>最近对于线上一些数据需要进行过滤导到本地来，或者对一些运营人员给的文本数据，需要在线上数据库跑出对应的结果出来，因此，需要通过一个脚本来执行。因为，现在服务器基本上会默认安装python，所以这里存一份脚本备用。</p><h2 id="Python脚本"><a href="#Python脚本" class="headerlink" title="Python脚本"></a><a id="Script">Python脚本</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os;</span><br><span class="line"><span class="keyword">import</span> MySQLdb;</span><br><span class="line"><span class="keyword">import</span> sys;</span><br><span class="line">reload(sys) </span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">file=<span class="built_in">open</span>(<span class="string">&quot;hotelseq.txt&quot;</span>)</span><br><span class="line">outfile=<span class="built_in">open</span>(<span class="string">&quot;customer.txt&quot;</span>,<span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line">conn=MySQLdb.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>,user=<span class="string">&#x27;root&#x27;</span>,passwd=<span class="string">&#x27;123456&#x27;</span>,db=<span class="string">&#x27;test&#x27;</span>,port=<span class="number">3306</span>,charset=<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">cur=conn.cursor()</span><br><span class="line">order_cur = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    line=file.readline().strip()</span><br><span class="line">    <span class="built_in">print</span> line</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    count=cur.execute(<span class="string">&quot;select cus.customer_state,cus.name from crm_customer_hotel as hotel join crm_customer as cus on hotel.customer_serial_number=cus.serial_number where hotel.hotel_seq=&#x27;%s&#x27;&quot;</span> % line)</span><br><span class="line">    result = cur.fetchone()</span><br><span class="line">    <span class="built_in">print</span> result</span><br><span class="line">    <span class="keyword">if</span> result:</span><br><span class="line">        outfile.write(<span class="built_in">str</span>(result[<span class="number">0</span>])+<span class="string">&quot;  &quot;</span>+result[<span class="number">1</span>])</span><br><span class="line">        outfile.write(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">cur.close()</span><br><span class="line">file.close()</span><br><span class="line">outfile.close()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Script </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用快捷键（备用）</title>
      <link href="2014/06/27/2014-06-27-Intelij-IDEA-Keymap/"/>
      <url>2014/06/27/2014-06-27-Intelij-IDEA-Keymap/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>Intelij IDEA一些快捷键和 Eclipse不同，所以对一些快捷键进行记录，备查。</p><h2 id="Idea-快捷键"><a href="#Idea-快捷键" class="headerlink" title="Idea 快捷键"></a><a id="Keymap">Idea 快捷键</a></h2><h3 id="视图快捷键"><a href="#视图快捷键" class="headerlink" title="视图快捷键"></a>视图快捷键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">快速查看方法注释文档          Ctrl + Q</span><br><span class="line"></span><br><span class="line">快速查询类名                   Ctrl + N</span><br><span class="line"></span><br><span class="line">快速查询文件名                Ctrl + Shift + N</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编辑快捷键"><a href="#编辑快捷键" class="headerlink" title="编辑快捷键"></a>编辑快捷键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">代码生成快捷键                Alt + Insert</span><br><span class="line"></span><br><span class="line">自动跳转测试Test类            Alt + T</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Sublime-快捷键"><a href="#Sublime-快捷键" class="headerlink" title="Sublime 快捷键"></a><a id="Sublime">Sublime 快捷键</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">选择多行操作                          Ctrl + Shift + L</span><br><span class="line"></span><br><span class="line">选择单词操作，多次往下移              Ctrl + D</span><br><span class="line"></span><br><span class="line">选择一行操作，重复选择下一行          Ctrl + L</span><br><span class="line"></span><br><span class="line">注释当前行                            Ctrl + / </span><br><span class="line"></span><br><span class="line">从当前位置开始注释                    Ctrl + Shift + /</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解软件包的配置、编译与安装</title>
      <link href="2014/06/24/2014-06-24-Linux-Software-Install-Understand/"/>
      <url>2014/06/24/2014-06-24-Linux-Software-Install-Understand/</url>
      
        <content type="html"><![CDATA[<p>说明：来自互联网，如有版权问题，请告知本人将其撤下。</p><p>来源：<a href="http://works.jinbuguo.com/linux/understand_package_install.htm">http://works.jinbuguo.com/linux/understand_package_install.htm</a>l</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>从源代码安装过软件的朋友一定对 <code>./configure &amp;&amp; make &amp;&amp; make install</code> 安装三步曲非常熟悉了。然而究竟这个过程中的每一步幕后都发生了些什么呢？本文将带领你一探究竟。深入理解这个过程将有助于你在LFS的基础上玩出自己的花样来。不过需要说明的是本文对 <code>Makefile</code> 和 <code>make</code> 的讲解是相当近视和粗浅的，但是对于理解安装过程来说足够了。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><a id="About">概述</a></h2><p>用一句话来解释这个过程就是：</p><p>根据源码包中 Makefile.in 文件的指示，configure 脚本检查当前的系统环境和配置选项，在当前目录中生成 <code>Makefile</code> 文件(还有其它本文无需关心的文件)，然后 <code>make</code> 程序就按照当前目录中的 Makefile 文件的指示将源代码编译为二进制文件，最后将这些二进制文件移动(即安装)到指定的地方(仍然按照 <code>Makefile</code> 文件的指示)。</p><p>由此可见 Makefile 文件是幕后的核心。要深入理解安装过程，必须首先对 <code>Makefile</code> 文件有充分的了解。本文将首先讲述 <code>Makefile</code> 与 <code>make</code> ，然后再讲述 <code>configure</code> 脚本。并且在讲述这两部分内容时，提供了尽可能详细的、可以运用于实践的参考资料。</p><h2 id="Makefile-与-make"><a href="#Makefile-与-make" class="headerlink" title="Makefile 与 make"></a><a id="Make">Makefile 与 make</a></h2><p>用一句话来概括<code>Makefile</code> 与 <code>make</code> 的关系就是：</p><p><code>Makefile</code> 包含了所有的规则和目标，而 <code>make</code> 则是为了完成目标而去解释 <code>Makefiel</code> 规则的工具。</p><span id="more"></span><h3 id="make-语法"><a href="#make-语法" class="headerlink" title="make 语法"></a>make 语法</h3><p>首先看看 <code>make</code> 的命令行语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">make [options] [targets] [VAR=VALUE]...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>[options]</code>是命令行选项，可以用 <code>make --help</code> 命令查看全部，<code>[VAR=VALUE]</code>是在命令行上指定环境变量，这两个大家都很熟悉，将在稍后详细讲解。而<code>[targets]</code>是什么呢？字面的意思是”目标”，也就是希望本次 make 命令所完成的任务。凭经验猜测，这个<code>[targets]</code>大概可以用”check”,”install”之类(也就是常见的测试和安装命令)。但是它到底是个啥玩意儿？不带任何”目标”的 <code>make</code> 命令是什么意思？为什么在安装 LFS 工具链中的 Perl-5.8.8 软件包时会出现”make perl utilities”这样怪异的命令？要回答这些问题必须首先理解 <code>Makefile</code> 文件中的”规则”。</p><h3 id="Makefile-规则"><a href="#Makefile-规则" class="headerlink" title="Makefile 规则"></a>Makefile 规则</h3><p>Makefile 规则包含了文件之间的依赖关系和更新此规则目标所需要的命令。</p><p>一个简单的 Makefile 规则是这样写的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TARGET : PREREQUISITES</span><br><span class="line">COMMAND</span><br><span class="line">TARGET</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>规则的目标。也就是可以被 make 使用的”目标”。有些目标可以没有依赖而只有动作(命令行)，比如”clean”，通常仅仅定义一系列删除中间文件的命令。同样，有些目标可以没有动作而只有依赖，比如”all”，通常仅仅用作”终极目标”。</p><p><code>PREREQUISITES</code><br>规则的依赖。通常一个目标依赖于一个或者多个文件。</p><p><code>COMMAND</code><br>规则的命令行。一个规则可以有零个或多个命令行。</p><p>OK! 现在你明白[targets]是什么了，原来它们来自于 <code>Makefile</code> 文件中一条条规则的目标(TARGET)。另外，<code>Makefile</code>文件中第一条规则的目标被称为”终极目标”，也就是你省略[targets]参数时的目标(通常为”all”)。</p><p>当你查看一个实际的 <code>Makefile</code> 文件时，你会发现有些规则非常复杂，但是它都符合规则的基本格式。此外，<code>Makefile</code> 文件中通常还包含了除规则以外的其它很多东西，不过本文只关心其中的变量。</p><h3 id="Makefile-实例"><a href="#Makefile-实例" class="headerlink" title="Makefile 实例"></a>Makefile 实例</h3><p>下面看一个简单的、实际的 <code>Makefile</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CC=gcc</span><br><span class="line">CPPFLAGS=</span><br><span class="line">CFLAGS=-O2 -pipe</span><br><span class="line">LDFLAGS=-s</span><br><span class="line">PREFIX=/usr</span><br><span class="line"></span><br><span class="line">all : prog1 prog2</span><br><span class="line"></span><br><span class="line">prog1 : prog1.o</span><br><span class="line">$(CC) $(LDFLAGS) -o prog1 prog1.o</span><br><span class="line"></span><br><span class="line">prog1.o : prog1.c</span><br><span class="line">$(CC) -c $(CFLAGS) prog1.c</span><br><span class="line"></span><br><span class="line">prog2 : prog2.o</span><br><span class="line">$(CC) $(CFLAGS) $(LDFLAGS) -o prog2 prog2.o</span><br><span class="line"></span><br><span class="line">prog2.o : prog2.c</span><br><span class="line">$(CC) -c $(CPPFLAGS) $(CFLAGS) prog2.c</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">rm -f *.&#123;o,a&#125; prog&#123;1,2&#125;</span><br><span class="line"></span><br><span class="line">install : prog1 prog2</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">test</span> ! -d $(PREFIX)/bin ) ; <span class="keyword">then</span> mkdir -p $(PREFIX)/bin ; <span class="keyword">fi</span></span><br><span class="line">cp -f prog1 $(PREFIX)/bin/prog1</span><br><span class="line">cp -f prog2 $(PREFIX)/bin/prog2</span><br><span class="line"></span><br><span class="line">check <span class="built_in">test</span> : prog1 prog2</span><br><span class="line">prog1 &lt; sample1.ref &gt; sample1.rz</span><br><span class="line">prog1 &lt; sample2.ref &gt; sample3.rz</span><br><span class="line">cmp sample1.ok sample1.rz</span><br><span class="line">cmp sample2.ok sample2.rz</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从中可以看出，<code>make</code> 与 <code>make all</code> 以及 <code>make prog1 prog2</code> 三条命令其实是等价的。而常用的 <code>make check</code> 和 <code>make install</code> 也找到了归属。同时我们也看到了 Makefile 中的各种变量是如何影响编译的。针对这个特定的 Makefile ，你甚至可以省略安装三步曲中的 make 命令而直接使用<code> make install</code> 进行安装。</p><p>同样，为了使用自定义的编译参数编译 prog2 ，我们可以使用 <code>make prog2 CFLAGS=&quot;-O3 -march=athlon64&quot;</code> 或 <code>CFLAGS=&quot;-O3 -march=athlon64&quot; &amp;&amp; make -e prog2</code> 命令达到此目的。</p><h3 id="Makefile-惯例"><a href="#Makefile-惯例" class="headerlink" title="Makefile 惯例"></a>Makefile 惯例</h3><p>下面是Makefile中一些约定俗成的目标名称及其含义：</p><p><code>all</code><br>编译整个软件包，但不重建任何文档。一般此目标作为默认的终极目标。此目标一般对所有源程序的编译和连接使用”-g”选项，以使最终的可执行程序中包含调试信息。可使用 strip 程序去掉这些调试符号。</p><p><code>clean</code><br>清除当前目录下在 make 过程中产生的文件。它不能删除软件包的配置文件，也不能删除 build 时创建的那些文件。</p><p><code>distclean</code><br>类似于”clean”，但增加删除当前目录下的的配置文件、build 过程产生的文件。</p><p><code>info</code><br>产生必要的 Info 文档。</p><p><code>check 或 test</code><br>完成所有的自检功能。在执行检查之前，应确保所有程序已经被创建(但可以尚未安装)。为了进行测试，需要实现在程序没有安装的情况下被执行的测试命令。</p><p><code>install</code><br>完成程序的编译并将最终的可执行程序、库文件等拷贝到指定的目录。此种安装一般不对可执行程序进行 strip 操作。</p><p><code>install-strip</code><br>和”install”类似，但是会对复制到安装目录下的可执行文件进行 strip 操作。</p><p><code>uninstall</code><br>删除所有由”install”安装的文件。</p><p><code>installcheck</code><br>执行安装检查。在执行安装检查之前，需要确保所有程序已经被创建并且被安装。</p><p><code>installdirs</code><br>创建安装目录及其子目录。它不能更改软件的编译目录，而仅仅是创建程序的安装目录。</p><p>下面是 Makefile 中一些约定俗成的变量名称及其含义：</p><p>这些约定俗成的变量分为三类。第一类代表可执行程序的名字，例如 CC 代表编译器这个可执行程序；第二类代表程序使用的参数(多个参数使用空格分开)，例如 CFLAGS 代表编译器执行时使用的参数(一种怪异的做法是直接在 CC 中包含参数)；第三类代表安装目录，例如 prefix 等等，含义简单，下面只列出它们的默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AR   函数库打包程序，可创建静态库.a文档。默认是<span class="string">&quot;ar&quot;</span>。</span><br><span class="line">AS   汇编程序。默认是<span class="string">&quot;as&quot;</span>。</span><br><span class="line">CC   C编译程序。默认是<span class="string">&quot;cc&quot;</span>。</span><br><span class="line">CXX  C++编译程序。默认是<span class="string">&quot;g++&quot;</span>。</span><br><span class="line">CPP  C/C++预处理器。默认是<span class="string">&quot;<span class="subst">$(CC)</span> -E&quot;</span>。</span><br><span class="line">FC   Fortran编译器。默认是<span class="string">&quot;f77&quot;</span>。</span><br><span class="line">PC   Pascal语言编译器。默认是<span class="string">&quot;pc&quot;</span>。</span><br><span class="line">YACC Yacc文法分析器。默认是<span class="string">&quot;yacc&quot;</span>。</span><br><span class="line"></span><br><span class="line">ARFLAGS     函数库打包程序的命令行参数。默认值是<span class="string">&quot;rv&quot;</span>。</span><br><span class="line">ASFLAGS     汇编程序的命令行参数。</span><br><span class="line">CFLAGS      C编译程序的命令行参数。</span><br><span class="line">CXXFLAGS    C++编译程序的命令行参数。</span><br><span class="line">CPPFLAGS    C/C++预处理器的命令行参数。</span><br><span class="line">FFLAGS      Fortran编译器的命令行参数。</span><br><span class="line">PFLAGS      Pascal编译器的命令行参数。</span><br><span class="line">YFLAGS      Yacc文法分析器的命令行参数。</span><br><span class="line">LDFLAGS     链接器的命令行参数。</span><br><span class="line"></span><br><span class="line">prefix      /usr/<span class="built_in">local</span></span><br><span class="line">exec_prefix $(prefix)</span><br><span class="line">bindir      $(exec_prefix)/bin</span><br><span class="line">sbindir     $(exec_prefix)/sbin</span><br><span class="line">libexecdir  $(exec_prefix)/libexec</span><br><span class="line">datadir     $(prefix)/share</span><br><span class="line">sysconfdir  $(prefix)/etc</span><br><span class="line">sharedstatedir $(prefix)/com</span><br><span class="line">localstatedir  $(prefix)/var</span><br><span class="line">libdir      $(exec_prefix)/lib</span><br><span class="line">infodir     $(prefix)/info</span><br><span class="line">includedir  $(prefix)/include</span><br><span class="line">oldincludedir  $(prefix)/include</span><br><span class="line">mandir      $(prefix)/man</span><br><span class="line">srcdir      需要编译的源文件所在的目录，无默认值</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="make-选项"><a href="#make-选项" class="headerlink" title="make 选项"></a>make 选项</h3><p>最后说说 make 的命令行选项(以Make-3.81版本为准)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`-B, --always-make`</span><br><span class="line">无条件的重建所有规则的目标，而不是根据规则的依赖关系决定是否重建某些目标文件。</span><br><span class="line"></span><br><span class="line">`-C DIR, --directory=DIR`</span><br><span class="line">在做任何动作之前先切换工作目录到 DIR ，然后再执行 make 程序。</span><br><span class="line"></span><br><span class="line">`-d`</span><br><span class="line">在 make 执行过程中打印出所有的调试信息。包括：make 认为那些文件需要重建；那些文件需要比较它们的最后修改时间、比较的结果；重建目标所要执行的命令；使用的隐含规则等。使用该选项我们可以看到 make 构造依赖关系链、重建目标过程的所有信息，它等效于&quot;-debug=a&quot;。</span><br><span class="line"></span><br><span class="line">`--debug=FLAGS`</span><br><span class="line">    在 make 执行过程中打印出调试信息。FLAGS 用于控制调试信息级别：</span><br><span class="line">    a 输出所有类型的调试信息</span><br><span class="line">    b 输出基本调试信息。包括：那些目标过期、是否重建成功过期目标文件。</span><br><span class="line">    v 除 b 级别以外还包括：解析的 makefile 文件名，不需要重建文件等。</span><br><span class="line">    i 除 b 级别以外还包括：所有使用到的隐含规则描述。</span><br><span class="line">    j 输出所有执行命令的子进程，包括命令执行的 PID 等。</span><br><span class="line">    m 输出 make 读取、更新、执行 makefile 的信息。</span><br><span class="line"></span><br><span class="line">`-e, --environment-overrides`  </span><br><span class="line">使用系统环境变量的定义覆盖 Makefile 中的同名变量定义。</span><br><span class="line"></span><br><span class="line">`-f FILE, --file=FILE, --makefile=FILE`  </span><br><span class="line">将 FILE 指定为 Makefile 文件。</span><br><span class="line"></span><br><span class="line">`-h, --help`  </span><br><span class="line">打印帮助信息。</span><br><span class="line"></span><br><span class="line">`-i, --ignore-errors`  </span><br><span class="line">忽略规则命令执行过程中的错误。</span><br><span class="line"></span><br><span class="line">`-I DIR, --include-dir=DIR`  </span><br><span class="line">指定包含 Makefile 文件的搜索目录。使用多个&quot;-I&quot;指定目录时，搜索目录按照指定顺序进行。</span><br><span class="line"></span><br><span class="line">`-j [N], --jobs[=N]`  </span><br><span class="line">指定并行执行的命令数目。在没有指定&quot;-j&quot;参数的情况下，执行的命令数目将是系统允许的最大可能数目。</span><br><span class="line"></span><br><span class="line">`-k, --keep-going`  </span><br><span class="line">遇见命令执行错误时不终止 make 的执行，也就是尽可能执行所有的命令，直到出现致命错误才终止。</span><br><span class="line"></span><br><span class="line">`-l [N], --load-average[=N], --max-load[=N]`  </span><br><span class="line">如果系统负荷超过 LOAD(浮点数)，不再启动新任务。</span><br><span class="line"></span><br><span class="line">`-L, --check-symlink-times`  </span><br><span class="line">同时考察符号连接的时间戳和它所指向的目标文件的时间戳，以两者中较晚的时间戳为准。</span><br><span class="line"> </span><br><span class="line">`-n, --just-print, --dry-run, --recon`  </span><br><span class="line">  只打印出所要执行的命令，但并不实际执行命令。</span><br><span class="line">  </span><br><span class="line">`-o FILE, --old-file=FILE, --assume-old=FILE`  </span><br><span class="line">即使相对于它的依赖已经过期也不重建 FILE 文件；同时也不重建依赖于此文件任何文件。</span><br><span class="line"></span><br><span class="line">`-p, --print-data-base`  </span><br><span class="line">命令执行之前，打印出 make 读取的 Makefile 的所有数据（包括规则和变量的值），同时打印出 make 的版本信息。如果只需要打印这些数据信息，可以使用 make -qp 命令。查看 make 执行前的预设规则和变量，可使用命令 make -p -f /dev/null 。</span><br><span class="line"></span><br><span class="line">`-q, --question`  </span><br><span class="line">&quot;询问模式&quot;。不运行任何命令，并且无输出，只是返回一个查询状态。返回状态为 0 表示没有目标需要重建，1 表示存在需要重建的目标，2 表示有错误发生。</span><br><span class="line"> </span><br><span class="line">`-r, --no-builtin-rules`  </span><br><span class="line">取消所有内嵌的隐含规则，不过你可以在 Makefile 中使用模式规则来定义规则。同时还会取消所有支持后追规则的隐含后缀列表，同样我们也可以在 Makefile 中使用&quot;.SUFFIXES&quot;定义我们自己的后缀规则。此选项不会取消 make 内嵌的隐含变量。</span><br><span class="line"></span><br><span class="line">`-R, --no-builtin-variables`   </span><br><span class="line">取消 make 内嵌的隐含变量，不过我们可以在 Makefile 中明确定义某些变量。注意，此选项同时打开了&quot;-r&quot;选项。因为隐含规则是以内嵌的隐含变量为基础的。</span><br><span class="line"></span><br><span class="line">`-s, --silent, --quiet`  </span><br><span class="line">不显示所执行的命令。</span><br><span class="line"></span><br><span class="line">`-S, --no-keep-going, --stop`  </span><br><span class="line">取消&quot;-k&quot;选项。在递归的 make 过程中子 make 通过 MAKEFLAGS 变量继承了上层的命令行选项。我们可以在子 make 中使用&quot;-S&quot;选项取消上层传递的&quot;-k&quot;选项，或者取消系统环境变量 MAKEFLAGS 中的&quot;-k&quot;选项。</span><br><span class="line"></span><br><span class="line">`-t, --touch`  </span><br><span class="line">更新所有目标文件的时间戳到当前系统时间。防止 make 对所有过时目标文件的重建。</span><br><span class="line"></span><br><span class="line">`-v, --version`  </span><br><span class="line">打印版本信息。</span><br><span class="line"></span><br><span class="line">`-w, --print-directory`  </span><br><span class="line">在 make 进入一个目录之前打印工作目录。使用&quot;-C&quot;选项时默认打开这个选项。</span><br><span class="line"></span><br><span class="line">--no-print-directory </span><br><span class="line">取消&quot;-w&quot;选项。可以是用在递归的 make 调用过程中，取消&quot;-C&quot;参数将默认打开&quot;-w&quot;</span><br><span class="line"></span><br><span class="line">-W FILE, --what-if=FILE, --new-file=FILE, --assume-new=FILE</span><br><span class="line">设定 FILE 文件的时间戳为当前时间，但不改变文件实际的最后修改时间。此选项主要是为实现了对所有依赖于 FILE 文件的目标的强制重建。</span><br><span class="line"></span><br><span class="line">--warn-undefined-variables </span><br><span class="line">在发现 Makefile 中存在对未定义的变量进行引用时给出告警信息。此功能可以帮助我们调试一个存在多级套嵌变量引用的复杂 Makefile 。但是：我们建议在书写 Makefile 时尽量避免超过三级以上的变量套嵌引用。</span><br></pre></td></tr></table></figure><h2 id="configure"><a href="#configure" class="headerlink" title="configure"></a><a id="Configure">configure</a></h2><p>此阶段的主要目的是生成 Makefile 文件，是最关键的运筹帷幄阶段，基本上所有可以对安装过程进行的个性化调整都集中在这一步。</p><p>configure 脚本能够对 Makefile 中的哪些内容产生影响呢？基本上可以这么说：所有内容，包括本文最关心的 Makefile 规则与 Makefile 变量。那么又是哪些因素影响着最终生成的 Makefile 文件呢？答曰：系统环境和配置选项。</p><p>配置选项的影响是显而易见的。但是”系统环境”的概念却很宽泛，包含很多方面内容，不过我们这里只关心环境变量，具体说来就是将来会在 Makefile 中使用到的环境变量以及与 Makefile 中的变量同名的环境变量。</p><h3 id="通用-configure-语法"><a href="#通用-configure-语法" class="headerlink" title="通用 configure 语法"></a>通用 configure 语法</h3><p>在进一步讲述之前，先看看 configure 脚本的语法，一般有两种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">configure [OPTIONS] [VAR=VALUE]...</span><br><span class="line"></span><br><span class="line">configure [OPTIONS] [HOST]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不管是哪种语法，我们都可以用 <code>configure --help</code> 查看所有可用的<code>[OPTIONS]</code>，并且通常在结尾部分还能看到这个脚本所关心的环境变量有哪些。在本文中将对这两种语法进行合并，使用下面这种简化的语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">configure [OPTIONS]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种语法能够被所有的 <code>configure</code> 脚本所识别，同时也能通过设置环境变量和使用特定的<code>[OPTIONS]</code>完成上述两种语法的一切功能。</p><h3 id="通用-configure-选项"><a href="#通用-configure-选项" class="headerlink" title="通用 configure 选项"></a>通用 configure 选项</h3><p>虽然每个软件包的 configure 脚本千差万别，但是它们却都有一些共同的选项，也基本上都遵守相同的选项语法。</p><p><strong>脚本自身选项</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">--<span class="built_in">help</span>  </span><br><span class="line">显示帮助信息。</span><br><span class="line"></span><br><span class="line">--version  </span><br><span class="line">显示版本信息。</span><br><span class="line"></span><br><span class="line">--cache-file=FILE  </span><br><span class="line">在FILE文件中缓存测试结果(默认禁用)。</span><br><span class="line"></span><br><span class="line">--no-create  </span><br><span class="line">configure脚本运行结束后不输出结果文件，常用于正式编译前的测试。</span><br><span class="line"></span><br><span class="line">--quiet, --silent  </span><br><span class="line">不显示脚本工作期间输出的<span class="string">&quot;checking ...&quot;</span>消息。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>目录选项</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">--srcdir=DIR  </span><br><span class="line">源代码文件所在目录，默认为configure脚本所在目录或其父目录。</span><br><span class="line"></span><br><span class="line">--prefix=PREFIX  </span><br><span class="line">体系无关文件的顶级安装目录PREFIX ，默认值一般是 /usr/<span class="built_in">local</span> 或 /usr/<span class="built_in">local</span>/pkgName</span><br><span class="line"></span><br><span class="line">--exec-prefix=EPREFIX  </span><br><span class="line">体系相关文件的顶级安装目录EPREFIX ，默认值一般是 PREFIX</span><br><span class="line"></span><br><span class="line">--bindir=DIR  </span><br><span class="line">用户可执行文件的存放目录DIR ，默认值一般是 EPREFIX/bin</span><br><span class="line"></span><br><span class="line">--sbindir=DIR  </span><br><span class="line">系统管理员可执行目录DIR ，默认值一般是 EPREFIX/sbin</span><br><span class="line"></span><br><span class="line">--libexecdir=DIR  </span><br><span class="line">程序可执行目录DIR ，默认值一般是 EPREFIX/libexec</span><br><span class="line"></span><br><span class="line">--datadir=DIR  </span><br><span class="line">通用数据文件的安装目录DIR ，默认值一般是 PREFIX/share</span><br><span class="line"></span><br><span class="line">--sysconfdir=DIR  </span><br><span class="line">只读的单一机器数据目录DIR ，默认值一般是 PREFIX/etc</span><br><span class="line"></span><br><span class="line">--sharedstatedir=DIR  </span><br><span class="line">可写的体系无关数据目录DIR ，默认值一般是 PREFIX/com</span><br><span class="line"></span><br><span class="line">--localstatedir=DIR  </span><br><span class="line">可写的单一机器数据目录DIR ，默认值一般是 PREFIX/var</span><br><span class="line"></span><br><span class="line">--libdir=DIR  </span><br><span class="line">库文件的安装目录DIR ，默认值一般是 EPREFIX/lib</span><br><span class="line"></span><br><span class="line">--includedir=DIR  </span><br><span class="line">C头文件目录DIR ，默认值一般是 PREFIX/include</span><br><span class="line"></span><br><span class="line">--oldincludedir=DIR  </span><br><span class="line">非gcc的C头文件目录DIR ，默认值一般是 /usr/include</span><br><span class="line"></span><br><span class="line">--infodir=DIR  </span><br><span class="line">Info文档的安装目录DIR ，默认值一般是 PREFIX/info</span><br><span class="line"></span><br><span class="line">--mandir=DIR  </span><br><span class="line">Man文档的安装目录DIR ，默认值一般是 PREFIX/man</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>体系结构选项</strong></p><p>玩交叉编译的朋友对这些选项已经很熟悉了，对于不使用交叉编译的朋友也不必担心，不要理它们就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">--build=BUILD  </span><br><span class="line">工具链当前的运行环境，默认是 config.guess 脚本的输出结果。</span><br><span class="line"></span><br><span class="line">--host=HOST  </span><br><span class="line">编译出的二进制代码将要运行在HOST上，默认值是BUILD。</span><br><span class="line"></span><br><span class="line">--target=TARGET  </span><br><span class="line">编译出的工具链所将来生成的二进制代码要在TARGET上运行，这个选项仅对工具链(也就是GCC和Binutils两者)有意义。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>特性选项</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">--enable-FEATURE  </span><br><span class="line">启用FEATURE特性</span><br><span class="line"></span><br><span class="line">--disable-FEATURE  </span><br><span class="line">禁用FEATURE特性</span><br><span class="line"></span><br><span class="line">--with-PACKAGE[=DIR]  </span><br><span class="line">启用附加软件包PACKAGE，亦可同时指定PACKAGE所在目录DIR</span><br><span class="line"></span><br><span class="line">--without-PACKAGE  </span><br><span class="line">禁用附加软件包PACKAGE</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>通用环境变量</strong></p><p>除了上述通用的选项外，下列环境变量影响着最终生成的 Makefile 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CPP  </span><br><span class="line">C预处理器命令  </span><br><span class="line"></span><br><span class="line">CXXCPP  </span><br><span class="line">C++预处理器命令</span><br><span class="line"></span><br><span class="line">CPPFLAGS  </span><br><span class="line">C/C++预处理器命令行参数</span><br><span class="line"></span><br><span class="line">CC  </span><br><span class="line">C编译器命令</span><br><span class="line"></span><br><span class="line">CFLAGS  </span><br><span class="line">C编译器命令行参数</span><br><span class="line"></span><br><span class="line">CXX  </span><br><span class="line">C++编译器命令</span><br><span class="line"></span><br><span class="line">CXXFLAGS  </span><br><span class="line">C++编译器命令行参数</span><br><span class="line"></span><br><span class="line">LDFLAGS  </span><br><span class="line">连接器命令行参数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至于设置这些环境变量的方法，你可以将它们 <code>export</code> 为全局变量在全局范围内使用，也可以在命令行上使用 <code>[VAR=VALUE]... configure [OPTIONS]</code> 的语法局部使用。此处就不详细描述了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu Chrome启动失败解决方法</title>
      <link href="2014/06/10/2014-06-10-Ubuntu-Chrome-Start-Fail-Resolve/"/>
      <url>2014/06/10/2014-06-10-Ubuntu-Chrome-Start-Fail-Resolve/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>使用<code>Ubuntu</code>系统时，由于系统是默认安装的，所以机器名没有修改成一个合适的名字。在<code>Ubuntu</code>下通过命令<code>sudo vim /etc/hostname</code>来修改成自己想要的命令，然后注销用户，重新进入系统。</p><p>接着，就出现了一个很奇怪的问题，我的桌面上的chrome图标不能点击进入，一直都是无响应状态，但是其他浏览器，比如自带的<code>Firefox</code>就可以正常启动和使用。</p><h2 id="Chrome启动失败解决方法"><a href="#Chrome启动失败解决方法" class="headerlink" title="Chrome启动失败解决方法"></a><a id="Chrome">Chrome启动失败解决方法</a></h2><p>点击<code>chrome</code>图标不管用，并且看不到任何出错信息，无法定位问题出在哪里。只好，从<code>终端</code>使用<code>google-chrome</code>命令来启动<code>chrome</code>浏览器客户端了。于是，出现以下错误信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ketao@ketao-Latitude:~$ google-chrome</span><br><span class="line"></span><br><span class="line">[5901:5901:0610/183033:ERROR:process_singleton_linux.cc(309)] 其他计算机 (ketao-Latitude-E5430-non-vPro) 的另一个 Google Chrome 进程 (7578) 好像正在使用此个人资料。Chrome 已锁定此个人资料以防止其受损。如果您确定其他进程目前未使用此个人资料，请为其解锁并重新启动 Chrome。</span><br><span class="line"></span><br><span class="line">[5901:5901:0610/183033:ERROR:simple_message_box_views.cc(208)] Unable to show a dialog outside the UI thread message loop: Google Chrome - 其他计算机 (ketao-Latitude-E5430-non-vPro) 的另一个 Google Chrome 进程 (7578) 好像正在使用此个人资料。Chrome 已锁定此个人资料以防止其受损。如果您确定其他进程目前未使用此个人资料，请为其解锁并重新启动 Chrome。</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><blockquote><p>Note：显然，上面的错误信息告诉我们，尼玛，<code>chrome</code>会记录我们在计算机上的操作数据在本地，然后我们修改主机名后，导致老数据被锁住了，这样新的主机名下chrome无法获取用户对应的浏览器数据，因此chrome无法正常启动，并且在UI上还无法看到相关错误，导致假死现象出现。</p></blockquote><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>先把本机上的<code>chrome</code>卸载掉，当然这不会把那些被锁定的数据也一并删除掉，不然我也不会写一篇博客记录下。因此，接下来，你需要删除掉自个目录下的残留的<code>chrome</code>用户数据。</p><p>在当前用户目录下面执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ketao@ketao-Latitude:~$ <span class="built_in">cd</span> .config/</span><br><span class="line">ketao@ketao-Latitude:~/.config$ ls</span><br><span class="line">chromium        gedit             monitors.xml     Trolltech.conf</span><br><span class="line">compiz-1        gnome-session     nautilus         ubuntu-ui-toolkit</span><br><span class="line">dconf           google-chrome     pulse            update-notifier</span><br><span class="line">enchant         gtk-2.0           ReText project   upstart</span><br><span class="line">evolution       gtk-3.0           software-center  user-dirs.dirs</span><br><span class="line">fcitx           ibus              SogouPY          user-dirs.locale</span><br><span class="line">fcitx-qimpanel  libaccounts-glib  SogouPY.users    VirtualBox</span><br><span class="line">ketao@ketao-Latitude:~/.config$ rm -rf chromium/</span><br><span class="line">ketao@ketao-Latitude:~/.config$ rm -rf google-chrome/</span><br></pre></td></tr></table></figure><p>然后，重装<code>chrome</code>浏览器，安装成功之后，就可以启动<code>chrome</code>了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><a id="Finally">小结</a></h2><p>一般，如果程序出现问题，通过重装都无法解决的，都是应用在用户目录下面添加来一些配置文件，并且这些文件在应用卸载之后并不会删除，所以会出现重装失败的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu Subversion软件安装和配置</title>
      <link href="2014/06/04/2014-06-04-Ubuntu-Software-Configure-and-Install/"/>
      <url>2014/06/04/2014-06-04-Ubuntu-Software-Configure-and-Install/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>最近，系统从 <code>windows</code>切换到<code>Ubuntu</code>，一些开发软件需要重新安装和配置。但是，众所周知，<code>windows</code>上的开发软件客户端比<code>ubuntu</code>等linux系系统使用要便捷和傻瓜得多，所以切换到<code>ubuntu</code>有很多软件需要安装，但是这些软件需要进行代码编译，就在这里记录下。</p><h2 id="subversion安装和配置"><a href="#subversion安装和配置" class="headerlink" title="subversion安装和配置"></a><a id="Subversion">subversion安装和配置</a></h2><p>一般，如果对<code>subversion</code>的版本不限制，那些直接使用<code>sudo apt-get install subversion</code>命令就可以安装来，但是如果对版本有要求，比如由于<code>svn</code>的1.8版本在很多<code>svn</code>服务器端不被支持，所以需要安装低于1.8的svn客户端。这就需要我们在本地编译完了之后再安装。</p><h3 id="2-1-subversion源码下载"><a href="#2-1-subversion源码下载" class="headerlink" title="2.1 subversion源码下载"></a>2.1 subversion源码下载</h3><p>点击进入下载页面：<a href="http://subversion.apache.org/download/#supported-releases">http://subversion.apache.org/download/#supported-releases</a> , 选择当前最新的<code>1.7</code>的子版本下载；</p><p>或者，也可以直接在终端使用命令：<code>wget http://apache.fayea.com/apache-mirror/subversion/subversion-1.7.17.tar.gz</code>下载。</p><h3 id="2-2-subversion-源码编译准备"><a href="#2-2-subversion-源码编译准备" class="headerlink" title="2.2 subversion 源码编译准备"></a>2.2 subversion 源码编译准备</h3><p>在<code>Linux</code>编译安装<code>subversion</code>需要事先准备很多的工作，安装很多相关的工具包，否则代码无法编译通过。因此，在安装<code> subversion</code>之前，需要先做一些准备工作。</p><span id="more"></span><h3 id="2-2-1-安装-autoconf-和-libtool"><a href="#2-2-1-安装-autoconf-和-libtool" class="headerlink" title="2.2.1 安装 autoconf 和 libtool"></a>2.2.1 安装 autoconf 和 libtool</h3><p>编译<code>subversion</code>首先需要安装<code>autoconf</code>和<code>libtool</code>两个工具，如果你的电脑上没有安装这两个工具包，很简单，直接执行安装命令就可以来了：</p><pre><code>1.  sudo apt-get install autoconf2.  sudo apt-get install libtool</code></pre><p>但是，如果你就接下来运行<code>./configure</code>命令，则会出现下面错误:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">configure: Apache Portable Runtime (APR) library configuration</span><br><span class="line">checking for APR... no</span><br><span class="line">configure: WARNING: APR not found</span><br><span class="line">The Apache Portable Runtime (APR) library cannot be found.</span><br><span class="line">Please install APR on this system and supply the appropriate</span><br><span class="line">--with-apr option to &#x27;configure&#x27;</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">get it with SVN and put it in a subdirectory of this source:</span><br><span class="line"></span><br><span class="line">   svn co \</span><br><span class="line">    http://svn.apache.org/repos/asf/apr/apr/branches/1.3.x \</span><br><span class="line">    apr</span><br><span class="line"></span><br><span class="line">Run that right here in the top level of the Subversion tree.</span><br><span class="line">Afterwards, run apr/buildconf in that subdirectory and</span><br><span class="line">then run configure again here.</span><br><span class="line"></span><br><span class="line">Whichever of the above you do, you probably need to do</span><br><span class="line">something similar for apr-util, either providing both</span><br><span class="line">--with-apr and --with-apr-util to &#x27;configure&#x27;, or</span><br><span class="line">getting both from SVN with:</span><br><span class="line"></span><br><span class="line">   svn co \</span><br><span class="line">    http://svn.apache.org/repos/asf/apr/apr-util/branches/1.3.x \</span><br><span class="line">    apr-util</span><br><span class="line"></span><br><span class="line">configure: error: no suitable apr found</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-2-安装-APR"><a href="#2-2-2-安装-APR" class="headerlink" title="2.2.2 安装 APR"></a>2.2.2 安装 APR</h3><p>因此，你还需要<code>APR</code>,首先，在安装<code>apr</code>之前需要<code>sqlite-autoconf</code>，因此<code>subversion</code>需要使用<code>sqlite</code>来存储数据。</p><ol><li> sqlite-autoconf：<a href="http://www.sqlite.org/2014/sqlite-autoconf-3080403.tar.gz">http://www.sqlite.org/2014/sqlite-autoconf-3080403.tar.gz</a></li></ol><p>解压缩文件，然后在<code>subversion-1.7.17</code>目录下面，新建一个目录<code>sqlite-amalgamation</code>，然后在目录下面，从解压缩后的<code>sqlite-autoconf</code>目录里面复制一个文件<code>sqlite3.c</code>到该新建目录中。</p><blockquote><p>Note：需要注意的是，新建目录名必须为<code>sqlite-amalgamation</code>，虽然下载的文件是<code>sqlite-autoconf</code>，这主要是因为<code>sqlite-autoconf</code>工具是由<code>sqlite-amalgamation</code>来的，后来改了名字了，但是<code>subversion</code>编译的时候，并没有改变相应代码配置，所以还是需要用原来的命名。</p></blockquote><p>接下来，就可以下载apr.tar.gz和apr-util.tar.gz两个源码包：</p><ol><li>apr：<a href="http://mirrors.cnnic.cn/apache//apr/apr-1.5.1.tar.gz">http://mirrors.cnnic.cn/apache//apr/apr-1.5.1.tar.gz</a></li><li>apr-util：<a href="http://mirrors.cnnic.cn/apache//apr/apr-util-1.5.3.tar.gz">http://mirrors.cnnic.cn/apache//apr/apr-util-1.5.3.tar.gz</a></li></ol><p>解压缩完了之后，分别在<code>subversion-1.7.17</code>目录下面新建<code>apr</code>目录和<code>apr-util</code>目录，然后把解压缩后的内容复制到对应的新建目录中，分别执行<code>./buildconf</code></p><blockquote><p>Note：这里的目录名字不能改变，必须为<code>apr</code>和<code>apr-util</code>，否则会编译失败。</p></blockquote><p>当然，在这里运行<code>./configure</code>还是会出现问题，错误如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">checking zlib.h usability... no</span><br><span class="line">checking zlib.h presence... no</span><br><span class="line">checking for zlib.h... no</span><br><span class="line">configure: error: subversion requires zlib</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-3-安装-zlib"><a href="#2-2-3-安装-zlib" class="headerlink" title="2.2.3 安装 zlib"></a>2.2.3 安装 zlib</h3><p>好吧，这里还需要<code>zlib</code>库，所以接下来，还需要下载<code>zlib</code>源码包：</p><ol><li> zlib：<a href="http://cznic.dl.sourceforge.net/project/libpng/zlib/1.2.8/zlib-1.2.8.tar.gz">http://cznic.dl.sourceforge.net/project/libpng/zlib/1.2.8/zlib-1.2.8.tar.gz</a></li></ol><p>然后解压缩，在<code>subversion-1.7.17</code>目录下面，新建一个<code>zlib</code>目录，然后把解压缩的内容复制到该目录下，执行<code>./configure --shared</code>，然后在<code>make</code>，OK了。</p><h3 id="2-2-4-安装-neon"><a href="#2-2-4-安装-neon" class="headerlink" title="2.2.4 安装 neon"></a>2.2.4 安装 neon</h3><p>如果不安装<code>neon</code>库，在使用<code>svn co http://...</code> 的时候，则会出现错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">svn: E170000: Unrecognized URL scheme for http...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此，我们需要安装<code>neon</code>库来提供<code>HTTP</code>库给svn工具使用。在安装<code>neon</code>前需要安装<code>libxml2</code>和<code>libxml2-dev</code>，直接使用<code>sudo apt-get install </code>安装就可以了。</p><p>然后，下载neon，地址为：<a href="http://www.webdav.org/neon/neon-0.30.0.tar.gz">http://www.webdav.org/neon/neon-0.30.0.tar.gz</a>，解压缩之后，进入目录，执行<code>./configure</code>、<code>make</code>、<code>sudo make install</code>。</p><h3 id="2-3-subversion源码编译安装"><a href="#2-3-subversion源码编译安装" class="headerlink" title="2.3 subversion源码编译安装"></a>2.3 subversion源码编译安装</h3><p>准备工作做好了之后，就可以开始编译安装了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> ./configure --with-neon=/usr/<span class="built_in">local</span> CPPFLAGS=<span class="string">&quot;-I/home/ketao/java/subversion-1.7.17/zlib/ -L/home/ketao/java/subversion-1.7.17/zlib/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><blockquote><p>Note：网上嗖的时候，说是<code>./configure CPPFLAGS=&quot;-Izlib/ -Lzlib/&quot;</code>就可以，但是在执行的时候出现问题，找不到<code>zlib</code>目录，所以需要写绝对路径。</p></blockquote><p>接下来，你可以在终端执行命名，查看安装版本是否正确。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">svnversion --version</span><br></pre></td></tr></table></figure><p>然后会出现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">svnversion, version 1.7.17 (r1591372)</span><br><span class="line">   compiled Jun  4 2014, 17:39:27</span><br><span class="line"></span><br><span class="line">Copyright (C) 2014 The Apache Software Foundation.</span><br><span class="line">This software consists of contributions made by many people; see the NOTICE</span><br><span class="line">file for more information.</span><br><span class="line">Subversion is open source software, see http://subversion.apache.org/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><a id="Finally">小结</a></h2><p>Linux下面安装软件，通过编译安装实在是比较复杂，有时候，涉及到多个类库，需要一个个去下载编译安装，比较麻烦。所以，一般情况下，推荐使用<code>apt-get install </code>来打包安装。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux Awk 使用学习笔记</title>
      <link href="2014/05/30/2014-05-30-Linux-Awk-Study-Note/"/>
      <url>2014/05/30/2014-05-30-Linux-Awk-Study-Note/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p><code>linux Awk</code> 脚本语言，算来也有很长的一段历史了。在如今各种更全更简单的脚本语言遍地生成的年代，关注<code>Awk</code>的新人越来越少了。最近，在项目组同事的影响下，去学习了下<code>Awk</code>的基本使用方法。</p><blockquote><p>Note：本文只是学习笔记，很多示例和描述都来自最后推荐的文章里面。 </p></blockquote><p>起意写关于<code>Awk</code>学习笔记的主要原因是，学习皓哥的<a href="http://coolshell.cn/articles/9070.html">AWK 简明教程</a> 完了之后，完全还是云里雾里的，不知所以然。所以，找了个<a href="http://www.aslibra.com/doc/awk.htm">AWK 手册</a>好好学习。但是，对于前者介绍太多浅，初学者对于<code>Awk</code>使用没有任何概念；后者又过于长，不方便我去查资料，所以合计起来，就写一个学习总结罢了。</p><h2 id="Awk命令行"><a href="#Awk命令行" class="headerlink" title="Awk命令行"></a><a id="Console">Awk命令行</a></h2><p>关于<code>Awk</code>的历史，语言优势什么的，就不浪费时间介绍了。</p><h3 id="2-1-Awk-程序结构"><a href="#2-1-Awk-程序结构" class="headerlink" title="2.1 Awk 程序结构"></a>2.1 Awk 程序结构</h3><p>首先，我们在服务器上查看日志信息，大部分时候都希望使用一行命令搞定问题，因此，显然命令行方式使用<code>Awk</code>是很频繁的事情。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;awk程序主体&#x27;</span> [操作的文本] </span><br></pre></td></tr></table></figure><p>在写一个<code>awk</code>脚本之前，首先需要的是了解 <code>awk</code>程序组成结构，如果你不了解它的程序一般的结构，那么你去看皓哥或者其他人写的入门级<code>Awk</code>小程序，你也无法真正去了解或者深入。</p><pre><code>Pattern1 &#123;Actions1&#125;Pattern2 &#123; Actions2 &#125;......Pattern3 &#123; Actions3 &#125;</code></pre><span id="more"></span><blockquote><p>Note：<code>Pattern （模式）</code>，如同正则一样，就是判断<code>Pattern</code>是否满足，如果满足，则执行就下来的<code>Actions</code>动作行为。<code>awk</code>提供的比较运算符和<code>C</code>语言一样，不过新加了 <code>~</code>(匹配) 及 <code>!~</code>(不匹配) 二个关系运算符.</p></blockquote><pre><code>其用法与涵义如下:若 A 为一字符串, B 为一正则表达式(Regular Expression)A ~ B 判断 字符串A 中是否 包含 能匹配(match)B表达式的子字符串.A !~ B 判断 字符串A 中是否 不包含 能匹配(match)B表达式的子字符串.</code></pre><blockquote><p>Note：<code>Action</code>，就是动作，但是需要指出的是，一个<code>Pattern</code>所对应的<code>Action</code>应该要放进<code>&#123; &#125;</code>内。当然，存在一种情况，就是没有<code>Pattern</code>,直接就是<code>&#123;Action&#125;</code>，这表示，“无条件执行指定的Action动作”。</p></blockquote><p>了解了<code>awk</code>程序的基本结构，下面给一个简单示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27; $0&gt;1 &#123;print &quot;hello world&quot;&#125;&#x27;</span> </span><br></pre></td></tr></table></figure><blockquote><p>这个程序意思就是：<code>$0&gt;1</code>模式成立，则打印后面的<code>hello world</code>，在console上输入3，回车，则会打印<code>hello world</code>；如果输入0，则不会打印该消息。</p></blockquote><h3 id="2-2-Awk-程序说明"><a href="#2-2-Awk-程序说明" class="headerlink" title="2.2 Awk 程序说明"></a>2.2 Awk 程序说明</h3><p>首先，需要了解<code>$0</code>这种格式： <code>$0</code>表示<code>awk</code>所读入的一行字符串；<code>$1</code>则表示所读入的字符串的第一个数据，默认安装<code>空格/tab</code>来分隔；<code>$2</code>则表示所读入的字符串的第二个数据；以此类推…..</p><p>其次，这个程序是从控制台，或者文本中读取变量值（需要在后面写操作的文本名）。如果你测试了这个小脚本，你会发现，它会一直读，知道遇到<code>ctrl+d</code>或者<code>EOF</code>才会结束。但是，如果你初始化一些变量或者其他只需要执行一次的逻辑，怎么办呢？你需要<code>BEGIN</code>和<code>END</code>。</p><pre><code>1. BEGIN ：程序一开始执行时执行的，仅被执行一次。2. END     ：程序处理完所有数据即将返回的时候，执行一次。</code></pre><p>比如上面的程序，可以写成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27; BEGIN&#123;n=3&#125; $0&gt;1 &amp;&amp; --n&gt;0 &#123;print &quot;hello world&quot;&#125; END&#123;print &quot;EXIT AWK TEST&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>执行完了结果如下：</p><pre><code>[tao.ke@l-rtools1.ops.cn6 ~]$ awk &#39; BEGIN&#123;n=3&#125; $0&gt;1 &amp;&amp; --n&gt;0 &#123;print &quot;hello world&quot;&#125; END&#123;print &quot;EXIT AWK TEST&quot;&#125;&#39;         3hello world2hello world10 #（在这里的时候输入 ctrl+d）EXIT AWK TEST</code></pre><p>最后，说说<code>Awk</code>中使用<code>linux shell</code>命令。和<code>linux</code>一样，使用<code>|</code>来操作管道流，使用<code>&quot;&quot;</code>标识<code>linux</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27; BEGIN&#123;while(&quot;who&quot;|getline)&#123;print $0&#125;&#125; &#x27;</span>  </span><br></pre></td></tr></table></figure><blockquote><p>这里可以打印出，所有的登陆在系统上的用户。    关于<code>while</code>的使用，和<code>c</code>语言一样；此外，其他控制语言<code>if</code>、<code>do-while</code>、<code>for</code>，也和<code>c</code>一样。需要说明的是，<code>for</code>可以使用类似<code>foreach</code>的形式，具体见下一节。</p></blockquote><h2 id="推荐教程"><a href="#推荐教程" class="headerlink" title="推荐教程"></a><a id="Recommend">推荐教程</a></h2><ul><li><p>awk手册，<a href="http://www.aslibra.com/doc/awk.htm">http://www.aslibra.com/doc/awk.htm</a></p></li><li><p>AWK 简明教程，<a href="http://coolshell.cn/articles/9070.html">http://coolshell.cn/articles/9070.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Script </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线上Mysql死锁问题分析</title>
      <link href="2014/05/28/2014-05-28-Online-Mysql-Deadlock-Analyse/"/>
      <url>2014/05/28/2014-05-28-Online-Mysql-Deadlock-Analyse/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>前段时间，查看线上<code>Tomcat</code>日志，发现多台服务器出现<code>Mysql</code>死锁情况，虽然死锁问题没有影响到正常业务，但是毕竟数据库死锁还是得需要好好分析原因去修复和开发过程中极力需要避免的。服务器上<code>Mysql死锁</code>日志如下：</p><img src="/images/2014/05/deadlock-log.png" /><p>由于我们的服务使用了连接池，所以接着让 DBA 查询下<code>Mysql</code>的数据库操作日志信息，如下图所示：</p><img src="/images/2014/05/mysql-log.png" /><h2 id="死锁问题定位"><a href="#死锁问题定位" class="headerlink" title="死锁问题定位"></a><a id="Problem">死锁问题定位</a></h2><p>查看了建表语句，其实很简单：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `room_rate_plan_id` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">  `<span class="keyword">value</span>` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uniq_value` (`<span class="keyword">value</span>`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">175663</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8  </span><br></pre></td></tr></table></figure><p>而使用的地方只在一个类代码里用过，使用的方式是<code>select for update</code>，并且该查询事务中包含着，如果不存在，则<code>INSERT INTO room_rate_plan_id (value) VALUES(?)</code>语句，那么，接着就得了解<code>select for update</code>来确定是不是这里导致数据库死锁现象。主要有两篇博客：</p><span id="more"></span><ul><li><p><a href="http://stackoverflow.com/questions/5432370/mysql-innodb-dead-lock-on-select-with-exclusive-lock-for-update">http://stackoverflow.com/questions/5432370/mysql-innodb-dead-lock-on-select-with-exclusive-lock-for-update</a></p></li><li><p><a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-deadlocks.html">http://dev.mysql.com/doc/refman/5.0/en/innodb-deadlocks.html</a></p></li></ul><p><code>SELECT FOR UPDATE</code> 是<code>SELECT</code> 的升级版，其在查询时会上锁。一般地，当数据量特别大时，可能有大量的并发，这些并发会导致在<code>SELECT</code>时，状态已经变更了，因此需要上锁。InnoDB默认是Row-Level Lock，因此<code>SELECT FOR UPDATE</code>只有在<code>WHERE</code> 判断条件内明确指定主键时，才会执行<code>Row lock</code>，否则会<code>lock</code>整个数据表。当有多个请求同时加上<code>for update</code>的意向锁时，如果<code>select</code>没有时，第一个请求会接着<code>insert</code>而去尝试获取排它锁，B锁保持等待；而第二个请求也<code>select</code>为空时，并且刚好第二条请求插入的数据和第一个请求一样的时候，则会导致死锁。</p><h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a><a id="Reproduce">问题重现</a></h2><blockquote><p>执行下面语句：</p></blockquote><ul><li><code>session 1</code>执行：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> qunar.room_rate_plan_id <span class="keyword">where</span> <span class="keyword">value</span><span class="operator">=</span><span class="string">&#x27;elong_abcd&#x27;</span><span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><ul><li><code>session 2</code>执行：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> qunar.room_rate_plan_id <span class="keyword">where</span> <span class="keyword">value</span><span class="operator">=</span><span class="string">&#x27;elong_abcd&#x27;</span><span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><ul><li>在<code>session 1</code>上执行 <code>insert</code> 语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> qunar.room_rate_plan_id(<span class="keyword">value</span>) <span class="keyword">values</span> (<span class="string">&#x27;elong_abcd&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>执行上面的操作，则在<code>Mysql</code>控制台上打出死锁日志信息：</p></blockquote><img src="/assets/img/2014/5/28/mysql-dead.png" /><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><a id="Solution">解决方法</a></h2><ol><li><p>采用官网上指出的方法：If you are using locking reads (SELECT … FOR UPDATE or SELECT … LOCK IN SHARE MODE), try using <code>a lower isolation level</code> such as READ COMMITTED.</p></li><li><p> 由于<code>select for update</code>只有不存在记录时才会去加一个意向锁，所以可以采用下面方法解决：select—&gt; if(id) is empty —&gt;insert;如果不为空，则select for update。不过这样就多了一次select了。</p></li><li><p>使用<code>insert ignore</code> 插入，然后select ，由于是value是<code>unique key</code>，所以select可以获取正确id，并且还可以不需要添加事务。可能会多一次insert ignore。这种方法之所以这样子，是因为在业务中没有update操作，只有insert和select，并且value是唯一的，这样子就可以只采用select而不需要采用select for update，并且还可以不需要事务，提供效率。</p></li></ol><blockquote><p>如果采用第3中解决方案，不会出现死锁问题，但是当锁一直被占用时，会出现等待超时，当然，如果不使用事务，则肯定不会有锁的问题了。</p></blockquote><pre><code>* session 1：    <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> IGNORE <span class="keyword">INTO</span> room_rate_plan_id(<span class="keyword">value</span>) <span class="keyword">VALUES</span> (<span class="string">&#x27;elong_abcs&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> room_rate_plan_id <span class="keyword">where</span> <span class="keyword">value</span><span class="operator">=</span><span class="string">&#x27;elong_abcs&#x27;</span>;</span><br></pre></td></tr></table></figure>* session 2：    <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> IGNORE <span class="keyword">INTO</span> room_rate_plan_id(<span class="keyword">value</span>) <span class="keyword">VALUES</span> (<span class="string">&#x27;elong_abcs&#x27;</span>);</span><br></pre></td></tr></table></figure>* 出现超时异常信息：</code></pre><img src="/images/2014/05/timeout.png" />]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 查看系统GC命令介绍</title>
      <link href="2014/05/27/2014-05-27-Jstat-GC-Guide-Introduce/"/>
      <url>2014/05/27/2014-05-27-Jstat-GC-Guide-Introduce/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>使用    <code>JVM</code>的人都或多或少的了解<code>垃圾回收</code>机制，当系统的服务出现性能问题时，都会去服务器上查看下系统<code>GC</code>的情况。此外，如果有新的服务上线，也需要去服务器上查看下新服务的整体<code>GC</code>水平，这就可以使用<code>jstat</code>命令来查看了，当然你也可以使用其他方式。</p><h2 id="Jstat-查看系统-GC-命令介绍"><a href="#Jstat-查看系统-GC-命令介绍" class="headerlink" title="Jstat 查看系统 GC 命令介绍"></a><a id="Jstat">Jstat 查看系统 GC 命令介绍</a></h2><p><code>jstat</code>的命令查看系统<code>GC</code>情况，很简单，只需要先通过<code>jps</code>或者<code>ps -aux |grep tomcat</code>来查看对应服务所在的进程数，然后使用下面命令查看。</p><blockquote><p>jstat 查看 gc 使用方法如下：  </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">jstat -gcutil `线程值` `间隔时间数(ms)`</span><br></pre></td></tr></table></figure><blockquote><p>执行命令<code>sudo jstat -gcutil 11694 3600</code>，结果会显示内存各个区域大小的情况，如图：</p></blockquote><img src="/images/2014/05/jstat-gc.jpg" /><blockquote><p>Note: 结果里面列出每个区间的内存大小，新生代gc的次数和时间，老年代gc的次数和时间。    </p></blockquote><pre><code>1. S0  — Heap上的 Survivor space 0 区已使用空间的百分比;2. S1  — Heap上的 Survivor space 1 区已使用空间的百分比;3. E   — Heap上的 Eden space 区已使用空间的百分比;4. O   — Heap上的 Old space 区已使用空间的百分比;5. P   — Perm space 区已使用空间的百分比;6. YGC — 从应用程序启动到采样时发生 Young GC 的次数;7. YGCT– 从应用程序启动到采样时 Young GC 所用的时间(单位秒);8. FGC — 从应用程序启动到采样时发生 Full GC 的次数;9. FGCT– 从应用程序启动到采样时 Full GC 所用的时间(单位秒);10. GCT — 从应用程序启动到采样时用于垃圾回收的总时间(单位秒).</code></pre><span id="more"></span><h2 id="Jmap-查看系统-GC-命令介绍"><a href="#Jmap-查看系统-GC-命令介绍" class="headerlink" title="Jmap 查看系统 GC 命令介绍"></a><a id="Jmap">Jmap 查看系统 GC 命令介绍</a></h2><p>当我们使用<code>jstat</code>命令查看<code>GC</code>时，发现<code>YoungGC</code>或者<code>FullGC</code>频率过高时，就需要分析服务的具体情况了。这个时候，可以使用<code>Jmap</code>来查看当前系统的实例使用内存大小，一般地，需要<code>dump</code>到本地进行分析，使用可视化工具可以使分析效率得到很大的提高。</p><blockquote><p><code>Jmap</code>的使用方法如下所示：  </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=log.bin `进程id`    </span><br></pre></td></tr></table></figure><blockquote><p>使用<code>sudo jmap -dump:format=b,file=log.bin  -F 11694</code>命令，写入文件内容如下:</p></blockquote><pre><code>JAVA PROFILE 1.0.1JAVA PROFILE 1.0.1Lcom/alibaba/dubbo/remoting/exchange/support/DefaultFuture$RemotingInvocationTimeoutScan;DefaultStatistics.javaT8procedureNameRsStringUtils.10isCons(Ljava/lang/Integer;)Ljava/math/BigDecimal;HtheCloseBracketForh([Ljava/lang/String;Lorg/codehaus/jackson/JsonGenerator;Lorg/codehaus/jackson/map/SerializerProvider;Lorg/codehaus/jackson/map/JsonSerializer;)VzC@roureqlastActiveFilterAmpersand......</code></pre><blockquote><p>Note：有很多可视化的工具来分析<code>dump</code>文件，为了简单，这里使用java自带的工具<code>jvisualvm</code>工具，在<code>文件</code>选项中<code>装入</code> dump 下来的 文件<code>log.bin</code>，就可以看到各个对象实例所占用的内存大小和实例数量了。如下图：</p></blockquote><img src="/images/2014/05/jmap-gc.jpg" /><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><a id="Finally">小结</a></h2><p>java 中 还有一个命令比较有用，就是<code>jstack</code>，该命令可以查看服务器上的某个服务的堆栈信息。从而分析线程是否处于死锁状态，从而导致服务不可用或者服务性能受到影响。使用命令<code>jstack 线程id</code>就可以获取所有堆栈信息了，非常简单便捷。</p>]]></content>
      
      
      <categories>
          
          <category> GC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC 项目构建入门指南</title>
      <link href="2014/05/26/2014-05-26-Spring-MVC-Project-Introduction/"/>
      <url>2014/05/26/2014-05-26-Spring-MVC-Project-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>走入社会工作接近一年了,感慨颇多.一年前的现在,自己对java知之甚少,更不知道怎么去创建一个满足<code>spring mvc</code>架构思想的web项目。最近，为了学习<code>Spring MVC</code>框架的实现原理，首先新建了一个web项目，该项目包含 <code>Spring + Mybatis</code>涉及数据库，DAO，service，API，业务，controller多个模块。</p><blockquote><p>Note：这个项目代码完成的功能只是为了演示一个大项目应该具备的结构，而显然在实际工程中，这么简单地功能，是不需要如此繁杂的结构模块的。</p></blockquote><p>此外，关于<code>Spring MVC</code>演示项目的代码，可以从<code>github</code>上<code>clone</code>一份到本地，项目为：<a href="https://github.com/ketao1989/simpleSpringProject">SimpleSpringProject</a>。<code>git clone</code> 地址为：<code>https://github.com/ketao1989/simpleSpringProject.git</code></p><h2 id="SimpleSpringProject-结构介绍"><a href="#SimpleSpringProject-结构介绍" class="headerlink" title="SimpleSpringProject 结构介绍"></a><a id="Framework">SimpleSpringProject 结构介绍</a></h2><p><code>simpleSpringProject</code>项目各个模块分工明确，主要由8个模块组成：</p><pre><code>1. simple-spring-main模块：该模块主要是提供给外界访问的controller层所在。`controller`层可以对外提供html视图，也可以对外提供RPC调用，例如 alibaba 的 dubbo接口。2. simple-spring-api模块：该模块主要就是封装一些底层的方法接口给外部使用。比如，如果我们使用RPC接口调用服务，则只需要API包就可以了，具体实现调用方是不需要知道的。3. simple-spring-biz模块：该模块是业务模块，也就是具体业务需要的方法基本上都是在这里实现的。在demo 中，在这一层实现api提供的接口。该模块主要调用service层提供的基本服务，组装起来，实现各种不同的业务逻辑接口。4. simple-spring-service模块：该模块是基础服务模块，该模块会为biz业务模块提供基本的服务，这些服务功能都比较简单，业务逻辑单一。因此，在这一层进行单元测试，一般会取到比较好的效果。5. simple-spring-dao模块：该模块是数据库相关接口模块。`Mybatis`可以把interface 和 xml结合起来，使得开发者可以把数据库表中相关操作集成在 interface 代码中，而具体的`SQL`实现则写在xml文件中。这样子，可以让整个结构更清晰。6. simple-spring-config模块：该模块就是相关`sql`语句的配置文件所在地。一般地，会根据interface 来切分不同的配置文件，两种的关联关系是通过对于的`sql.xml`文件中`mapper namespace`来关联。7. simple-spring-common模块：该模块一般存放一些项目公用的工具类和常量值。比如，一些配置文件中需要配置的属性值，一些xxxUtils类实现等。8. simple-spring-model模块：该模块主要提供一些模型，各个类需要使用的对象。比如，我们需要获取一个学生个体信息，显然会作为一个对象类来实现。</code></pre><blockquote><p>Note：显然，对于各个模块的具体详细分工，其实还是可以调整的，比如可能有些地方会在<code>service</code>层来做稍微复杂的服务实现，而在<code>biz</code>层则稍微组合就可以了。这里，demo的模块分类，只是正常情况下，业务规模有一些大的情况下，才会进行多个模块的分工。</p></blockquote><span id="more"></span><h2 id="SimpleSpringProject-配置介绍"><a href="#SimpleSpringProject-配置介绍" class="headerlink" title="SimpleSpringProject 配置介绍"></a><a id="Configure">SimpleSpringProject 配置介绍</a></h2><p><code>Spring</code>作为一个主打配置的框架，配置文件的位置，十分重要。如果，一些配置文件的一个符号错误，都会导致整个<code>MVC</code> web 项目无法正常启动。</p><blockquote><p>首先，来看看web项目中，重中之重的配置文件<code>web.xml</code>，</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> <span class="attr">xmlns:web</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;WebApp_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.5&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--启动配置文件设置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>simple-spring-main<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 请求地址匹配映射 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.htm<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.json<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.xml<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 编码过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.htm<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定404页面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>接下来默认<code>springmvc-servlet.xml</code>文件和<code>applicationContext.xml</code>文件。<code>springmvc-servlet.xml</code>配置文件，主要定义servlet相关配置，比如scan 基本包名，视图velocity配置，jsp配置设置等信息。由于这里只有一个 mapping servlet，所以只有一个对应的配置文件，当然也可以把这个文件放置其他地方，然后再<code>web.xml</code>中定义对于的servlet就可以了。<code>applicationContext.xml</code>配置文件，则是整个项目的公共配置，比如指定数据库配置，连接池相关信息，一些spring bean 注册信息，默认的视图解析器等等。</p></blockquote><p>-</p><blockquote><p>接下来，就是<code>mybatis.xml</code>配置文件，这个配置主要是针对<code>Mybatis</code>而存在的，其指定项目中<code>Mybatis</code>设置，以及一些<code>typeHandler</code>，<code>mapper</code>实现的位置。下面给出demo中的配置示例：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这个配置使全局的映射器启用或禁用缓存 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 允许或不允许多种结果集从一个单独的语句中返回（需要适合的驱动） --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用列标签代替列名。不同的驱动在这方便表现不同。参考驱动文档或充分测试两种方法来决定所使用的驱动 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 允许JDBC支持生成的键。需要适合的驱动。如果设置为true则这个设置强制生成的键被使用，尽管一些驱动拒绝兼容但仍然有效（比如Derby） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定MyBatis如何自动映射列到字段/属性。PARTIAL只会自动映射简单，没有嵌套的结果。FULL会自动映射任意复杂的结果（嵌套的或其他情况） --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置默认的执行器。SIMPLE执行器没有什么特别之处。REUSE执行器重用预处理语句。BATCH执行器重用语句和批量更新 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;safeRowBoundsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;REUSE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置超时时间，它决定驱动等待一个数据库响应的时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultStatementTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/version.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>-</p><blockquote><p>最后，介绍下<code>pom.xml</code>文件，这个实际上，不算是MVC 所仅有的。但是，作为一个maven项目，很多配置都比较关键，一般模块的<code>pom.xml</code>都比较简单，但是<code>    main</code>模块由于涉及编译成war包，并且针对不同的运行环境，对应打包的配置文件不同，因此，其内部配置会比较复杂。具体参考demo项目代码。</p></blockquote><h2 id="SimpleSpringProject-数据操作实现介绍"><a href="#SimpleSpringProject-数据操作实现介绍" class="headerlink" title="SimpleSpringProject 数据操作实现介绍"></a><a id="DataOp">SimpleSpringProject 数据操作实现介绍</a></h2><p>整个项目代码都非常简单，不需要过多的去说明。在这里，对于初学者，需要介绍下，数据库相关的访问代码实现逻辑。</p><blockquote><p>首先，定义一个接口，该接口里面会声明一些需要在    <code>sql</code>中去实现的方法名，如下所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: tao.ke Date: 14-5-26 Time: 上午11:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: \$Id$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">VersionDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id 查询对应的version信息</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Version <span class="title">queryVersionById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有的版本信息</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Version&gt; <span class="title">queryAllVersions</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>当<code>dao</code>模块则存在了需要实现的接口，则接下来可以在<code>config</code>模块中去实现它，具体实现，如下所示：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;io.github.ketao1989.dao.VersionDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;VersionMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;io.github.ketao1989.model.Version&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;version_num&quot;</span> <span class="attr">property</span>=<span class="string">&quot;versionNum&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;description&quot;</span> <span class="attr">property</span>=<span class="string">&quot;description&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;update_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;updateTime&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;versionColumn&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">suffix</span>=<span class="string">&quot;&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;versionNum != null&quot;</span>&gt;</span>version_num,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;description != null&quot;</span>&gt;</span>description,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateTime != null&quot;</span>&gt;</span>update_time<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;versionValue&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">suffix</span>=<span class="string">&quot;&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;versionNum != null&quot;</span>&gt;</span>#&#123;versionNum&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;description != null&quot;</span>&gt;</span>#&#123;description&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateTime != null&quot;</span>&gt;</span>#&#123;updateTime&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 根据id查询Version记录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryVersionById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;VersionMap&quot;</span>&gt;</span></span><br><span class="line">          select id,version_num,description,update_time</span><br><span class="line">          from version</span><br><span class="line">          where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 查询所有Version记录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAllVersions&quot;</span>  <span class="attr">resultMap</span>=<span class="string">&quot;VersionMap&quot;</span>&gt;</span></span><br><span class="line">          select id,version_num,description,update_time</span><br><span class="line">          from version</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Note：这样在<code>service</code>模块调用 <code>dao</code>模块的接口，就可以操作数据库了。当然，你在<code>applicationContext.xml</code>中需要配置下面一段代码：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建SqlSessionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;io.github.ketao1989.dao&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><a id="Finally">小结</a></h2><p>本文只是简单介绍了下<code>Spring MVC</code>项目的一些实现注意点，具体的代码实现，请参考本github上的<a href="https://github.com/ketao1989/simpleSpringProject">SimpleSpringProject</a> 。在demo代码的实现里面，如果你是一个初学者，你会发现更多需要注意的地方。如果你对于本项目的各个地方都能理解，并且可以仿照新建一个项目，那么你对于<code>Spring MVC</code>就已经入门了，可以深入框架源码来进一步学习了。</p><p>当然，作为一个提供初学者使用的<code>Spring MVC</code> web工程项目，该demo只是供学习使用而已。你也可以继续在该demo上扩展，增加更多地类，更多地业务和功能，从而完成一个商业大项目。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java Fork&amp;Join框架使用和实现分析</title>
      <link href="2014/05/24/2014-05-24-Java-Fork-Join-Task-Framework-API-Introduce/"/>
      <url>2014/05/24/2014-05-24-Java-Fork-Join-Task-Framework-API-Introduce/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>在并发编程网上,关于ForkJoin框架介绍得很好，推荐去看: <a href="http://ifeve.com/fork-join-1/">Fork/Join框架</a> 本篇博文只是对一些地方进行补充说明(为了文章连续性，会借鉴一些介绍文字).</p><p>在上一篇博文: <a href="http://ketao1989.github.io/posts/Java-MultiThread-ThreadPool-Introduce.html">Java 多线程线程池介绍</a> 中最后说明了，对于一个任务可以切割成多个小任务分别执行，然后把各个小任务的结果，组合成最终的结论。熟悉<code>MapReduce</code>的同学，肯定对此再熟悉不过了。</p><p>首先贴出一个很简单的代码demo，这段代码是对上篇博文中代码，用<code>ForkJoin</code> API方式来实现（实际上，这并不是一个好的介绍<code>ForkJoin</code>功能的例子，但是我们先用它来入门了）</p><blockquote><p><code>ForkJoin</code>任务，继承自<code>RecursiveAction</code>，因为我们不需要任务返回什么计算结果：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> io.github.ketao1989;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveAction;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 很简单的一个操作，就是把字符串加一个后缀，然后放进队列里</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ketao Date: 14-5-24 Time: 下午10:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: \$Id$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; processStr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListTask</span><span class="params">(List&lt;String&gt; processStr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.processStr = processStr;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isProcess = (end - start) == THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (isProcess) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            String newStr = processStr.get(start) + <span class="string">&quot;-test&quot;</span>;</span><br><span class="line">            processStr.set(start, newStr);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;----&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> partPos = (start + end) / <span class="number">2</span>;</span><br><span class="line">            ListTask taskl = <span class="keyword">new</span> ListTask(processStr, start, partPos);</span><br><span class="line">            ListTask taskr = <span class="keyword">new</span> ListTask(processStr, partPos, end);</span><br><span class="line">            invokeAll(taskl, taskr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><blockquote><p><code>ForkJoin</code>的DEMO主函数，最后如果任务正常结束，则打印<code>任务顺利完成</code>信息：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> io.github.ketao1989;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ketao Date: 14-5-24 Time: 下午10:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: \$Id: ForkJoinTest.java 6 2014-05-24 14:13:48Z ketao1989 $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;thread-11&quot;</span>, <span class="string">&quot;thread-21&quot;</span>, <span class="string">&quot;thread-31&quot;</span>, <span class="string">&quot;thread-41&quot;</span>, <span class="string">&quot;thread-51&quot;</span>,</span><br><span class="line">                <span class="string">&quot;thread-61&quot;</span>, <span class="string">&quot;thread-71&quot;</span>, <span class="string">&quot;thread-81&quot;</span>);</span><br><span class="line">        ListTask listTask = <span class="keyword">new</span> ListTask(list, <span class="number">0</span>, list.size());</span><br><span class="line">        pool.invoke(listTask);</span><br><span class="line">        System.out.println(JSON.toJSONString(list));</span><br><span class="line">        pool.shutdown();</span><br><span class="line">        <span class="keyword">if</span> (listTask.isCompletedNormally()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task 任务顺利完成！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>执行结果如下，如我们所期望的那样：</p></blockquote><pre><code>ForkJoinPool-1-worker-1----ForkJoinPool-1-worker-1----ForkJoinPool-1-worker-1----ForkJoinPool-1-worker-1ForkJoinPool-1-worker-3----ForkJoinPool-1-worker-3ForkJoinPool-1-worker-3ForkJoinPool-1-worker-2----ForkJoinPool-1-worker-1ForkJoinPool-1-worker-4----ForkJoinPool-1-worker-4ForkJoinPool-1-worker-4ForkJoinPool-1-worker-2----ForkJoinPool-1-worker-2ForkJoinPool-1-worker-2[&quot;thread-11-test&quot;,&quot;thread-21-test&quot;,&quot;thread-31-test&quot;,&quot;thread-41-test&quot;,&quot;thread-51-test&quot;,&quot;thread-61-test&quot;,&quot;thread-71-test&quot;,&quot;thread-81-test&quot;]Task 任务顺利完成！</code></pre><p>上面的代码，其是同步执行任务，也就是说当任务开始执行时，主线程会阻塞执行任务，直到任务执行完成。和线程池一样，你也可以使用Future来完成异步执行任务。此外，对于需要返回结果的<code>ForkJoin</code>，Task类可以继承<code>RecursiveTask&lt;T&gt;</code>类。</p><h2 id="ForkJoin框架介绍"><a href="#ForkJoin框架介绍" class="headerlink" title="ForkJoin框架介绍"></a><a id="ForkJoin">ForkJoin框架介绍</a></h2><p><code>ForkJoin</code>框架其本质就是将一个大任务分割成多个小任务来执行，然后将每个小任务执行的结果合并为我们需要的返回值。因此，和当前云计算框架<code>MapReduce</code>一样，其计算主要分两步：</p><pre><code>1. Fork操作：就是把一个大的任务分割成多个更小的子任务，然后执行这些小的子任务；2. Join操作：顾名思义就是等待所有任务完成后返回。</code></pre><p>因此可以看出，命名意义和<code>Linux C</code>的<code>Thread</code>的API定义保持一致。借鉴网络上得一张图来形象描述下：</p><img src="/images/2014/05/forkjoin-work.jpg" /><p>这个框架被设计用来解决可以使用分而治之技术将任务分解成更小的问题。在一个任务中，检查你想要解决问题的大小，如果它大于一个既定的大小，把它分解成更小的任务，然后用这个框架来执行。如果问题的大小是小于既定的大小，你直接在任务中解决这问题。它返回一个可选地结果。</p><p>Fork/Join 和Executor框架主要的区别是<code>work-stealing</code>算法，可以参考上一篇博文：<a href="http://ketao1989.github.io/posts/Java-MultiThread-ThreadPool-Introduce.html">Java 多线程线程池介绍</a>。不像Executor框架，当一个任务正在等待它使用join操作创建的子任务的结 束时，执行这个任务的线程（工作线程）查找其他未被执行的任务并开始它的执行。通过这种方式，线程充分利用它们的运行时间，从而提高了应用程序的性能。</p><p>工作窃取算法，<code>work-stealing</code>算法存在可以帮助我们充分利用线程资源来减少执行时间。</p><blockquote><p>Tips: 我们把一个大的任务分割成多个不相互依赖的小的子任务，并且把这些子任务分别放在不同的执行队列中，每个执行队列分别创建一个单独的线程来执行任务。默认线程数（队列数）为执行机器的CPU核数+1，具体可以看看上面DEMO执行的线程编号。每个队列分别有一个线程单独去执行，是为了避免或减少线程间的竞争。当某线程执行完队列中得所有任务时，而有其他线程没有完成对应队列中的任务时，线程会协助其他线程完成其对应队列中剩余的任务。为了避免线程间获取队列任务时产生竞争，显然会采取双端队列从而线程可以从队列尾部拿到还未被执行的任务，而真正执行队列任务的线程，则依然从队列头部获取任务。当然，该算法遇到队列只有一个任务时，也会产生竞争，并且多个队列和多个线程，也会消耗更多的系统资源。</p></blockquote><p>为实现这个目标，Fork/Join框架执行的任务有以下局限性：</p><pre><code>1. 任务只能使用`fork()`和`join()`操作，作为同步机制。如果使用其他同步机制，工作线程不能执行其他任务，当它们在同步操作时。比如，在Fork/Join框架中，你使任务进入睡眠，正在执行这个任务的工作线程将不会执行其他任务，在这睡眠期间内。2. 任务不应该执行I/O操作，如读或写数据文件。3. 任务不能抛出检查异常，它必须包括必要的代码来处理它们。</code></pre><p>Fork/Join框架的核心是由以下两个类：</p><pre><code>1. ForkJoinPool：它实现ExecutorService接口和work-stealing算法。它管理工作线程和提供关于任务的状态和它们执行的信息。2. ForkJoinTask： 它是将在ForkJoinPool中执行的任务的基类。它提供在任务中执行fork()和join()操作的机制，并且这两个方法控制任务的状态。通常， 为了实现你的Fork/Join任务，你将实现两个子类的子类的类：RecursiveAction对于没有返回结果的任务和RecursiveTask 对于返回结果的任务。</code></pre><h2 id="ForkJoin-API介绍"><a href="#ForkJoin-API介绍" class="headerlink" title="ForkJoin API介绍"></a><a id="API">ForkJoin API介绍</a></h2><p>一般地，你需要按照下面两种情况下使用<code>ForkJoin</code>框架的API：</p><blockquote><p><code>RecursiveAction</code>任务对应的API使用模型：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">If (problem size &lt; <span class="keyword">default</span> size)&#123;</span><br><span class="line">          tasks=divide(task);</span><br><span class="line">          execute(tasks);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve problem using another algorithm;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>RecursiveTask&lt;V&gt;</code>类任务对应的API使用模型：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">If (problem size &lt; size)&#123;</span><br><span class="line">    tasks=Divide(task);</span><br><span class="line">    execute(tasks);</span><br><span class="line">    groupResults()</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve problem;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，看看<code>ForkJoinPool</code>类的构造函数，和一些重要的对外提供的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程数为当前系统CPU核数+1的&#123;<span class="doctag">@code</span> ForkJoinPool&#125;对象，该对象使用&#123;<span class="doctag">@linkplain</span></span></span><br><span class="line"><span class="comment">    * #defaultForkJoinWorkerThreadFactory default thread factory&#125;，没有异常处理器和非异步的LIFO处理模式</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> SecurityException if a security manager exists and</span></span><br><span class="line"><span class="comment">    *         the caller is not permitted to modify threads</span></span><br><span class="line"><span class="comment">    *         because it does not hold &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">    *         java.lang.RuntimePermission&#125;&#123;<span class="doctag">@code</span> (&quot;modifyThread&quot;)&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(Runtime.getRuntime().availableProcessors(),</span><br><span class="line">            defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 指定线程数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(parallelism, defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 原生的构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="params"><span class="function">                       Thread.UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">boolean</span> asyncMode)</span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">   <span class="comment">// 执行给定的task任务，直到执行完成之后返回它的结果</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> &lt;T&gt; T <span class="title">invoke</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"><span class="comment">// 异步执行给定的task任务</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">   <span class="comment">// 提交一个 ForkJoinTask 任务去执行</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">   <span class="comment">// 按照先前提交任务的顺序关闭，但是不在接收新的任务。对于已经关闭的pool，不会有副作用。</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>接下来，看看<code>RecursiveAction</code>类的构造函数，以及相应地方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 抽象类，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveAction</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务需要执行的代码. 继承该类的子类，需要重写该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，看看<code>RecursiveTask</code>类的构造函数，以及相应地方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务需要执行的代码. 继承该类的子类，需要重写该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> V <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ForkJoin-使用示例"><a href="#ForkJoin-使用示例" class="headerlink" title="ForkJoin 使用示例"></a><a id="Example">ForkJoin 使用示例</a></h2><p>在前言中已经给出了关于<code>RecursiveAction</code>的demo，下面来看看使用<code>RecursiveTask</code>来实现该问题的代码，一并说明异步返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> io.github.ketao1989;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 很简单的一个操作，就是把字符串加一个后缀，然后放进队列里</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ketao Date: 14-5-24 Time: 下午10:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: \$Id$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">List</span>&lt;<span class="title">String</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; processStr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListTask</span><span class="params">(List&lt;String&gt; processStr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.processStr = processStr;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = Lists.newArrayListWithCapacity(processStr.size());</span><br><span class="line">        <span class="keyword">boolean</span> isProcess = (end - start) == THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (isProcess) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            String newStr = processStr.get(start) + <span class="string">&quot;-test&quot;</span>;</span><br><span class="line">            result.add(newStr);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> partPos = (start + end) / <span class="number">2</span>;</span><br><span class="line">            ListTask taskl = <span class="keyword">new</span> ListTask(processStr, start, partPos);</span><br><span class="line">            ListTask taskr = <span class="keyword">new</span> ListTask(processStr, partPos, end);</span><br><span class="line"></span><br><span class="line">            taskl.fork(); <span class="comment">//按序异步执行这个任务，会放到一个队列里</span></span><br><span class="line">            taskr.fork();</span><br><span class="line"></span><br><span class="line">            List&lt;String&gt; resultl = taskl.join(); <span class="comment">//等待执行完成后返回，调用isDone 会返回true</span></span><br><span class="line">            List&lt;String&gt; resultr = taskr.join();</span><br><span class="line">            </span><br><span class="line">            result.addAll(resultl);</span><br><span class="line">            result.addAll(resultr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试主函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ketao Date: 14-5-24 Time: 下午10:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: \$Id: ForkJoinTest.java 6 2014-05-24 14:13:48Z ketao1989 $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;thread-11&quot;</span>, <span class="string">&quot;thread-21&quot;</span>, <span class="string">&quot;thread-31&quot;</span>, <span class="string">&quot;thread-41&quot;</span>, <span class="string">&quot;thread-51&quot;</span>,</span><br><span class="line">                <span class="string">&quot;thread-61&quot;</span>, <span class="string">&quot;thread-71&quot;</span>, <span class="string">&quot;thread-81&quot;</span>);</span><br><span class="line">        ListTask listTask = <span class="keyword">new</span> ListTask(list, <span class="number">0</span>, list.size());</span><br><span class="line">        Future&lt;List&lt;String&gt;&gt; result = pool.submit(listTask);</span><br><span class="line">        System.out.println(JSON.toJSONString(result.get()));</span><br><span class="line">        pool.shutdown();</span><br><span class="line">        <span class="keyword">if</span> (listTask.isCompletedNormally()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task 任务顺利完成！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果，如下所示：</p><pre><code>ForkJoinPool-1-worker-1---ForkJoinPool-1-worker-2---ForkJoinPool-1-worker-3---ForkJoinPool-1-worker-4---ForkJoinPool-1-worker-5ForkJoinPool-1-worker-5---ForkJoinPool-1-worker-3ForkJoinPool-1-worker-3---ForkJoinPool-1-worker-2ForkJoinPool-1-worker-2ForkJoinPool-1-worker-5ForkJoinPool-1-worker-1---ForkJoinPool-1-worker-2ForkJoinPool-1-worker-2ForkJoinPool-1-worker-3[&quot;thread-11-test&quot;,&quot;thread-21-test&quot;,&quot;thread-31-test&quot;,&quot;thread-41-test&quot;,&quot;thread-51-test&quot;,&quot;thread-61-test&quot;,&quot;thread-71-test&quot;,&quot;thread-81-test&quot;]Task 任务顺利完成！</code></pre><blockquote><p>demo代码很简单，这里不进行说明。</p></blockquote><h2 id="ForkJoin-实现剖析"><a href="#ForkJoin-实现剖析" class="headerlink" title="ForkJoin 实现剖析"></a><a id="Analyze">ForkJoin 实现剖析</a></h2><p><code>ForkJoin</code>整体框架相对简单明了，实现起来，也就是<code>ForkJoinTask</code> 和<code>ForkJoinWorkerThread</code>两部分，其中Task负责存放需要执行的任务，而Thread负责执行任务即可。具体实现，如下分析。</p><h3 id="5-1-ForkJoinPool实现分析"><a href="#5-1-ForkJoinPool实现分析" class="headerlink" title="5.1 ForkJoinPool实现分析"></a>5.1 ForkJoinPool实现分析</h3><p>首先，看<code>ForkJoinPool</code>类的构造函数，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="params"><span class="function">                       Thread.UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">boolean</span> asyncMode)</span> </span>&#123;</span><br><span class="line">       checkPermission(); <span class="comment">// 安全管理，检查操作是否有权限修改线程</span></span><br><span class="line">       <span class="keyword">if</span> (factory == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">if</span> (parallelism &lt;= <span class="number">0</span> || parallelism &gt; MAX_ID)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">this</span>.parallelism = parallelism;</span><br><span class="line">       <span class="keyword">this</span>.factory = factory;</span><br><span class="line">       <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">       <span class="keyword">this</span>.locallyFifo = asyncMode;</span><br><span class="line">       <span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">       <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);<span class="comment">//ctl是整个池的核心控制技术变量，说明见下面</span></span><br><span class="line">       <span class="keyword">this</span>.submissionQueue = <span class="keyword">new</span> ForkJoinTask&lt;?&gt;[INITIAL_QUEUE_CAPACITY]; <span class="comment">// 提交任务队列</span></span><br><span class="line">       <span class="comment">// initialize workers array with room for 2*parallelism if possible</span></span><br><span class="line">       <span class="keyword">int</span> n = parallelism &lt;&lt; <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (n &gt;= MAX_ID)</span><br><span class="line">           n = MAX_ID;</span><br><span class="line">       <span class="keyword">else</span> &#123; <span class="comment">// 当 n &lt; (1 &lt;&lt; 16)时，计算 n对应2进制的后面所有bit位为1，比如：6 = 110B --&gt; 111B = 7 ；8 = 1000B --&gt; 1111B = 15</span></span><br><span class="line">           n |= n &gt;&gt;&gt; <span class="number">1</span>; n |= n &gt;&gt;&gt; <span class="number">2</span>; n |= n &gt;&gt;&gt; <span class="number">4</span>; n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       workers = <span class="keyword">new</span> ForkJoinWorkerThread[n + <span class="number">1</span>]; <span class="comment">//执行任务的线程数组，n+1</span></span><br><span class="line">       <span class="keyword">this</span>.submissionLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">       <span class="keyword">this</span>.termination = submissionLock.newCondition();</span><br><span class="line">       StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ForkJoinPool-&quot;</span>);</span><br><span class="line">       sb.append(poolNumberGenerator.incrementAndGet()); <span class="comment">// pool 序数</span></span><br><span class="line">       sb.append(<span class="string">&quot;-worker-&quot;</span>);</span><br><span class="line">       <span class="keyword">this</span>.workerNamePrefix = sb.toString(); <span class="comment">// 线程名前缀在demo中，结果中打印出来了</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>ForkJoinPool</code>代码中变量<code>volatile long ctl</code>包含了<code>forkjoinpool</code>几个核心的数值，使用bit位来表示。具体为： AC(16 bits)–活跃运行的<code>worker</code>数量减去当前系统<code>parallelism</code>值；TC(16 bits)–总的<code>worker</code>数减去当前系统<code>parallelism</code>值；ST（1 bits）– <code>pool</code>是否结束；EC(15 bits) –等待线程组的头部的等待数；ID（16 bits）– 正在等待的线程组栈顶的索引<code>poolIndex</code>. </p></blockquote><hr><blockquote><p>Tips: 在构造函数中，创建了两个对象，分别是大小为<code>8</code>的<code>ForkJoinTask</code>数组 和 大小为<code>n+1</code>（4核Cpu为8）的 <code>ForkJoinWorkerThread</code>。因此，可以知道<strong>在初始化的时候，提交任务队列的大小 和 执行任务的线程数 很可能不相等</strong>。</p></blockquote><p>接下来需要说明的是，<code>ForkJoinPool</code>的<code>submit</code>方法，其会调用<code>forkOrSubmit(ForkJoinTask&lt;T&gt; task)</code>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">forkOrSubmit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">      ForkJoinWorkerThread w;</span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      <span class="keyword">if</span> (shutdown)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">      <span class="keyword">if</span> ((t <span class="keyword">instanceof</span> ForkJoinWorkerThread) &amp;&amp;</span><br><span class="line">          (w = (ForkJoinWorkerThread)t).pool == <span class="keyword">this</span>)</span><br><span class="line">          w.pushTask(task);<span class="comment">//push 该任务到该线程对应的队列中</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          addSubmission(task); <span class="comment">//把任务task 插入到submissionQueue队列中</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><blockquote><p>因此，需要执行的任务task已经被放进了队列中，执行线程可以获取任务来进行执行了。<code>addSubmission</code>运行时会使用<code>this.submissionLock</code>锁，并且入队之后，会调用<code>signalWork()</code>方法，该方法会根据当前<code>pool</code>中<code>worker</code>数量和状态来决定 唤醒或者创建一个worker。</p></blockquote><hr><blockquote><p>在<code>pool</code>中有一个核心的顶层循环，所有的工作线程都会按照这个步骤执行：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在每一步：如果上一步顺利通过所有的队列，并且发现没有了任务；或者有多余的线程，则可能会阻塞。此外，扫描scan，如果发现任务，则执行。</span></span><br><span class="line"><span class="comment"> * 当pool和 worker结束的时候，返回， </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(ForkJoinWorkerThread w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> swept = <span class="keyword">false</span>;                <span class="comment">// true on empty scans</span></span><br><span class="line">    <span class="keyword">long</span> c;</span><br><span class="line">    <span class="keyword">while</span> (!w.terminate &amp;&amp; (<span class="keyword">int</span>)(c = ctl) &gt;= <span class="number">0</span>) &#123; <span class="comment">//当线程未结束，并且还有任务未完成执行</span></span><br><span class="line">        <span class="keyword">int</span> a;                            <span class="comment">// active count</span></span><br><span class="line">        <span class="keyword">if</span> (!swept &amp;&amp; (a = (<span class="keyword">int</span>)(c &gt;&gt; AC_SHIFT)) &lt;= <span class="number">0</span>)</span><br><span class="line">            swept = scan(w, a); <span class="comment">//扫描任务，发现，则执行</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tryAwaitWork(w, c)) <span class="comment">//把worker线程放入等待queue中，等待worker的eventCount改变。</span></span><br><span class="line">            swept = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>Scan</code>方法的逻辑其实很简单，就是首先获取其线程内部的queue，执行任务；如果完了，则steal其他<code>worker</code>线程的任务；如果还没有，则执行pool中的<code>submissionQueue</code>。再没有，则返回true。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Scans for and, if found, executes one task. Scans start at a</span></span><br><span class="line"><span class="comment">    * random index of workers array, and randomly select the first</span></span><br><span class="line"><span class="comment">    * (2*#workers)-1 probes, and then, if all empty, resort to 2</span></span><br><span class="line"><span class="comment">    * circular sweeps, which is necessary to check quiescence. and</span></span><br><span class="line"><span class="comment">    * taking a submission only if no stealable tasks were found.  The</span></span><br><span class="line"><span class="comment">    * steal code inside the loop is a specialized form of</span></span><br><span class="line"><span class="comment">    * ForkJoinWorkerThread.deqTask, followed bookkeeping to support</span></span><br><span class="line"><span class="comment">    * helpJoinTask and signal propagation. The code for submission</span></span><br><span class="line"><span class="comment">    * queues is almost identical. On each steal, the worker completes</span></span><br><span class="line"><span class="comment">    * not only the task, but also all local tasks that this task may</span></span><br><span class="line"><span class="comment">    * have generated. On detecting staleness or contention when</span></span><br><span class="line"><span class="comment">    * trying to take a task, this method returns without finishing</span></span><br><span class="line"><span class="comment">    * sweep, which allows global state rechecks before retry.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> a the number of active workers</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true if swept all queues without finding a task</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">scan</span><span class="params">(ForkJoinWorkerThread w, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> g = scanGuard; <span class="comment">// mask 0 avoids useless scans if only one active</span></span><br><span class="line">       <span class="keyword">int</span> m = (parallelism == <span class="number">1</span> - a &amp;&amp; blockedCount == <span class="number">0</span>) ? <span class="number">0</span> : g &amp; SMASK;</span><br><span class="line">       ForkJoinWorkerThread[] ws = workers;</span><br><span class="line">       <span class="keyword">if</span> (ws == <span class="keyword">null</span> || ws.length &lt;= m)         <span class="comment">// staleness check</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> r = w.seed, k = r, j = -(m + m); j &lt;= m + m; ++j) &#123;</span><br><span class="line">           ForkJoinTask&lt;?&gt; t; ForkJoinTask&lt;?&gt;[] q; <span class="keyword">int</span> b, i;</span><br><span class="line">           ForkJoinWorkerThread v = ws[k &amp; m];</span><br><span class="line">           <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; (b = v.queueBase) != v.queueTop &amp;&amp;</span><br><span class="line">               (q = v.queue) != <span class="keyword">null</span> &amp;&amp; (i = (q.length - <span class="number">1</span>) &amp; b) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">long</span> u = (i &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">               <span class="keyword">if</span> ((t = q[i]) != <span class="keyword">null</span> &amp;&amp; v.queueBase == b &amp;&amp;</span><br><span class="line">                   UNSAFE.compareAndSwapObject(q, u, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                   <span class="keyword">int</span> d = (v.queueBase = b + <span class="number">1</span>) - v.queueTop;</span><br><span class="line">                   v.stealHint = w.poolIndex;</span><br><span class="line">                   <span class="keyword">if</span> (d != <span class="number">0</span>)</span><br><span class="line">                       signalWork();             <span class="comment">// propagate if nonempty</span></span><br><span class="line">                   w.execTask(t);</span><br><span class="line">               &#125;</span><br><span class="line">               r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; w.seed = r ^ (r &lt;&lt; <span class="number">5</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;                     <span class="comment">// store next seed</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;                     <span class="comment">// xorshift</span></span><br><span class="line">               r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; k = r ^= r &lt;&lt; <span class="number">5</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               ++k;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (scanGuard != g)                       <span class="comment">// staleness check</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">else</span> &#123;                                    <span class="comment">// try to take submission</span></span><br><span class="line">           ForkJoinTask&lt;?&gt; t; ForkJoinTask&lt;?&gt;[] q; <span class="keyword">int</span> b, i;</span><br><span class="line">           <span class="keyword">if</span> ((b = queueBase) != queueTop &amp;&amp;</span><br><span class="line">               (q = submissionQueue) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (i = (q.length - <span class="number">1</span>) &amp; b) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">long</span> u = (i &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">               <span class="keyword">if</span> ((t = q[i]) != <span class="keyword">null</span> &amp;&amp; queueBase == b &amp;&amp;</span><br><span class="line">                   UNSAFE.compareAndSwapObject(q, u, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                   queueBase = b + <span class="number">1</span>;</span><br><span class="line">                   w.execTask(t);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;                         <span class="comment">// all queues empty</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><h3 id="5-2-ForkJoinWorkerThread实现分析"><a href="#5-2-ForkJoinWorkerThread实现分析" class="headerlink" title="5.2 ForkJoinWorkerThread实现分析"></a>5.2 ForkJoinWorkerThread实现分析</h3><p>在<code>submit</code>方法中调用了<code>pushTask(ForkJoinTask&lt;?&gt; t)</code>方法，其实现在<code>ForkJoinWorkerThread</code>类中。<code>ForkJoinWorkerThread</code>类是用来被<code>ForkJoinPool</code>管理的线程类型，该类线程值执行<code>ForkJoinTask</code>类任务对象。</p><p>依然首先看看其构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在给定的pool里面创建一个 ForkJoinWorkerThread 实例.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ForkJoinWorkerThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(pool.nextWorkerName()); <span class="comment">// 使用Thread调用pool中指定的线程名前缀</span></span><br><span class="line">    <span class="keyword">this</span>.pool = pool;</span><br><span class="line">    <span class="keyword">int</span> k = pool.registerWorker(<span class="keyword">this</span>); <span class="comment">//注册线程到pool得worker数组中，获取在pool数组里对应的index索引</span></span><br><span class="line">    poolIndex = k;</span><br><span class="line">    eventCount = ~k &amp; SMASK; <span class="comment">// clear wait count</span></span><br><span class="line">    locallyFifo = pool.locallyFifo;</span><br><span class="line">    Thread.UncaughtExceptionHandler ueh = pool.ueh;</span><br><span class="line">    <span class="keyword">if</span> (ueh != <span class="keyword">null</span>)</span><br><span class="line">        setUncaughtExceptionHandler(ueh);</span><br><span class="line">    setDaemon(<span class="keyword">true</span>); <span class="comment">//守护线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Tips: 在构造方法里面，新建的线程实例，会注册到<code>pool</code>的<code>worker</code>数组中去，当<code>worker</code>数组大小不够，会进行<code>CopyOf</code>操作，把大小扩大原来的一倍。此外，代码的实现被没有获取lock操作。此外，创建的线程被指定为<code>守护进程</code>。</p></blockquote><p>接着来看看了<code>pushTask(ForkJoinTask&lt;?&gt; t)</code>方法的实现，该方法和<code>pool</code>的<code>addSubmission</code>方法基本一致，除了<code>addSubmission</code>会增加互斥锁操作。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pushes a task. Call only from this thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t the task. Caller must ensure non-null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pushTask</span><span class="params">(ForkJoinTask&lt;?&gt; t)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] q; <span class="keyword">int</span> s, m;</span><br><span class="line">    <span class="keyword">if</span> ((q = queue) != <span class="keyword">null</span>) &#123;    <span class="comment">// ignore if queue removed</span></span><br><span class="line">        <span class="keyword">long</span> u = (((s = queueTop) &amp; (m = q.length - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        UNSAFE.putOrderedObject(q, u, t); <span class="comment">// 把q数组偏移量为u的对应的值，置为t。不保证及时内存可见，如果field不为volatile</span></span><br><span class="line">        queueTop = s + <span class="number">1</span>;         <span class="comment">// or use putOrderedInt</span></span><br><span class="line">        <span class="keyword">if</span> ((s -= queueBase) &lt;= <span class="number">2</span>)</span><br><span class="line">            pool.signalWork(); <span class="comment">//唤醒或者新建worker线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == m)</span><br><span class="line">            growQueue(); <span class="comment">//当s的值和队列值长度length-1一样时，即队列已满，则增加队列大小。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>关于<code>UNSAFE</code>的实现，底层实现的<code>native</code>方法是C++，具体代码可以参见：<a href="http://www.oschina.net/code/explore/gcc-4.5.2/libjava/sun/misc">UNSAFE 源码实现链接</a></p></blockquote><hr><blockquote><p>作为一个<code>Thread</code>的继承子类，必然需要实现<code>run</code>方法，实现细节如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           onStart(); <span class="comment">// 该方法主要负责初始化Task 队列，和seed值</span></span><br><span class="line">           pool.work(<span class="keyword">this</span>); <span class="comment">// 调用pool的work方法，在pool中说明</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">           exception = ex;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           onTermination(exception);<span class="comment">// 清除该worker线程关于结束的一些操作，比如取消任务，解除在pool上的注册，状态为结束terminate</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-3-ForkJoinTask实现分析"><a href="#5-3-ForkJoinTask实现分析" class="headerlink" title="5.3 ForkJoinTask实现分析"></a>5.3 ForkJoinTask实现分析</h3><p>在API接口描述中，可以看出<code>RecursiveAction</code>类和<code>RecursiveTask</code>类都继承自<code>ForkJoinTask</code>抽象类，唯一不同就是一个不返回执行结果。在<code>ForkJoinTask</code>中需要关注的就是<code>join</code>方法和<code>fork</code>方法。</p><p>首先是<code>fork</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按序的异步执行这个任务.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ((ForkJoinWorkerThread) Thread.currentThread())</span><br><span class="line">        .pushTask(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>fork</code>方法实际上就是把新创建的子任务提交给当前线程，由当前线程push到它自身的队列数组中。</p></blockquote><p>接下来看看<code>join</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *当任务执行完成后，返回执行的结果，该方法和`Feture.get()`不同的地方时，其抛出的异常是`RuntimeException`和`Error`。</span></span><br><span class="line"><span class="comment">  *此外，也不会抛出`InterruptedException`。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (doJoin() != NORMAL) <span class="comment">// 任务没有正常完成</span></span><br><span class="line">         <span class="keyword">return</span> reportResult(); <span class="comment">//处理非正常情况</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> getRawResult(); <span class="comment">// 返回结果</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>doJoin()</code>方法算是<code>ForkJoinTask</code>类主要方法之一，其他的方法<code>doInvoke</code>、<code>doExec</code>方法和<code>doJoin</code>一样，都会执行核心的任务自定义<code>compute</code>方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Primary mechanics for join, get, quietlyJoin.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> status upon completion</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t; ForkJoinWorkerThread w; <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">       <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((s = status) &lt; <span class="number">0</span>) <span class="comment">// 如果任务已经完成，则直接返回</span></span><br><span class="line">               <span class="keyword">return</span> s;</span><br><span class="line">           <span class="keyword">if</span> ((w = (ForkJoinWorkerThread)t).unpushTask(<span class="keyword">this</span>)) &#123; <span class="comment">//从当前线程的任务数组中 pop 该任务，准备执行</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   completed = exec(); <span class="comment">// 调用自定义任务的compute方法执行</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                   <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (completed)</span><br><span class="line">                   <span class="keyword">return</span> setCompletion(NORMAL); <span class="comment">//如果顺利正常完成，则设置为正常完成状态</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> w.joinTask(<span class="keyword">this</span>); <span class="comment">//当任务没有正常完成，可能阻塞什么的，则会给helpJoinTask stolen-&gt;joining 方式执行</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> externalAwaitDone();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="5-4-joinTask-方法实现分析"><a href="#5-4-joinTask-方法实现分析" class="headerlink" title="5.4 joinTask 方法实现分析"></a>5.4 joinTask 方法实现分析</h3><p><code>joinTask</code>方法的具体实现在<code>ForkJoinWorkerThread</code>类中。但是由于其实现了 <code>ForkJoin</code>中关于<code>work-stealing</code>算法的实现，所以当初分析下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// helpJoinTask允许的最大stolen-&gt;joining 链深度，同时也是重试的最大次数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HELP = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">joinTask</span><span class="params">(ForkJoinTask&lt;?&gt; joinMe)</span> </span>&#123;</span><br><span class="line">       ForkJoinTask&lt;?&gt; prevJoin = currentJoin; <span class="comment">//保存当前在执行的任务</span></span><br><span class="line">       currentJoin = joinMe;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> s, retries = MAX_HELP;;) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((s = joinMe.status) &lt; <span class="number">0</span>) &#123; <span class="comment">//当joinMe任务正常完成，则执行原来正在执行的任务，返回执行状态</span></span><br><span class="line">               currentJoin = prevJoin; </span><br><span class="line">               <span class="keyword">return</span> s;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (retries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (queueTop != queueBase) &#123; <span class="comment">//当前队列中有任务未被执行</span></span><br><span class="line">                   <span class="keyword">if</span> (!localHelpJoinTask(joinMe)) <span class="comment">//并且队列中还存在其他未取消的任务，则不重试，扔到pool.tryAwaitJoin中</span></span><br><span class="line">                       retries = <span class="number">0</span>;           <span class="comment">// cannot help</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (retries == MAX_HELP &gt;&gt;&gt; <span class="number">1</span>) &#123; <span class="comment">//这个值为什么这么判断呢？？为什么retries == 8 执行下面逻辑？？</span></span><br><span class="line">                   --retries;                 <span class="comment">// check uncommon case</span></span><br><span class="line">                   <span class="keyword">if</span> (tryDeqAndExec(joinMe) &gt;= <span class="number">0</span>) <span class="comment">// 当joinMe是一些worker 队列的base上面，则steal，并且执行，执行的状态为不正常完成时</span></span><br><span class="line">                       Thread.yield();        <span class="comment">// 则礼貌性的暂停任务</span></span><br><span class="line">                      &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               <span class="comment">// 尝试定位和执行给定任务的stealer的任务集，或者轮流执行他的所有stealers的一个。如果运行一个任务，则返回true</span></span><br><span class="line">                   retries = helpJoinTask(joinMe) ? MAX_HELP : retries - <span class="number">1</span>; </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               retries = MAX_HELP;           <span class="comment">// restart if not done</span></span><br><span class="line">               pool.tryAwaitJoin(joinMe);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helpJoinTask</span><span class="params">(ForkJoinTask&lt;?&gt; joinMe)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> helped = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">int</span> m = pool.scanGuard &amp; SMASK;</span><br><span class="line">       ForkJoinWorkerThread[] ws = pool.workers; <span class="comment">//获取pool所有的worker线程数组</span></span><br><span class="line">       <span class="keyword">if</span> (ws != <span class="keyword">null</span> &amp;&amp; ws.length &gt; m &amp;&amp; joinMe.status &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">           <span class="keyword">int</span> levels = MAX_HELP;              <span class="comment">// remaining chain length</span></span><br><span class="line">           ForkJoinTask&lt;?&gt; task = joinMe;      <span class="comment">// base of chain</span></span><br><span class="line">           outer:<span class="keyword">for</span> (ForkJoinWorkerThread thread = <span class="keyword">this</span>;;) &#123;</span><br><span class="line">               <span class="comment">// Try to find v, the stealer of task, by first using hint</span></span><br><span class="line">               ForkJoinWorkerThread v = ws[thread.stealHint &amp; m];</span><br><span class="line">               <span class="keyword">if</span> (v == <span class="keyword">null</span> || v.currentSteal != task) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; ;) &#123;        <span class="comment">// search array</span></span><br><span class="line">                       <span class="keyword">if</span> ((v = ws[j]) != <span class="keyword">null</span> &amp;&amp; v.currentSteal == task) &#123;</span><br><span class="line">                           thread.stealHint = j;</span><br><span class="line">                           <span class="keyword">break</span>;              <span class="comment">// save hint for next time</span></span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (++j &gt; m)</span><br><span class="line">                           <span class="keyword">break</span> outer;        <span class="comment">// can&#x27;t find stealer</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Try to help v, using specialized form of deqTask</span></span><br><span class="line">               <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                   ForkJoinTask&lt;?&gt;[] q; <span class="keyword">int</span> b, i;</span><br><span class="line">                   <span class="keyword">if</span> (joinMe.status &lt; <span class="number">0</span>)</span><br><span class="line">                       <span class="keyword">break</span> outer;</span><br><span class="line">                   <span class="keyword">if</span> ((b = v.queueBase) == v.queueTop ||</span><br><span class="line">                       (q = v.queue) == <span class="keyword">null</span> ||</span><br><span class="line">                       (i = (q.length-<span class="number">1</span>) &amp; b) &lt; <span class="number">0</span>)</span><br><span class="line">                       <span class="keyword">break</span>;                  <span class="comment">// empty</span></span><br><span class="line">                   <span class="keyword">long</span> u = (i &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                   ForkJoinTask&lt;?&gt; t = q[i];</span><br><span class="line">                   <span class="keyword">if</span> (task.status &lt; <span class="number">0</span>)</span><br><span class="line">                       <span class="keyword">break</span> outer;            <span class="comment">// stale</span></span><br><span class="line">                   <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; v.queueBase == b &amp;&amp;</span><br><span class="line">                       UNSAFE.compareAndSwapObject(q, u, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                       v.queueBase = b + <span class="number">1</span>;</span><br><span class="line">                       v.stealHint = poolIndex;</span><br><span class="line">                       ForkJoinTask&lt;?&gt; ps = currentSteal;</span><br><span class="line">                       currentSteal = t;</span><br><span class="line">                       t.doExec(); <span class="comment">// 好了，这里获取到了steal到的task，可以执行了</span></span><br><span class="line">                       currentSteal = ps;</span><br><span class="line">                       helped = <span class="keyword">true</span>; <span class="comment">//执行了任务，这里设为true</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Try to descend to find v&#x27;s stealer</span></span><br><span class="line">               ForkJoinTask&lt;?&gt; next = v.currentJoin;</span><br><span class="line">               <span class="keyword">if</span> (--levels &gt; <span class="number">0</span> &amp;&amp; task.status &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                   next != <span class="keyword">null</span> &amp;&amp; next != task) &#123;</span><br><span class="line">                   task = next;</span><br><span class="line">                   thread = v;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">break</span>;  <span class="comment">// max levels, stale, dead-end, or cyclic</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> helped;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><a id="Finally">小结</a></h2><p>本文只是简单地分析了Fork&amp;Join 框架的用法和实现。由于JDK 中 关于多线程的代码，有些还涉及到native得实现，并且代码可读性不是太好，导致有些理解不是很清楚。不过知道大体框架和使用方法，应该就可以满足日常使用了。</p><p>Fork Join 框架的思想，在很多地方都可以体现，只是实现的繁简而已。大任务的切割，小任务的并发执行，然后Reuce 各个子结果，就是我们想要的最终值了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Thread </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 多线程线程池分析</title>
      <link href="2014/05/03/2014-05-03-Java-MultiThread-ThreadPool-Introduce/"/>
      <url>2014/05/03/2014-05-03-Java-MultiThread-ThreadPool-Introduce/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>关于Java多线程的知识，看了很多博客书籍，对理论还是比较了解的。但是，最近写一个很简单的使用线程池对列表中任务进行处理，然后返回结果列表的功能，发现理论和实际操作还是有相当大的差距。</p><p>首先贴出一个很简单的代码demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ketao Date: 14-5-3 Time: 下午4:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: \$Id$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executors = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;thread-1&quot;</span>, <span class="string">&quot;thread-2&quot;</span>, <span class="string">&quot;thread-3&quot;</span>, <span class="string">&quot;thread-4&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; results = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> String str : list) &#123;</span><br><span class="line">            executors.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    results.add(str+<span class="string">&quot;test&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(JSON.toJSONString(results));</span><br><span class="line">        executors.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下，显然<code>results</code>的值并<strong>不是我们想要的结果</strong> ：</p><pre><code>[]pool-1-thread-1pool-1-thread-2pool-1-thread-2pool-1-thread-1</code></pre><h3 id="1-1-线程定义"><a href="#1-1-线程定义" class="headerlink" title="1.1 线程定义"></a>1.1 线程定义</h3><p>来自Java 并发大家 Doug Lea 关于线程的描述（<a href="http://ifeve.com/java-concurrency-constructs/">中文版</a>）：</p><blockquote><p>线程：其是一个独立执行的调用序列，同一个进程的线程在同一时刻共享一些系统资源（比如文件句柄等）也能访问同一个进程所创建的对象资源（内存资源）。</p></blockquote><p>由于一般的系统，最小的基本调度单位是线程，因此如果一个程序中只有一个线程的话，当该线程因为远程调用或者数据库访问，或者其他大量数学计算导致IO/CPU阻塞时，就会导致整个处理性能大幅度的降低。即使没有这些阻塞，对于当前多核处理系统来讲，单线程也会导致资源的浪费。因此，多线程可以帮助我们很好地提高系统的处理能力和吞吐能力。</p><h2 id="Java线程API"><a href="#Java线程API" class="headerlink" title="Java线程API"></a><a id="Thread">Java线程API</a></h2><p>在Java中可以通过<code>java.lang.Thread</code>创建线程。一般，应用中包括两种类型的线程：用户线程和守护线程。当应用启动时，会创建main线程，然后main线程可以创建多个用户线程和守护线程。当所有的用户线程都终止的时候，则JVM会终止程序。<br><strong>相对于用户线程而言，守护线程是为用户线程服务的，当所有的用户线程都退出的时候，守护线程就会全部退出，而不管守护线程当前的执行任务是否完成。</strong></p><h3 id="2-1-创建Thread"><a href="#2-1-创建Thread" class="headerlink" title="2.1 创建Thread"></a>2.1 创建Thread</h3><p>在java中，创建一个线程类对象很简单，有两种方式：其一，只需要继承<code>Thread</code>类，并且在子类中实现<code>run()</code>方法;其二，实现一个<code>Runnable</code>接口来创建线程。简单地demo如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ketao Date: 14-5-3 Time: 下午4:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: \$Id$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()); <span class="comment">// main</span></span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;创建一个java线程&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()); <span class="comment">// Thread-0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;创建一个java线程&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()); <span class="comment">// Thread==Runable=2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;Thread==Runable=2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>对于上面的两种创建线程的方法，推荐使用<code>Runnable</code>来实现，因为我们知道在java 线程池<code>ExecutorService</code>可以管理和使用<code>Runnable</code>接口的线程。<br>当请求超过线程池设置的大小后，新的请求会排队等待执行，直到所有的线程池空闲为止，如果通过<code>Thread 子类</code>来实现线程池，则会比较复杂。</p><blockquote><p>Tip: 在demo中使用<code>thread.run()</code>也可以得到相同的输出结果，但是，<strong>run() 的输出是由当前线程执行的，而不是新创建的线程</strong>。</p></blockquote><h3 id="2-2-创建守护线程"><a href="#2-2-创建守护线程" class="headerlink" title="2.2 创建守护线程"></a>2.2 创建守护线程</h3><p>守护线程，你可能没有注意过，但是在运行java服务的时候必然会遇到，因为一个典型的守护线程就是java垃圾回收线程。因此，当我们的java应用的所有用户线程都完成退出后，就不会再由内存垃圾产生，进而垃圾回收线程就不需要GC操作，对于只剩下守护线程时，JVM的操作就是退出，结束整个java应用环境。</p><p>参考网络上得一篇博文<a href="#http://blog.csdn.net/lcore/article/details/12280027">Java中的Daemon线程–守护线程</a>，给出一个deamon示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ketao Date: 14-5-3 Time: 下午4:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: \$Id$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;创建一个守护线程Deamon&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;deamon-thread-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;守护线程：  &quot;</span> + thread.isDaemon());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AddShutdownHook方法增加JVM停止时要做处理事件：</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当JVM退出时，打印JVM Exit语句.</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;JVM Exit!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Note: 守护线程不要去做一些文件、数据库等操作，因为一旦用户线程都完成操作退出后，守护线程也需要退出，这个时候可能会导致内存溢出等风险。</p></blockquote><h2 id="Java线程池API"><a href="#Java线程池API" class="headerlink" title="Java线程池API"></a><a id="ThreadPool">Java线程池API</a></h2><p>在前言中，引入的<code>ExecutorService</code>是对原生线程池<code>ThreadPoolExecutor</code>类的封装，提供了4种构造不同需求的线程池方法。首先，还是先介绍下<code>ThreadPoolExecutor</code>，API接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据给定的初始化参数创建一个新的 &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; 对象.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize 线程池中维持的线程数，即使所有线程都是空闲状态；除非设置了&#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125;。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maximumPoolSize 线程池中允许的最大数量的线程。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime 当线程数量比corePoolSize的值大时，这个变量指定了在结束之前，多余的线程等待新来任务时最长的时间。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 参数&#123;<span class="doctag">@code</span> keepAliveTime&#125; 的时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workQueue 在任务执行之前，存储这些任务的队列queue。这个队列只会保存通过&#123;<span class="doctag">@code</span> execute&#125;提交的&#123;<span class="doctag">@code</span> Runnable&#125;任务。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 当创建一个新的线程时候，使用的工厂factory对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 当执行任务出现阻塞的时候，使用的处理器handler。一般，可能当前的线程上线和队列容量都已经饱和的时候，</span></span><br><span class="line"><span class="comment">     *        就需要对新进来的任务执行相应处理策略。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment">     *         or &#123;<span class="doctag">@code</span> threadFactory&#125; or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span></span><br></pre></td></tr></table></figure><p>对于该构造函数的参数说明，已经对应的一些注意事项可以参考 <a href="http://dlc.sun.com.edgesuite.net/jdk/jdk-api-localizations/jdk-api-zh-cn/builds/latest/html/zh_CN/api/">JDK 6 ThreadPoolExecutor API中文</a>。但是需要对其中<code>BlockingQueue&lt;Runnable&gt;</code>，<code>ThreadFactory</code>，<code>RejectedExecutionHandler</code>进行说明。</p><h3 id="3-1-BlockingQueue-介绍"><a href="#3-1-BlockingQueue-介绍" class="headerlink" title="3.1 BlockingQueue 介绍"></a>3.1 BlockingQueue<Runnable> 介绍</h3><p>在jdk 6中对<code>BlockingQueue</code>接口进行了详细的说明，主要几点如下：</p><ol><li><p>BlockingQueue 实现主要用于生产者-使用者队列，但它另外还支持 Collection 接口。因此，举例来说，使用 remove(x) 从队列中移除任意一个元素是有可能的。然而，这种操作通常不会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。</p></li><li><p>BlockingQueue 实现是线程安全的。所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的。然而，大量的 Collection 操作（addAll、containsAll、retainAll 和 removeAll）没有 必要自动执行，除非在实现中特别说明。因此，举例来说，在只添加了 c 中的一些元素后，addAll(c) 有可能失败（抛出一个异常）。</p></li><li><p>BlockingQueue 实质上不 支持使用任何一种“close”或“shutdown”操作来指示不再添加任何项。这种功能的需求和使用有依赖于实现的倾向。例如，一种常用的策略是：对于生产者，插入特殊的 end-of-stream 或 poison 对象，并根据使用者获取这些对象的时间来对它们进行解释。</p></li><li><p>此外，BlockingQueue 可以安全地与多个生产者和多个使用者一起使用。</p></li></ol><p>在java 中默认实现了4种阻塞队列，提供四种不同的阻塞队列模型：</p><ol><li>ArrayBlockingQueue, 底层由数组构成的有界阻塞队列。按照FIFO(先进先出)策略对元素进行排序。因此，队列的头部是当前队列中，最早进入队列的元素，而队尾则是最后进入队列的元素。并且，新来的任务元素，都插入到队列的尾部，执行任务的时候，从队列的头部取出任务元素。</li><li>LinkedBlockingQueue, 底层由链表组成的阻塞队列。同样是按照FIFO策略对元素进行排序。和ArrayBlockingQueue不同的是，基于链表的阻塞队列可以不设置队列的大小，从而构造一个无界队列；此外，LinkedBlockingQueue的吞吐量也要高于数组的阻塞队列，不过，它会造成部分元素插入顺序的不确定性。</li><li>SynchronousQueue，同步的阻塞队列，不存储元素，没有任何内部容量。因此，这决定了该队列模型是一个同步操作，即每一个生产者的任务消息都会直接给消费者处理，而不会先保存起来，让消费者从队列中FIFO来获取最老的消息元素。其特点就是：每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。适合传递性设计，设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。</li><li>DelayQueue<E extends Delayed>，延迟的无界阻塞队列。队列中的元素只有在只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且 poll 将返回 null。</li><li>LinkedBlockingDeque，底层有双向链表构成的阻塞队列。和LinkedBlockingQueue一样，可以做无界队列，只是因为可以从两端插入和获取元素，所以时间消耗是单向链表的一半；当然这是一种空间换时的策略。该队列需要设置队列大小来防止过度膨胀。</li><li>PriorityBlockingQueue，一个无界的阻塞队列，它的使用和类 PriorityQueue 相同的顺序规则，并且提供了阻塞获取操作。虽然此队列逻辑上是无界的，但是资源被耗尽时试图执行 add 操作也将失败（导致 OutOfMemoryError）。iterator() 方法中提供的迭代器并不 保证以特定的顺序遍历 PriorityBlockingQueue 的元素。如果需要有序地进行遍历，则应考虑使用 Arrays.sort(pq.toArray())。此外，可以使用方法 drainTo 按优先级顺序移除 全部或部分元素，并将它们放在另一个 collection 中。</li></ol><p><strong>ArrayBlockingQueue：</strong>      </p><blockquote><p>Note: <code>ArrayBlockingQueue</code>队列是有界的队列，所以当队列满的时候，如果还向该队列插入元素，则会导致操作被阻塞住，当然，如果从空的队列中获取元素，该操作也会被阻塞。此外，构造<code>ArrayBlockingQueue</code>队列时，有一个参数为：<code> boolean fair</code> ：如果为 true，则按照 FIFO 顺序访问插入或移除时受阻塞线程的队列；如果为 false，则访问顺序是不确定的. </p></blockquote><p><strong>LinkedBlockingQueue：</strong>  </p><blockquote><p>Note: <code>LinkedBlockingQueue</code> 队列的吞吐量也要高于数组的阻塞队列，这主要是因为数组的特性和链表的特性决定的，链表在处理元素的offer队头元素和add队尾元素的速度要快于相应地数组操作。不过，显然这样会造成部分元素插入顺序的不确定性。</p></blockquote><p><strong><code>DelayQueue&lt;E extends Delayed&gt;</code>：</strong> </p><blockquote><p>Note: <code>DelayQueue&lt;E extends Delayed&gt;</code>队列中的元素需要实现<code>Delayed</code>接口，该接口只有<code>long getDelay(TimeUnit unit);</code>方法即可使用延迟阻塞队列。此外，需要注意，可能存在的时间延时，即任务元素不一定会准时执行，会有一点点的延迟。</p></blockquote><p><strong>LinkedBlockingDeque：</strong>  </p><blockquote><p>Note: <code>LinkedBlockingDeque</code>队列用的最多的地方，就是使用<code>工作窃取算法</code>的地方。工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。如下图（参考<a href="http://ifeve.com/talk-concurrency-forkjoin/">工作窃取运行说明</a>）：</p></blockquote><img src="/images/2014/05/work-stealing.png" /><p><strong>PriorityBlockingQueue：</strong> </p><blockquote><p>Note: <code>PriorityBlockingQueue</code>队列，默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。比较器可使用修改键断开主优先级值之间的联系。元素默认按照升序排列。</p></blockquote><p>选择其中的<code>LinkedBlockingQueue</code>来简单分析下，其内部实现结构和细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">     <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">     last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>); <span class="comment">// Node是链表中一个节点，包含一个元素和下一个元素的引用</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到，<code>LinkedBlockingQueue</code>实质上就是一个链表结构。作为阻塞的队列，在插入和移出元素的时候，肯定会加一个特殊的操作控制。在代码中，可以很清楚的看到，其消费者和生产者是通过singal来维护的，包括<code>notFull</code>和<code>notEmpty</code>两个信号变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 插入指定元素到队列的尾部，如果没有空间的话，等待。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">     <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">     <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">     Node&lt;E&gt; node = <span class="keyword">new</span> Node(e); <span class="comment">//创建插入链表的节点node</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock; <span class="comment">// 使用自旋锁，确保插入时线程安全</span></span><br><span class="line">     <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count; <span class="comment">// 原子类型整型</span></span><br><span class="line">     putLock.lockInterruptibly();<span class="comment">// 可中断加锁</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * 在这里的count并没有使用锁来保护，这是因为这里只有递减操作，并且我</span></span><br><span class="line"><span class="comment">          * 们在容量大小更改的时候将会发送信号，这和在其他等待guard计数相似。 </span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">             notFull.await(); <span class="comment">//等待，直到有空间插入元素</span></span><br><span class="line">         &#125;</span><br><span class="line">         enqueue(node); <span class="comment">// 插入元素</span></span><br><span class="line">         c = count.getAndIncrement(); <span class="comment">//插入成功</span></span><br><span class="line">         <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">             notFull.signal(); <span class="comment">//释放信号，队列未满</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         putLock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">         signalNotEmpty(); <span class="comment">//发送信号，表明当前队列为空。使用全局takeLock 自旋锁来加锁设置发送信号</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     E x;</span><br><span class="line">     <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">     takeLock.lockInterruptibly();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">             notEmpty.await();</span><br><span class="line">         &#125;</span><br><span class="line">         x = dequeue();</span><br><span class="line">         c = count.getAndDecrement();</span><br><span class="line">         <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">             notEmpty.signal();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         takeLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (c == capacity)</span><br><span class="line">         signalNotFull(); <span class="comment">//发送信号告知当前队列已满，使用全局putLock 自旋锁来加锁发送信号。</span></span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Note: <code>put</code>在插入的时候，会一直等待插入成功；如果需要设置等待超时时间，需要使用<code>offer(E e, long timeout, TimeUnit unit)</code>来插入元素。<br>此外，<code>take</code>方法和<code>put</code>方法整体流程基本一样。</p></blockquote><h3 id="3-2-ThreadFactory-介绍"><a href="#3-2-ThreadFactory-介绍" class="headerlink" title="3.2 ThreadFactory 介绍"></a>3.2 ThreadFactory 介绍</h3><p><code>ThreadFactory</code>，线程工厂，顾名思义，就是采用工厂模式来创建线程实例。使用<code>ThreadFactory</code>方式构建线程，可以不调用<code>&#123;@link Thread#Thread(Runnable) new Thread&#125;</code>方法来new 一个新的线程，这样可以更方便的让应用使用定制好了的线程子类，属性等。<br><code>ThreadFactory</code>接口，只有一个需要实现的方法，接口定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new &#123;<span class="doctag">@code</span> Thread&#125;.  Implementations may also initialize</span></span><br><span class="line"><span class="comment">     * priority, name, daemon status, &#123;<span class="doctag">@code</span> ThreadGroup&#125;, etc.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r a runnable to be executed by new thread instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> constructed thread, or &#123;<span class="doctag">@code</span> null&#125; if the request to</span></span><br><span class="line"><span class="comment">     *         create a thread is rejected</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一般使用<code>Executors</code>类中提供的<code>DefaultThreadFactory</code>对接口进行了简单地实现，我们在代码中使用<code>Executors</code>来创建线程池时，会用到这个默认线程工厂类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default thread factory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>); <span class="comment">//线程池序号</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>); <span class="comment">//线程所在池中的序号</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup(); <span class="comment">// 当前线程组名</span></span><br><span class="line">            namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">&quot;-thread-&quot;</span>; <span class="comment">// 线程前缀组合名</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>); <span class="comment">// 封装了new 对象的方法</span></span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>); <span class="comment">// 设置为非deamon 线程</span></span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY); <span class="comment">//设置为默认优先级 </span></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Note: 除了<code>Executors</code>使用的默认的线程工厂类之外，还提供了一个线程工厂类：<code>PrivilegedThreadFactory</code>类。该类继承了<code>DefaultThreadFactory</code>，增加了访问控制上下文和类加载器，会检查类的调用者是否有相关权限。例如：<code>System.getSecurityManager().checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</code>以及<code>System.getSecurityManager().checkPermission(new RuntimePermission(&quot;setContextClassLoader&quot;));</code>。</p></blockquote><h3 id="3-3-RejectedExecutionHandler-介绍"><a href="#3-3-RejectedExecutionHandler-介绍" class="headerlink" title="3.3 RejectedExecutionHandler 介绍"></a>3.3 RejectedExecutionHandler 介绍</h3><p><code>RejectedExecutionHandler</code>类是对线程池中不能被执行的任务，所需要采用的处理策略的指定。当 <code>executor</code> 不能接受某个任务时，可以由 <code>ThreadPoolExecutor</code> 调用<code>RejectedExecutionHandler</code>指定的处理方法。这种不能接受任务的情况，很容易就发生了，比如当超出其界限而没有更多可用的线程或队列池时，或者关闭 Executor 时。默认情况下，<code>private static final RejectedExecutionHandler defaultHandler = new AbortPolicy()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In the absence of other alternatives, the method may throw</span></span><br><span class="line"><span class="comment">     * an unchecked &#123;<span class="doctag">@link</span> RejectedExecutionException&#125;, which will be</span></span><br><span class="line"><span class="comment">     * propagated to the caller of &#123;<span class="doctag">@code</span> execute&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if there is no remedy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 6 提供了 4 种处理拒绝执行任务的策略：</p><pre><code>1. `AbortPolicy`类，该策略很简单，如果出现任务要被拒绝处理，则会抛出`RejectedExecutionException`异常，该策略为默认处理方式。2. `CallerRunsPolicy`类，该策略会直接在`execute`方法的调用线程中运行该呗拒绝执行的任务；如果执行程序已经关闭，则直接丢弃该任务。3. `DiscardOldestPolicy`类，该策略会在出现拒绝执行任务的时候，放弃队列中最老的未被处理的请求，然后重试execute；如果执行程序关闭，同样直接丢弃该任务。4. `DiscardPolicy`类，该策略同样很简单，就是如果出现被拒绝执行的任务，则直接丢弃该任务。</code></pre><p>比如<code>DiscardOldestPolicy</code>策略的实现，其把任务阻塞队列中得队头元素丢弃掉，然后重新执行该任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A handler for rejected tasks that discards the oldest unhandled</span></span><br><span class="line"><span class="comment">    * request and then retries &#123;<span class="doctag">@code</span> execute&#125;, unless the executor</span></span><br><span class="line"><span class="comment">    * is shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates a &#123;<span class="doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Obtains and ignores the next task that the executor</span></span><br><span class="line"><span class="comment">        * would otherwise execute, if one is immediately available,</span></span><br><span class="line"><span class="comment">        * and then retries execution of task r, unless the executor</span></span><br><span class="line"><span class="comment">        * is shut down, in which case task r is instead discarded.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">               e.getQueue().poll(); <span class="comment">// 丢弃最老的元素</span></span><br><span class="line">               e.execute(r); <span class="comment">//重试执行该拒绝任务</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Java-Executors类介绍"><a href="#Java-Executors类介绍" class="headerlink" title="Java Executors类介绍"></a><a id="Executors">Java Executors类介绍</a></h2><p>虽然<code>Executors</code>类只是对<code>ThreadPoolExecutor</code>的一些属性进行组合封装，但是，一般地，我们只需要使用该工具类完成创建线程池，就可以基本上满足我们的需求。<br><code>Executors</code>类提供了创建4种不同属性的线程池，分别为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程。</span></span><br><span class="line"><span class="comment">    * 在任意点，大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，</span></span><br><span class="line"><span class="comment">    * 剩余任务将在队列中一直等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。</span></span><br><span class="line"><span class="comment">    * 在某个线程被显式地关闭&#123;<span class="doctag">@link</span> ExecutorService#shutdown shutdown&#125;之前，池中的线程将一直存在。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nThreads the number of threads in the pool</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> threadFactory 默认使用Executors.defaultThreadFactory()线程工厂，使用抛出异常的AbortPolicy处理策略</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> nThreads &lt;= 0&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                     threadFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程，</span></span><br><span class="line"><span class="comment">    *（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。</span></span><br><span class="line"><span class="comment">    * 并在需要时使用提供的 ThreadFactory 创建新线程。与其他等效的 newFixedThreadPool(1, threadFactory) 不同，</span></span><br><span class="line"><span class="comment">    * 可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">           (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                   <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                   threadFactory));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。</span></span><br><span class="line"><span class="comment">    * 对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。</span></span><br><span class="line"><span class="comment">    * 如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。</span></span><br><span class="line"><span class="comment">    * 因此，长时间保持空闲的线程池不会使用任何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                     <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                     threadFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。</span></span><br><span class="line"><span class="comment">    *（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程会代替它执行后续的任务）。</span></span><br><span class="line"><span class="comment">    * 可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</span></span><br><span class="line"><span class="comment">    * 与其他等效的 newScheduledThreadPool(1, threadFactory) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">           (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, threadFactory));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> corePoolSize 池中所保存的线程数，即使线程是空闲的也包括在内。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在前言部分使用了<code>Executors.newFixedThreadPool</code>来创建固定线程数的线程池。因此，我们就对这个代码的整个流程进行说明。</p><blockquote><p>Note： 代码首先new 一个线程池，如上面代码所示，直接调用<code>ThreadPoolExecutor</code>构造函数即可。接下来就是创建任务放在线程池中执行了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在将来某个时间执行给定任务。可以在新线程中或者在现有池线程中执行该任务。 </span></span><br><span class="line"><span class="comment">    * 如果无法将任务提交执行，或者因为此执行程序已关闭，或者因为已达到其容量，则该任务由当前 RejectedExecutionHandler 处理。     </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 1. 如果比指定的corePoolSize值要少的线程在运行，则尝试着使用给定的factory来新建一个线程来运行该Runnable任务。</span></span><br><span class="line"><span class="comment">        * 这次addworker()方法的调用会自动检查运行状态和工作者worker数量，所以如果不允许增加worker则会返回false。具体实现参见下面分析。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 2. 如果任务被插入队列，然后我们仍然需要再次检查是否我们应该增加一个线程（可能会有某一个线程在上一次检查完之后挂掉了），</span></span><br><span class="line"><span class="comment">        * 或者一进入该方法，线程池就down掉了。所以我们重复检查状态，并在如果需要，则回滚进入队列，或者开启新的线程。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 3. 如果我们不可以插入任务到队列，则我们会尝试新加一个线程。如果增加失败，我们需要现在线程池已经关闭了或者饱和了，因此拒绝任务进入。</span></span><br><span class="line"><span class="comment">        */</span>                  </span><br><span class="line">       <span class="keyword">int</span> c = ctl.get(); <span class="comment">// 获取线程池中有效的线程数</span></span><br><span class="line">       <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">           <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">//增加新的工作线程运行新的任务command</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           c = ctl.get(); <span class="comment">//增加新的失败，则获得有效线程数，进行再次尝试</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// 如果worker正在运行任务，则把新的command放在queue中去。</span></span><br><span class="line">           <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">           <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">//非running状态的线程是不接受任务的，所以从队列中移除任务</span></span><br><span class="line">               reject(command); <span class="comment">//并且执行拒绝操作</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) <span class="comment">//如果当前没有running线程是因为线程池没有线程，则增加非core线程。</span></span><br><span class="line">               addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">           reject(command); <span class="comment">//增加线程失败，则调用对接的策略来执行拒绝该任务</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> removed = workQueue.remove(task);</span><br><span class="line">       tryTerminate(); <span class="comment">// In case SHUTDOWN and now empty</span></span><br><span class="line">       <span class="keyword">return</span> removed;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips: 在代码中，获取当前程序中运行的线程数，是一个很有趣的实现。核心代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程池控制状态 ctl，表示当前有效地线程数，此外还可以指示是否是running、shutdown等状态</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>; <span class="comment">//Integer.SIZE = 32</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;<span class="comment">// 00011111111111111111111111111111</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * RUNNING -&gt; SHUTDOWN</span></span><br><span class="line"><span class="comment">    *    On invocation of shutdown(), perhaps implicitly in finalize()</span></span><br><span class="line"><span class="comment">    * (RUNNING or SHUTDOWN) -&gt; STOP</span></span><br><span class="line"><span class="comment">    *    On invocation of shutdownNow()</span></span><br><span class="line"><span class="comment">    * SHUTDOWN -&gt; TIDYING</span></span><br><span class="line"><span class="comment">    *    When both queue and pool are empty</span></span><br><span class="line"><span class="comment">    * STOP -&gt; TIDYING</span></span><br><span class="line"><span class="comment">    *    When pool is empty</span></span><br><span class="line"><span class="comment">    * TIDYING -&gt; TERMINATED</span></span><br><span class="line"><span class="comment">    *    When the terminated() hook method has completed</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// runState 一共5种，使用高位的3位即可完全表示</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 11100000000000000000000000000000</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">// 00000000000000000000000000000000</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 00100000000000000000000000000000</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">// 01000000000000000000000000000000</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">// 01100000000000000000000000000000</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Packing and unpacking ctl</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="comment">//获取线程的状态</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125; <span class="comment">//获取线程池的线程数</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125; <span class="comment">//获取某一状态的值</span></span><br></pre></td></tr></table></figure><blockquote><p>Note: addWorker方法，会检查如果增加一个新的worker后，是否满足当前线程池的状态和最初创建线程池设置的大小限制。这可能会创建一个新的工作线程worker来运行该任务。但是，如果线程池停止或者将要关闭，再或者使用线程工厂创建新线程失败，都将返回false。<br><code>Worker</code>的继承<code>AbstractQueuedSynchronizer</code>类，该类是实现基于FIFO等待队列的阻塞锁和相关同步器的一个基本的框架，其可以依靠单个原子int值来表示状态。因此，<code>Worker</code>类其实主要目的就是为了维持线程的运行的任务的状态而存在的工作者队列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> core if true use corePoolSize as bound, else</span></span><br><span class="line"><span class="comment">     * maximumPoolSize. (A boolean indicator is used here rather than a</span></span><br><span class="line"><span class="comment">     * value to ensure reads of fresh values after checking other pool</span></span><br><span class="line"><span class="comment">     * state).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c); <span class="comment">//运行的状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.非running状态</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask); <span class="comment">// 新建worker，并且指定第一个任务</span></span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;<span class="comment">//正常的线程状态</span></span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        workers.add(w); <span class="comment">//非core线程数时，加入到任务队列中</span></span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start(); <span class="comment">//执行worker任务，详细见下面分析</span></span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码比较复杂，其主要就是判断新建worker线程的环境条件，如果可以创建，则执行相应地任务<code>w = new Worker(firstTask);final Thread t = w.thread; t.start()</code>，否则返回false；<code>execute</code>方法会执行相关拒绝策略的操作。</p><p><strong>Worker中任务的执行</strong><br>但是，从上面的代码中，我们看到<code>worker</code>的新建流程，并且把新任务作为参数来初始化worker，但是执行worker有一个目的只是为了测试worker实例是否创建成功。根据上面的API介绍，应该猜到其实大部分的任务到达线程池的时候，显然不是都新建一个线程来处理，而是放进<code>queue</code>中，然后执行。在<code>Worker</code>类中，封装需要执行的Runnable任务，然后其重写了run方法，内部调用<code>runWorker</code>执行任务。</p><blockquote><p>Note:<code>runWorker</code>是<code>worker</code>主要的工作。就是重复的从queue中获取任务，然后执行他们。整个流程大概如下：    </p><ol><li>我们可能会从一个初始的任务开始，当然非core数创建的<code>worker</code>则没有第一个<code>task</code>。此外<br> 在pool运行期间，我们使用<code>getTask</code>方法来获取任务。如果返回null的时候，则退出worker线程。<br> 另外，如果执行的任务会抛出异常，也会导致worker突然地完成，进而会使用<code>processWorkerExit</code>来代替该线程。    </li><li>在执行任何任务task之前，需要需求<code>lock</code>锁和调用<code>clearInterruptsForTaskRun</code>方法，这是为了防止在任务正在执行的时候，其他线程池中断。  </li><li>每个任务在递交运行之前，都会调用<code>beforeExecute</code>。这个方法可能会抛出一个异常，这个异常可以导致线程down掉，而不需要执行任务task。  </li><li>假设    <code>beforeExecute</code>顺利完成了，则开始运行task。在此期间产生的任务异常都会抛给<code>afterExecute</code>方法。分别会处理<code>RuntimeException</code>,<code>Error</code>,以及任意的<code>Throwables</code>。由于我们不可以在run方法中重新抛出<code>Throwables</code>，所以我们封装它们在即将过时的<code>Errors</code>里给线程的<code>UncaughtExceptionHandler</code>方法来处理。任何抛出来得异常也会导致线程down掉。  </li><li>在run方法完成之后，就会调用<code>afterExecute</code>方法，这也会抛出一个异常，当然也会导致线程down掉。According to <code>JLS Sec 14.20</code>, this exception is the one that will be in effect even if <code>task.run</code> throws.</li></ol></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts。使该worker状态为0，即可以运行新的任务。</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123; <span class="comment">//如果task为null的时候，则从队列中获取任务</span></span><br><span class="line">            w.lock(); <span class="comment">//设置0为1，表示该worker不可用，原子操作。</span></span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted()) <span class="comment">// 在这些情况下，需要中断当前的线程。</span></span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();<span class="comment">//执行任务</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);<span class="comment">//执行后处理异常等信息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();<span class="comment">//恢复当前worker可工作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);<span class="comment">//为脏worker执行清扫工作和记账工作，true时，方法会把worker的线程移出，或者替换worker等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从queue中获取需要执行的任务</span></span><br><span class="line"><span class="comment"> * Performs blocking or timed wait for a task, depending on</span></span><br><span class="line"><span class="comment"> * current configuration settings, or returns null if this worker</span></span><br><span class="line"><span class="comment"> * must exit because of any of:</span></span><br><span class="line"><span class="comment"> * 1. There are more than maximumPoolSize workers (due to</span></span><br><span class="line"><span class="comment"> *    a call to setMaximumPoolSize).</span></span><br><span class="line"><span class="comment"> * 2. The pool is stopped.</span></span><br><span class="line"><span class="comment"> * 3. The pool is shutdown and the queue is empty.</span></span><br><span class="line"><span class="comment"> * 4. This worker timed out waiting for a task, and timed-out</span></span><br><span class="line"><span class="comment"> *    workers are subject to termination (that is,</span></span><br><span class="line"><span class="comment"> *    &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span></span><br><span class="line"><span class="comment"> *    both before and after the timed wait.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> task, or null if the worker must exit, in which case</span></span><br><span class="line"><span class="comment"> *         workerCount is decremented</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        </span><br><span class="line">        ........</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 获取任务，超时设计判断获取逻辑</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Java-CountDownLatch类介绍"><a href="#Java-CountDownLatch类介绍" class="headerlink" title="Java CountDownLatch类介绍"></a><a id="CountDownLatch">Java CountDownLatch类介绍</a></h2><p><code>CountDownLatch</code>类，是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或者多个线程一直等待。</p><p>用给定的<code>计数Count</code> 初始化 <code>CountDownLatch</code>。由于调用了 <code>countDown()</code> 方法，所以在当前计数到达零之前，<code>await</code> 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要**重置计数，请考虑使用 <code>CyclicBarrier</code>**。</p><p><code>CountDownLatch</code> 是一个通用同步工具，它有很多用途。将计数 1 初始化的 <code>CountDownLatch</code> 用作一个简单的开/关锁存器，或入口：在通过调用 <code>countDown()</code> 的线程打开入口前，所有调用 <code>await</code> 的线程都一直在入口处等待。用 <code>N</code> 初始化的 <code>CountDownLatch</code> 可以使一个线程在 N 个线程完成某项操作之前一直等待，或者使其在某项操作完成 N 次之前一直等待。</p><p><code>CountDownLatch</code> 的一个有用特性是，它不要求调用 <code>countDown</code>方法的线程等到计数到达零时才继续， 而在所有线程都能通过之前，它只是通过一个 <code>await</code>阻止任何线程继续。</p><p>知道<code>CountDownLatch</code>类作用，我们就可以回到前言中说到的一个简单地多线程处理问题。我在一开始的时候，直接使用线程池执行多组任务，虽然考虑了多个线程在处理完任务之后，把结果add到list里面会有线程安全问题，但是放了一个非常大的<code>错误</code>，就是线程池创建完线程，分配给完所有任务之后，主线程Main会接着往下执行，即打印结果。而这时，非常大的可能是，线程全部都在执行，并没有结果add到list中，导致list可能并不是完整地结果集，甚至有些情况下list还会为空。</p><p>因此，这个时候就需要<code>CountDownLatch</code>上场了。经过修改的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ketao Date: 14-5-3 Time: 下午4:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: \$Id$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executors = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;thread-11&quot;</span>, <span class="string">&quot;thread-21&quot;</span>, <span class="string">&quot;thread-31&quot;</span>, <span class="string">&quot;thread-41&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; results = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(list.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> String str : list) &#123;</span><br><span class="line">            executors.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                        results.add(str + <span class="string">&quot;-test&quot;</span>);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(JSON.toJSONString(results));</span><br><span class="line">        executors.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a id="Finally">总结</a></h2><p>在最后，对于<code>CountDownLatch</code>类并没有详细的进行介绍，只是使用该类修复了前言中有问题的代码。其实在Java 7中，对于期待结果的多线程任务，推荐使用Fork &amp; Join 方式来处理。关于多线程其他方面的介绍，将在以后慢慢给出。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Thread </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java日志框架slf4j API介绍及异常接口实现分析</title>
      <link href="2014/05/02/2014-05-02-Java-slf4j-Introduce/"/>
      <url>2014/05/02/2014-05-02-Java-slf4j-Introduce/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>slf4j:简洁的java日志统一接口(Simple Logging Facade for Java),顾名思义,就是一个使用Facade设计模式实现的面向java Logging框架的接口开源包.<br>其和java数据库连接工具包JDBC很像, 在JDBC框架中, 各个不同数据库连接器分别针对不同数据库系统来实现对应的连接操作, 而普通程序员只需要使用统一的JDBC接口而不需要关注具体底层使用的数据库类型, 或者针对不同的数据库系统写各种兼容代码.</p><blockquote><p>Note: slf4j其实类似于适配器,但是这里不称呼适配器,是因为当底层log日志系统不支持slf4j扩展时,比如log4j,就需要在两者中间增加一个适配器层来完成slf4j调用相关日志系统的操作接口动作.例如,slf4j为log4j提高的slf4j-log412.jar类库,但是logback支持slf4J扩展,所以其不需适配层转换.</p></blockquote><p>同样，slf4j 不参与具体的日志代码实现，它只是在代码编译的时候根据程序的配置来绑定具体的日志系统。这样，使用slf4j类库就可以让你的代码独立于任意一个特定的日志API。因此，如果编写一个对外开发的API活着一个同样的类库，那么为了不限制使用你类库的代码必须使用指定的日志系统，你应该使用slf4j。</p><p>相对于其他日志框架，slf4j日志类库的优点和推荐使用的缘由，可以参见 ImportNew 的译文【 <a href="#http://www.importnew.com/7450.html">为什么要使用SLF4J而不是Log4J</a> 】</p><h2 id="Facade设计模式简介"><a href="#Facade设计模式简介" class="headerlink" title="Facade设计模式简介"></a><a id="Facade">Facade设计模式简介</a></h2><p>Facade模式，或者叫做外观模式，顾名思义就是封装各个底层子系统的提供的同一类功能接口，统一成一个更易操作使用的上层接口进而对外提供交互。有了这个上层封装的接口，接口调用方只需要调用这个接口，而不需要关于各个子系统的具体逻辑实现。</p><p>Facade设计模式的官方定义是：Facade模式定义了一个更高层的接口，使子系统更加容易使用。</p><span id="more"></span><p>关于Facade模式的实例，日常生活中很多这样子的例子。比如，5、1回家，可以有好几种方式：飞机、火车、长途汽车。在实际生活中，你回家的路线应该是：</p><pre><code>    1. 坐车去机场（火车站/长途汽车站）；    2. 坐飞机（火车/长途汽车）到家乡；    3. 从家乡飞机场（火车站/长途汽车站）到家里。 </code></pre><p>一般来说，上面的流程是毫无问题的。但是，如果做成一个系统，你需要对外暴露3个步骤中得3个不同的接口，外界需要根据不同的交通方式选择不同的调用接口，这无疑加大了接口调研的复杂度，以及系统的复杂度。如下图所示：</p><img src="/images/2014/05/facade.png" /><p>使用Facade模式，封装各个子系统的实现，对外提供3个接口：</p><pre><code>    1. 坐车其站点；    2. 做主交通工具到家乡；    3. 从家乡的站点回家里。</code></pre><p>因此，接口使用方不需要知道子系统具体是什么样的业务逻辑，其主要要在配置中，或者一开始指定交通工具，就可以让facade系统来完成下面的一系列操作。这样，除了让我们的系统对外暴露接口少了，最重要的是可以让第三方以最低的成本使用我们的接口。</p><h2 id="slf4j绑定日志"><a href="#slf4j绑定日志" class="headerlink" title="slf4j绑定日志"></a><a id="Bind">slf4j绑定日志</a></h2><h3 id="3-1-slf4j-设计模式说明"><a href="#3-1-slf4j-设计模式说明" class="headerlink" title="3.1 slf4j 设计模式说明"></a>3.1 slf4j 设计模式说明</h3><p>为了说明slf4j采用的Facade模式，也就是如果只引入slf4j-api包，日志系统将无法正常使用。例如在pom.xml文件这只有：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>       </span><br></pre></td></tr></table></figure><p>而<a id="BindCode">测试代码</a>为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ketao Date: 14-5-3 Time: 上午1:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: \$Id$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(LogTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure><p>执行上面的代码会出现提示：</p><pre><code>SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.SLF4J: Defaulting to no-operation (NOP) logger implementationSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</code></pre><p>而如果我们引入logback日志系统，并且配置logback.xml日志配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        </span><br></pre></td></tr></table></figure><p>接下来执行上面的测试代码，则会打印日志信息：</p><pre><code>[2014-05-03 01:27:11 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:17)] Hello world[2014-05-03 01:27:11 [1;31mERROR[0;39m com.qunar.dubbo.LogTest.main(LogTest.java:18)] ERROR</code></pre><h3 id="3-2-slf4j-日志绑定流程"><a href="#3-2-slf4j-日志绑定流程" class="headerlink" title="3.2 slf4j 日志绑定流程"></a>3.2 slf4j 日志绑定流程</h3><p>如<a href="#BindCode">3.1</a>中的代码所示，首先调用<code>LoggerFactory.getLogger</code>的方法，这个方法会在编译的时候，绑定系统设置的真正的日志框架，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return a logger named according to the name parameter using the statically</span></span><br><span class="line"><span class="comment">   * bound &#123;<span class="doctag">@link</span> ILoggerFactory&#125; instance.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name The name of the logger.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> logger</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    ILoggerFactory iLoggerFactory = getILoggerFactory(); <span class="comment">// 这里先获取ILoggerFactory对象</span></span><br><span class="line">    <span class="keyword">return</span> iLoggerFactory.getLogger(name); <span class="comment">// 根据获取的ILoggerFactory对象，调用其对应的日志对象</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the &#123;<span class="doctag">@link</span> ILoggerFactory&#125; instance in use.</span></span><br><span class="line"><span class="comment">   * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">   * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">   * ILoggerFactory instance is bound with this class at compile time.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the ILoggerFactory instance in use</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ILoggerFactory <span class="title">getILoggerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</span><br><span class="line">      INITIALIZATION_STATE = ONGOING_INITIALIZATION;</span><br><span class="line">      performInitialization();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (INITIALIZATION_STATE) &#123;</span><br><span class="line">      <span class="keyword">case</span> SUCCESSFUL_INITIALIZATION:</span><br><span class="line">        <span class="keyword">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();<span class="comment">// 这里就可以获取底层日志系统的单例对象了</span></span><br><span class="line">      <span class="keyword">case</span> NOP_FALLBACK_INITIALIZATION:</span><br><span class="line">        <span class="keyword">return</span> NOP_FALLBACK_FACTORY;</span><br><span class="line">      <span class="keyword">case</span> FAILED_INITIALIZATION:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(UNSUCCESSFUL_INIT_MSG);</span><br><span class="line">      <span class="keyword">case</span> ONGOING_INITIALIZATION:</span><br><span class="line">        <span class="comment">// support re-entrant behavior.</span></span><br><span class="line">        <span class="comment">// See also http://bugzilla.slf4j.org/show_bug.cgi?id=106</span></span><br><span class="line">        <span class="keyword">return</span> TEMP_FACTORY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unreachable code&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而绑定是在<code>getILoggerFactory()</code>中调用的，在该方法的实现里，会调用<code>performInitialization()</code>，该方法调用<code>bind()</code>方法（部分代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Set staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();<span class="comment">// 寻找程序配置的日志系统集，具体见下面代码</span></span><br><span class="line">      reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);<span class="comment">// 验证多于1个日志系统时，输出警告信息</span></span><br><span class="line">      <span class="comment">// the next line does the binding</span></span><br><span class="line">      StaticLoggerBinder.getSingleton();<span class="comment">// 测试是否可以获取该静态绑定类单例，可以，则置为成功状态，如下行；否则，会打出3.1中的NOP异常信息。</span></span><br><span class="line">      INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;</span><br><span class="line">      reportActualBinding(staticLoggerBinderPathSet);<span class="comment">// 绑定，打印绑定具体日志系统的日志</span></span><br><span class="line">      emitSubstituteLoggerWarning();<span class="comment">// 提交给临时日志factory 打印的日志，不是重点</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError ncde) &#123;</span><br><span class="line">      String msg = ncde.getMessage();</span><br><span class="line">      <span class="keyword">if</span> (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) &#123;</span><br><span class="line">        INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;</span><br><span class="line">        Util.report(<span class="string">&quot;Failed to load class \&quot;org.slf4j.impl.StaticLoggerBinder\&quot;.&quot;</span>);</span><br><span class="line">        Util.report(<span class="string">&quot;Defaulting to no-operation (NOP) logger implementation&quot;</span>);</span><br><span class="line">        Util.report(<span class="string">&quot;See &quot;</span> + NO_STATICLOGGERBINDER_URL</span><br><span class="line">                + <span class="string">&quot; for further details.&quot;</span>);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;        </span><br></pre></td></tr></table></figure><p>下面看看，slf4j是如何获取系统中指定的真正底层日志系统：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We need to use the name of the StaticLoggerBinder class, but we can&#x27;t reference</span></span><br><span class="line">  <span class="comment">// the class itself.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String STATIC_LOGGER_BINDER_PATH = <span class="string">&quot;org/slf4j/impl/StaticLoggerBinder.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Set <span class="title">findPossibleStaticLoggerBinderPathSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// use Set instead of list in order to deal with  bug #138</span></span><br><span class="line">    <span class="comment">// LinkedHashSet appropriate here because it preserves insertion order during iteration</span></span><br><span class="line">    Set staticLoggerBinderPathSet = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ClassLoader loggerFactoryClassLoader = LoggerFactory.class</span><br><span class="line">              .getClassLoader();</span><br><span class="line">      Enumeration paths;</span><br><span class="line">      <span class="keyword">if</span> (loggerFactoryClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        paths = loggerFactoryClassLoader</span><br><span class="line">                .getResources(STATIC_LOGGER_BINDER_PATH);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (paths.hasMoreElements()) &#123;</span><br><span class="line">        URL path = (URL) paths.nextElement();</span><br><span class="line">        staticLoggerBinderPathSet.add(path);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">      Util.report(<span class="string">&quot;Error getting resources from path&quot;</span>, ioe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> staticLoggerBinderPathSet;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>slf4j在适配器层或者在兼容slf4j扩展的log-api 中会有一个<code>org/slf4j/impl/StaticLoggerBinder.class</code>类，这样就获取了系统中真正的日志系统。然后获取该日志的单例，打印相关的日志信息就可以了。比如，打印slf4j的<code>log.info</code>则调用logback中<code>Logger.info()</code>方法来打印日志信息。</p><h2 id="slf4j-API使用"><a href="#slf4j-API使用" class="headerlink" title="slf4j API使用"></a><a id="API">slf4j API使用</a></h2><p>slf4j的打印日志基本一致，主要分为：<code>trace</code>,<code>debug</code>,<code>info</code>,<code>warn</code>,<code>error</code>,比log4j少了<code>fatal</code>级别日志。由于每个级别对于的API方法级别一致，因此，这里选用info来介绍不同输入参数的API使用。</p><blockquote><p>Tip: SLF4J 认为 ERROR 与 FATAL 并没有实质上的差别，所以拿掉了 FATAL 等级，只剩下其他五种。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 纯字符串形式的日志</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String msg)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 指定一个参数和位置格式的info级别的日志输出形式。这个形式避免了多个object对象的创建。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String format, Object arg)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 指定2个参数和对于位置格式的info级别的日志输出。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String format, Object arg1, Object arg2)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据指定的参数和日志格式来输出info级别的日志信息。</span></span><br><span class="line"><span class="comment">  * 但是，需要指出这种形式虽然避免的字符串拼接的成本，但是它会私底下创建一个`Object[]`对象在调用info方法之前，即使info级别的日志不打印。</span></span><br><span class="line"><span class="comment">  * 因此，如果不是必须3个及以上参数的话，推荐使用两个参数和一个参数的info日志。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String format, Object... arguments)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 打印抛出异常信息的info 级别日志</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String msg, Throwable t)</span></span>;</span><br></pre></td></tr></table></figure><p>此外，需要介绍的是在slf4j中还提供了含有Marker对象的日记输出API接口。Marker是常常被用来丰富log状态的对象。遵守slf4j的日志系统实现，决定了信息怎样在使用的Marker之间传达。实际上，很多遵守规范的日志系统会忽视掉marker数据,所以，我们不介绍Marker相关API接口。</p><p>下面给出各个接口的使用示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ketao Date: 14-5-3 Time: 上午1:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: \$Id$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(LogTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;纯字符串信息的info级别日志&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;一个参数:&#123;&#125;的info级别日志&quot;</span>, <span class="string">&quot;agr1&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;二个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;的info级别日志&quot;</span>, <span class="string">&quot;args1&quot;</span>, <span class="string">&quot;args2&quot;</span>);</span><br><span class="line">        <span class="comment">// 下面两种方式都可以，一般使用上面一种就可以了</span></span><br><span class="line">        logger.info(<span class="string">&quot;三个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;;args3:&#123;&#125; 的info级别日志&quot;</span>, <span class="string">&quot;args1&quot;</span>, <span class="string">&quot;args2&quot;</span>, <span class="string">&quot;args3&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;三个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;;args3:&#123;&#125; 的info级别日志&quot;</span>, <span class="keyword">new</span> Object[] &#123; <span class="string">&quot;args1&quot;</span>, <span class="string">&quot;args2&quot;</span>, <span class="string">&quot;args3&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;======================异常相关====================================&quot;</span>);</span><br><span class="line">        <span class="comment">// 测试异常相关日志</span></span><br><span class="line">        logger.info(<span class="string">&quot;抛出异常,e:&quot;</span>, <span class="keyword">new</span> IOException(<span class="string">&quot;测试抛出IO异常信息&quot;</span>));</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;二个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;的info级别日志&quot;</span>, <span class="string">&quot;args1&quot;</span>, <span class="keyword">new</span> IOException(<span class="string">&quot;测试抛出IO异常信息&quot;</span>));</span><br><span class="line">        logger.info(<span class="string">&quot;二个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;的info级别日志&quot;</span>, <span class="string">&quot;args1&quot;</span>, <span class="string">&quot;args2&quot;</span>, <span class="keyword">new</span> IOException(<span class="string">&quot;测试抛出IO异常信息&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面两种方式都可以，一般使用上面一种就可以了</span></span><br><span class="line">        logger.info(<span class="string">&quot;三个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;;args3:&#123;&#125; 的info级别日志&quot;</span>, <span class="string">&quot;args1&quot;</span>, <span class="string">&quot;args2&quot;</span>, <span class="keyword">new</span> IOException(<span class="string">&quot;测试抛出IO异常信息&quot;</span>));</span><br><span class="line">        logger.info(<span class="string">&quot;三个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;;args3:&#123;&#125; 的info级别日志&quot;</span>, <span class="string">&quot;args1&quot;</span>, <span class="string">&quot;args2&quot;</span>, <span class="string">&quot;agrs3&quot;</span>, <span class="keyword">new</span> IOException(</span><br><span class="line">                <span class="string">&quot;测试抛出IO异常信息&quot;</span>));</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;三个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;;args3:&#123;&#125; 的info级别日志&quot;</span>, <span class="keyword">new</span> Object[] &#123; <span class="string">&quot;args1&quot;</span>, <span class="string">&quot;args2&quot;</span>, <span class="string">&quot;args3&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> IOException(<span class="string">&quot;测试抛出IO异常信息&quot;</span>) &#125;);</span><br><span class="line">        logger.info(<span class="string">&quot;三个参数:agrs1:&#123;&#125;;agrs2:&#123;&#125;;args3:&#123;&#125; 的info级别日志&quot;</span>, <span class="keyword">new</span> Object[] &#123; <span class="string">&quot;args1&quot;</span>, <span class="string">&quot;args2&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> IOException(<span class="string">&quot;测试抛出IO异常信息&quot;</span>) &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应输出日志信息：</p><pre><code>[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:20)] 纯字符串信息的info级别日志[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:21)] 一个参数:agr1的info级别日志[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:22)] 二个参数:agrs1:args1;agrs2:args2的info级别日志[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:24)] 三个参数:agrs1:args1;agrs2:args2;args3:args3 的info级别日志[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:25)] 三个参数:agrs1:args1;agrs2:args2;args3:args3 的info级别日志[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:27)] ======================异常相关====================================[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:29)] 抛出异常,e:java.io.IOException: 测试抛出IO异常信息    at com.qunar.dubbo.LogTest.main(LogTest.java:29) [classes/:na]    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_45]    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_45]    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_45]    at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_45]    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120) [idea_rt.jar:na][2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:31)] 二个参数:agrs1:args1;agrs2:java.io.IOException: 测试抛出IO异常信息的info级别日志[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:32)] 二个参数:agrs1:args1;agrs2:args2的info级别日志java.io.IOException: 测试抛出IO异常信息    at com.qunar.dubbo.LogTest.main(LogTest.java:32) [classes/:na]    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_45]    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_45]    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_45]    at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_45]    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120) [idea_rt.jar:na][2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:35)] 三个参数:agrs1:args1;agrs2:args2;args3:java.io.IOException: 测试抛出IO异常信息 的info级别日志[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:36)] 三个参数:agrs1:args1;agrs2:args2;args3:agrs3 的info级别日志java.io.IOException: 测试抛出IO异常信息    at com.qunar.dubbo.LogTest.main(LogTest.java:36) [classes/:na]    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_45]    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_45]    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_45]    at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_45]    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120) [idea_rt.jar:na][2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:38)] 三个参数:agrs1:args1;agrs2:args2;args3:args3 的info级别日志java.io.IOException: 测试抛出IO异常信息    at com.qunar.dubbo.LogTest.main(LogTest.java:38) [classes/:na]    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_45]    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_45]    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_45]    at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_45]    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120) [idea_rt.jar:na][2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:39)] 三个参数:agrs1:args1;agrs2:args2;args3:java.io.IOException: 测试抛出IO异常信息 的info级别日志</code></pre><blockquote><p>Note: 从代码调用可以看到，throwable 异常信息单独作为一个参数输入，因此，如果把异常信息作为<code>&#123;&#125;</code>占位符中的字符串，则会调用其对应toString方法，而无法打印异常堆栈信息。可以看看下面的截取源码：  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String msg, Throwable t)</span> </span>&#123;</span><br><span class="line">  filterAndLog_0_Or3Plus(FQCN, <span class="keyword">null</span>, Level.INFO, msg, <span class="keyword">null</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当日志的参数string 大于1，并且包含 Throwable类型参数，则调用下面的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String format, Object[] argArray)</span> </span>&#123;</span><br><span class="line">  filterAndLog_0_Or3Plus(FQCN, <span class="keyword">null</span>, Level.INFO, format, argArray, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在logback代码中，作者表明如果不使用Object[]创建参数数组对象，则会减少20 纳秒的时间开销。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">filterAndLog_0_Or3Plus</span><span class="params">(<span class="keyword">final</span> String localFQCN,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> Marker marker, <span class="keyword">final</span> Level level, <span class="keyword">final</span> String msg,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> Object[] params, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> FilterReply decision = loggerContext</span><br><span class="line">      .getTurboFilterChainDecision_0_3OrMore(marker, <span class="keyword">this</span>, level, msg,</span><br><span class="line">          params, t);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (decision == FilterReply.NEUTRAL) &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectiveLevelInt &gt; level.levelInt) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (decision == FilterReply.DENY) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buildLoggingEventAndAppend(localFQCN, marker, level, msg, params, t);<span class="comment">// 在这个方法里面，会LoggingEvent方法构架日志信息，而对于Throwable非空时，则会创建一个ThrowableProxy对象，具体代码见下面。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码，是对日志中的异常打印信息。显然，在messageFormat里面，使用String来处理，是无法获得这么丰富的异常堆栈信息的。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThrowableProxy</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">this</span>.throwable = throwable;</span><br><span class="line">  <span class="keyword">this</span>.className = throwable.getClass().getName();</span><br><span class="line">  <span class="keyword">this</span>.message = throwable.getMessage();</span><br><span class="line">  <span class="keyword">this</span>.stackTraceElementProxyArray = ThrowableProxyUtil.steArrayToStepArray(throwable</span><br><span class="line">      .getStackTrace());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//下面构建详细异常的堆栈信息，这也就是我们在代码输出时，看到的一大坨at... 输出错误代码位置等。</span></span><br><span class="line">  Throwable nested = throwable.getCause();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (nested != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cause = <span class="keyword">new</span> ThrowableProxy(nested);</span><br><span class="line">    <span class="keyword">this</span>.cause.commonFrames = ThrowableProxyUtil</span><br><span class="line">        .findNumberOfCommonFrames(nested.getStackTrace(),</span><br><span class="line">            stackTraceElementProxyArray);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(GET_SUPPRESSED_METHOD != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// this will only execute on Java 7</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object obj = GET_SUPPRESSED_METHOD.invoke(throwable);</span><br><span class="line">      <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Throwable[]) &#123;</span><br><span class="line">        Throwable[] throwableSuppressed = (Throwable[]) obj;</span><br><span class="line">        <span class="keyword">if</span>(throwableSuppressed.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          suppressed = <span class="keyword">new</span> ThrowableProxy[throwableSuppressed.length];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;throwableSuppressed.length;i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.suppressed[i] = <span class="keyword">new</span> ThrowableProxy(throwableSuppressed[i]);</span><br><span class="line">            <span class="keyword">this</span>.suppressed[i].commonFrames = ThrowableProxyUtil</span><br><span class="line">                .findNumberOfCommonFrames(throwableSuppressed[i].getStackTrace(),</span><br><span class="line">                    stackTraceElementProxyArray);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="comment">// ignore</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">      <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Note: 上面代码只是一般的步骤，对于调用<code>Object[]</code>形式的方法，则<code>ThrowableProxy</code>之前，还会对<code>Object[]</code>中的元素进行过滤处理，提取出最后一个元素判断是不是 <code>Throwable</code>类型的对象。代码参考如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">static</span> FormattingTuple <span class="title">format</span><span class="params">(<span class="keyword">final</span> String messagePattern,</span></span></span><br><span class="line"><span class="params"><span class="function">      Object arg1, Object arg2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arrayFormat(messagePattern, <span class="keyword">new</span> Object[] &#123; arg1, arg2 &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这方法会对输入参数进行特殊处理和过滤</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">static</span> FormattingTuple <span class="title">arrayFormat</span><span class="params">(<span class="keyword">final</span> String messagePattern,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">final</span> Object[] argArray)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Throwable throwableCandidate = getThrowableCandidate(argArray);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L &lt; argArray.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FormattingTuple(sbuf.toString(), argArray, throwableCandidate);<span class="comment">// 如果元素中有Throwable类型，则size会减少，因此，对应的Throwale参数位置为 置提取出来的异常对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FormattingTuple(sbuf.toString(), argArray, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> Throwable <span class="title">getThrowableCandidate</span><span class="params">(Object[] argArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argArray == <span class="keyword">null</span> || argArray.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object lastEntry = argArray[argArray.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (lastEntry <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line">      <span class="keyword">return</span> (Throwable) lastEntry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a><a id="End">后记</a></h2><p>slf4j的日志，打印抛出异常的信息时，如果只需要message，则需要在log api接口中的String 里面对应位置添加<code>&#123;&#125;</code>符号；否则，如果想要打印全量<font color="red">异常栈信息，则<strong>不能也不可以</strong></font>在string字符串中添加<code>&#123;&#125;</code>，不然会大失所望。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Log </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Intelij IDEA 远程调试Tomcat服务</title>
      <link href="2014/04/29/2014-04-29-Intelij-IDEA-Remote-Debug-Tomcat-App/"/>
      <url>2014/04/29/2014-04-29-Intelij-IDEA-Remote-Debug-Tomcat-App/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>在很多情况下，我们在本地启动调试一些服务；或者说外部调用开发测试环境某些服务时，需要直接调试定位问题代码点；<br>这些问题都会让我们需要可以在本地IDE上面调试本地代码来查看线上情况。最近和其他业务部门联调的时候，<br>了解到原来真的可以debug本地代码同步控制线上运行流程。下面，记录一下具体的操作配置步骤。</p><h2 id="线上服务配置"><a href="#线上服务配置" class="headerlink" title="线上服务配置"></a><a id="Server">线上服务配置</a></h2><p>目前线上的整个tomcat的服务脚本配置：</p><ol><li>一台机器上放一个全局脚本，比如放置在<code>/home/tomcat/bin</code>目录下；</li><li>机器上的每一个tomcat实例目录里面都会有一些基本的设置，比如tomcat的<code>conf</code>目录，以及<code>startenv.sh</code>文件，</li><li><code>startenv.sh</code>文件目前的配置为：  </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TOMCAT_USER=<span class="string">&quot;tomcat&quot;</span></span><br><span class="line"><span class="built_in">export</span> JAVA_OPTS=<span class="string">&quot;-Xms512m -Xmx1024m -XX:NewSize=256m -XX:PermSize=256m -server -XX:+DisableExplicitGC -Dqunar.logs=<span class="variable">$CATALINA_BASE</span>/logs -Dqunar.cache=<span class="variable">$CATALINA_BASE</span>/cache -verbose:gc -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:<span class="variable">$CATALINA_BASE</span>/logs/gc.log&quot;</span></span><br><span class="line">chown -R tomcat:tomcat <span class="variable">$CATALINA_BASE</span>/logs</span><br><span class="line">chown -R tomcat:tomcat <span class="variable">$CATALINA_BASE</span>/cache</span><br><span class="line">chown -R tomcat:tomcat <span class="variable">$CATALINA_BASE</span>/conf</span><br><span class="line">chown -R tomcat:tomcat <span class="variable">$CATALINA_BASE</span>/work</span><br><span class="line">chown -R tomcat:tomcat <span class="variable">$CATALINA_BASE</span>/temp</span><br></pre></td></tr></table></figure><span id="more"></span><p>因此，为了方便，我们只需要增加debug相关配置在JAVA_OPTS就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=9999,server=y,<span class="built_in">suspend</span>=n</span><br></pre></td></tr></table></figure><blockquote><p>Note: 这里的端口指定为9999，你也可以自己指定。主要是JVM绑定端口使用。</p></blockquote><pre><code>-Xdebug                    |启用调试特性-Xrunjdwp                |启用JDWP实现，它包含若干子选项：transport=dt_socket        |JPDA front-end和back-end之间的传输方法。dt_socket表示使用套接字传输。address=9999            |JVM在9999端口上监听请求。server=y                |y表示启动的JVM是被调试者。如果为n，则表示启动的JVM是调试器。suspend=y                |y表示启动的JVM会暂停等待，直到调试器连接上。suspend=y这个选项很重要。如果你想从Tomcat启动的一开始就进行调试，那么就必须设置suspend=y。</code></pre><p>接下来，重新启动线上服务，就可以在本地调试相关app了。</p><h2 id="IDE本地配置"><a href="#IDE本地配置" class="headerlink" title="IDE本地配置"></a><a id="Client">IDE本地配置</a></h2><p>本地使用的IDE是Intelij IDEA 开发工具，具体操作步骤为：</p><p>1、 在IDEA上面新建一个 tomcat remote server服务：<br><img src="/images/2014/04/newremote.png" /></p><blockquote><p>Note:图片中的端口是web服务的端口号，而不是JVM监听绑定的端口号。</p></blockquote><img src="/images/2014/04/debugaddress.png" />> Note:图片中的端口是JVM监听绑定的端口号，即我们在服务端设置绑定的address值。<p>2、 接下来就可以通过debug来启动本地服务，当出现下面字样时，表示连接成功，可以debug了。</p><pre><code>client：      Connected to server    Connected to the target VM, address: &#39;l-hds2.h.dev.cn6.qunar.com:9999&#39;, transport: &#39;socket&#39;  server：      Listening for transport dt_socket at address: 9999      Listening for transport dt_socket at address: 9999      Listening for transport dt_socket at address: 9999</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> IDE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Google Java编程风格指南</title>
      <link href="2014/04/16/2014-04-16-google-java-style/"/>
      <url>2014/04/16/2014-04-16-google-java-style/</url>
      
        <content type="html"><![CDATA[<p>说明：来自互联网，如有版权问题，请告知本人将其撤下。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="Intro">前言</a></h2><p>这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，<br>我们才认为它符合Google的Java编程风格。</p><p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，<br>同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，<br>对于那些不是明确强制要求的，我们尽量避免提供意见。</p><h3 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h3><p>在本文档中，除非另有说明：</p><ol><li>术语class可表示一个普通类，枚举类，接口或是annotation类型(<code>@interface</code>)</li><li>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。</li></ol><p>其他的术语说明会偶尔在后面的文档出现。</p><h3 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h3><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。<br>示例中的格式选择不应该被强制定为规则。</p><span id="more"></span><h2 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a><a id="SFBasic">源文件基础</a></h2><h3 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h3><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为<code>.java</code>。</p><h3 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h3><p>源文件编码格式为UTF-8。</p><h3 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h3><h4 id="2-3-1-空白字符"><a href="#2-3-1-空白字符" class="headerlink" title="2.3.1 空白字符"></a>2.3.1 空白字符</h4><p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p><ol><li>所有其它字符串中的空白字符都要进行转义。</li><li>制表符不用于缩进。</li></ol><h4 id="2-3-2-特殊转义序列"><a href="#2-3-2-特殊转义序列" class="headerlink" title="2.3.2 特殊转义序列"></a>2.3.2 特殊转义序列</h4><p>对于具有特殊<a href="http://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97">转义序列</a>的任何字符(\b, \t, \n, \f, \r, &quot;, &#39;及\)，我们使用它的转义序列，而不是相应的八进制(比如<code>\012</code>)或Unicode(比如<code>\u000a</code>)转义。</p><h4 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h4><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。</p><blockquote><p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p></blockquote><p>例如：</p><pre><code>String unitAbbrev = &quot;μs&quot;;                                 | 赞，即使没有注释也非常清晰String unitAbbrev = &quot;\u03bcs&quot;; // &quot;μs&quot;                    | 允许，但没有理由要这样做String unitAbbrev = &quot;\u03bcs&quot;; // Greek letter mu, &quot;s&quot;    | 允许，但这样做显得笨拙还容易出错String unitAbbrev = &quot;\u03bcs&quot;;                            | 很糟，读者根本看不出这是什么return &#39;\ufeff&#39; + content; // byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释</code></pre><blockquote><p>Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行，<br>你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)</p></blockquote><h2 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a><a id="SFStruct">源文件结构</a></h2><p>一个源文件包含(按顺序地)：</p><ol><li>许可证或版权信息(如有需要)</li><li>package语句</li><li>import语句</li><li>一个顶级类(<strong>只有一个</strong>)</li></ol><p>以上每个部分之间用一个空行隔开。</p><h3 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p><h3 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h3><p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p><h3 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h3><h4 id="3-3-1-import不要使用通配符"><a href="#3-3-1-import不要使用通配符" class="headerlink" title="3.3.1 import不要使用通配符"></a>3.3.1 import不要使用通配符</h4><p>即，不要出现类似这样的import语句：<code>import java.util.*;</code></p><h4 id="3-3-2-不要换行"><a href="#3-3-2-不要换行" class="headerlink" title="3.3.2 不要换行"></a>3.3.2 不要换行</h4><p>import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)</p><h4 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h4><p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p><ol><li>所有的静态导入独立成组</li><li><code>com.google</code> imports(仅当这个源文件是在<code>com.google</code>包下)</li><li>第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun</li><li><code>java</code> imports</li><li><code>javax</code> imports</li></ol><p>组内不空行，按字典序排列。</p><h3 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h3><h4 id="3-4-1-只有一个顶级类声明"><a href="#3-4-1-只有一个顶级类声明" class="headerlink" title="3.4.1 只有一个顶级类声明"></a>3.4.1 只有一个顶级类声明</h4><p>每个顶级类都在一个与它同名的源文件中(当然，还包含<code>.java</code>后缀)。</p><p>例外：<code>package-info.java</code>，该文件中可没有<code>package-info</code>类。</p><h4 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h4><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。<br>最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如，<br>新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p><h5 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h5><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a><a id="Format">格式</a></h2><p><strong>术语说明</strong>：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p><h3 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h3><h4 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h4><p>大括号与<code>if, else, for, do, while</code>语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p><h4 id="4-1-2-非空块：K-amp-R-风格"><a href="#4-1-2-非空块：K-amp-R-风格" class="headerlink" title="4.1.2 非空块：K &amp; R 风格"></a>4.1.2 非空块：K &amp; R 风格</h4><p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格<br>(<a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html">Egyptian brackets</a>):</p><ul><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyClass() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        something();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ProblemException e) &#123;</span><br><span class="line">        recover();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4.8.1节给出了enum类的一些例外。</p><h4 id="4-1-3-空块：可以用简洁版本"><a href="#4-1-3-空块：可以用简洁版本" class="headerlink" title="4.1.3 空块：可以用简洁版本"></a>4.1.3 空块：可以用简洁版本</h4><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成<code>&#123;&#125;</code>，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally)<br>，即使大括号内没内容，右大括号也要换行。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothing</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-块缩进：2个空格"><a href="#4-2-块缩进：2个空格" class="headerlink" title="4.2 块缩进：2个空格"></a>4.2 块缩进：2个空格</h3><p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p><h3 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h3><p>每个语句后要换行。</p><h3 id="4-4-列限制：80或100"><a href="#4-4-列限制：80或100" class="headerlink" title="4.4 列限制：80或100"></a>4.4 列限制：80或100</h3><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p><p>例外：</p><ol><li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。</li><li><code>package</code>和<code>import</code>语句(见3.2节和3.3节)。</li><li>注释中那些可能被剪切并粘贴到shell中的命令行。</li></ol><h3 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h3><p><strong>术语说明</strong>：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p><p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p><blockquote><p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p></blockquote><h4 id="4-5-1-从哪里断开"><a href="#4-5-1-从哪里断开" class="headerlink" title="4.5.1 从哪里断开"></a>4.5.1 从哪里断开</h4><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p><ol><li>如果在<code>非赋值运算符</code>处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。<br>这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（<code>&lt;T extends Foo &amp; Bar&gt;</code>)，catch块中的管道符号(<code>catch (FooException | BarException e</code>)</li><li>如果在<code>赋值运算符</code>处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于<code>foreach</code>语句中的分号。</li><li>方法名或构造函数名与左括号留在同一行。</li><li>逗号(,)与其前面的内容留在同一行。</li></ol><h4 id="4-5-2-自动换行时缩进至少-4个空格"><a href="#4-5-2-自动换行时缩进至少-4个空格" class="headerlink" title="4.5.2 自动换行时缩进至少+4个空格"></a>4.5.2 自动换行时缩进至少+4个空格</h4><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p><p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p><p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p><h3 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h3><h4 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h4><p>以下情况需要使用一个空行：</p><ol><li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。<ul><li><strong>例外</strong>：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li></ul></li><li>在函数体内，语句的逻辑分组间使用空行。</li><li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li><li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li></ol><p>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</p><h4 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h4><p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p><ol><li>分隔任何保留字与紧随其后的左括号(<code>(</code>)(如<code>if, for catch</code>等)。</li><li>分隔任何保留字与其前面的右大括号(<code>&#125;</code>)(如<code>else, catch</code>)。</li><li>在任何左大括号前(<code>&#123;</code>)，两个例外：<ul><li><code>@SomeAnnotation(&#123;a, b&#125;)</code>(不使用空格)。</li><li><code>String[][] x = &#123;&#123;"foo"&#125;&#125;;</code>(大括号间没有空格，见下面的Note)。</li></ul></li><li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：<ul><li>类型界限中的&amp;(<code>&lt;T extends Foo &amp; Bar&gt;</code>)。</li><li>catch块中的管道符号(<code>catch (FooException | BarException e</code>)。</li><li><code>foreach</code>语句中的分号。</li></ul></li><li>在<code>, : ;</code>及右括号(<code>)</code>)后</li><li>如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。</li><li>类型和变量之间：List<String> list。</li><li>数组初始化中，大括号内的空格是可选的，即<code>new int[] &#123;5, 6&#125;</code>和<code>new int[] &#123; 5, 6 &#125;</code>都是可以的。</li></ol><blockquote><p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p></blockquote><h4 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h4><p><strong>术语说明</strong>：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p><p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p><p>以下示例先展示未对齐的代码，然后是对齐的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x; <span class="comment">// this is fine</span></span><br><span class="line"><span class="keyword">private</span> Color color; <span class="comment">// this too</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>   x;      <span class="comment">// permitted, but future edits</span></span><br><span class="line"><span class="keyword">private</span> Color color;  <span class="comment">// may leave it unaligned</span></span><br></pre></td></tr></table></figure><blockquote><p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。<br>这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)，<br>这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p></blockquote><h3 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h3><p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。<br>我们没有理由假设读者能记住整个Java运算符优先级表。</p><h3 id="4-8-具体结构"><a href="#4-8-具体结构" class="headerlink" title="4.8 具体结构"></a>4.8 具体结构</h3><h4 id="4-8-1-枚举类"><a href="#4-8-1-枚举类" class="headerlink" title="4.8.1 枚举类"></a>4.8.1 枚举类</h4><p>枚举常量间用逗号隔开，换行可选。</p><p>没有方法和文档的枚举类可写成数组初始化的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> </span>&#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;</span><br></pre></td></tr></table></figure><p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p><h4 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h4><h5 id="4-8-2-1-每次只声明一个变量"><a href="#4-8-2-1-每次只声明一个变量" class="headerlink" title="4.8.2.1 每次只声明一个变量"></a>4.8.2.1 每次只声明一个变量</h5><p>不要使用组合声明，比如<code>int a, b;</code>。</p><h5 id="4-8-2-2-需要时才声明，并尽快进行初始化"><a href="#4-8-2-2-需要时才声明，并尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，并尽快进行初始化"></a>4.8.2.2 需要时才声明，并尽快进行初始化</h5><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。<br>局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p><h4 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h4><h5 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h5><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>,</span><br><span class="line">  <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h5><p>中括号是类型的一部分：<code>String[] args</code>， 而非<code>String args[]</code>。</p><h4 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h4><p><strong>术语说明</strong>：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(<code>case FOO:</code>或<code>default:</code>)，后面跟着一条或多条语句。</p><h5 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h5><p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p><p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p><h5 id="4-8-4-2-Fall-through：注释"><a href="#4-8-4-2-Fall-through：注释" class="headerlink" title="4.8.4.2 Fall-through：注释"></a>4.8.4.2 Fall-through：注释</h5><p>在一个switch块内，每个语句组要么通过<code>break, continue, return</code>或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，<br>任何能表达这个意思的注释都是OK的(典型的是用<code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (input) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    prepareOneOrTwo();</span><br><span class="line">    <span class="comment">// fall through</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    handleOneTwoOrThree();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    handleLargeNumber(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-8-4-3-default的情况要写出来"><a href="#4-8-4-3-default的情况要写出来" class="headerlink" title="4.8.4.3 default的情况要写出来"></a>4.8.4.3 default的情况要写出来</h5><p>每个switch语句都包含一个<code>default</code>语句组，即使它什么代码也不包含。</p><h4 id="4-8-5-注解-Annotations"><a href="#4-8-5-注解-Annotations" class="headerlink" title="4.8.5 注解(Annotations)"></a>4.8.5 注解(Annotations)</h4><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNameIfPresent</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p><strong>例外</strong>：单个的注解可以和签名的第一行出现在同一行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Partial</span> <span class="meta">@Mock</span> DataLoader loader;</span><br></pre></td></tr></table></figure><p>参数和局部变量注解没有特定规则。</p><h4 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h4><h5 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h5><p>块注释与其周围的代码在同一缩进级别。它们可以是<code>/* ... */</code>风格，也可以是<code>// ...</code>风格。对于多行的<code>/* ... */</code>注释，后续行必须从<code>*</code>开始，<br>并且与前一行的<code>*</code>对齐。以下示例注释都是OK的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is          // And so           /* Or you can</span></span><br><span class="line"><span class="comment"> * okay.            // is this.          * even do this. */</span></span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>注释不要封闭在由星号或其它字符绘制的框架里。</p><blockquote><p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用<code>/* ... */</code>。</p></blockquote><h4 id="4-8-7-Modifiers"><a href="#4-8-7-Modifiers" class="headerlink" title="4.8.7 Modifiers"></a>4.8.7 Modifiers</h4><p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">synchronized</span> <span class="keyword">native</span> <span class="keyword">strictfp</span></span><br></pre></td></tr></table></figure><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a><a id="Naming">命名约定</a></h2><h3 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h3><p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\w+</code>。</p><p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>, <code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p><h3 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h3><h4 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h4><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p><h4 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h4><p>类名都以<code>UpperCamelCase</code>风格编写。</p><p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p><p>测试类的命名以它要测试的类的名称开始，以<code>Test</code>结束。例如，<code>HashTest</code>或<code>HashIntegrationTest</code>。</p><h4 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h4><p>方法名都以<code>lowerCamelCase</code>风格编写。</p><p>方法名通常是动词或动词短语。</p><p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如<code>testPop_emptyStack</code>。<br>并不存在唯一正确的方式来命名测试方法。</p><h4 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h4><p>常量名命名模式为<code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p><p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时，<br>考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。<br>只是永远不<code>打算</code>改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableList&lt;String&gt; NAMES = ImmutableList.of(<span class="string">&quot;Ed&quot;</span>, <span class="string">&quot;Ann&quot;</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Joiner COMMA_JOINER = Joiner.on(<span class="string">&#x27;,&#x27;</span>);  <span class="comment">// because Joiner is immutable</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnum</span> </span>&#123; ENUM_CONSTANT &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not constants</span></span><br><span class="line"><span class="keyword">static</span> String nonFinal = <span class="string">&quot;non-final&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String nonStatic = <span class="string">&quot;non-static&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; mutableCollection = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(MyClass.getName());</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] nonEmptyArray = &#123;<span class="string">&quot;these&quot;</span>, <span class="string">&quot;can&quot;</span>, <span class="string">&quot;change&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>这些名字通常是名词或名词短语。</p><h4 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h4><p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p><p>这些名字通常是名词或名词短语。</p><h4 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h4><p>参数名以<code>lowerCamelCase</code>风格编写。</p><p>参数应该避免用单个字符命名。</p><h4 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h4><p>局部变量名以<code>lowerCamelCase</code>风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p><p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p><p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p><h4 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h4><p>类型变量可用以下两种风格之一进行命名：</p><ul><li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li><li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li></ul><h3 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h3><p><a href="http://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB">驼峰式命名法</a>分大驼峰式命名法(<code>UpperCamelCase</code>)和小驼峰式命名法(<code>lowerCamelCase</code>)。<br>有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</p><p>名字从<code>散文形式</code>(prose form)开始:</p><ol><li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li><li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul><li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。<br>需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li></ul></li><li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul><li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li><li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li></ul></li><li>最后将所有的单词连接起来得到一个标识符。</li></ol><p>示例：</p><pre><code>Prose form                Correct               Incorrect------------------------------------------------------------------&quot;XML HTTP request&quot;        XmlHttpRequest        XMLHTTPRequest&quot;new customer ID&quot;         newCustomerId         newCustomerID&quot;inner stopwatch&quot;         innerStopwatch        innerStopWatch&quot;supports IPv6 on iOS?&quot;   supportsIpv6OnIos     supportsIPv6OnIOS&quot;YouTube importer&quot;        YouTubeImporter                          YoutubeImporter*</code></pre><p>加星号处表示可以，但不推荐。</p><blockquote><p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p></blockquote><h2 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a><a id="Practice">编程实践</a></h2><h3 id="6-1-Override：能用则用"><a href="#6-1-Override：能用则用" class="headerlink" title="6.1 @Override：能用则用"></a>6.1 @Override：能用则用</h3><p>只要是合法的，就把<code>@Override</code>注解给用上。</p><h3 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h3><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p><p>如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> i = Integer.parseInt(response);</span><br><span class="line">  <span class="keyword">return</span> handleNumericResponse(i);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException ok) &#123;</span><br><span class="line">  <span class="comment">// it&#x27;s not numeric; that&#x27;s fine, just continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handleTextResponse(response);</span><br></pre></td></tr></table></figure><p><strong>例外</strong>：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常，<br>因此在这里就没有必要加注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  emptyStack.pop();</span><br><span class="line">  fail();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException expected) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-静态成员：使用类进行调用"><a href="#6-3-静态成员：使用类进行调用" class="headerlink" title="6.3 静态成员：使用类进行调用"></a>6.3 静态成员：使用类进行调用</h3><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo aFoo = ...;</span><br><span class="line">Foo.aStaticMethod(); <span class="comment">// good</span></span><br><span class="line">aFoo.aStaticMethod(); <span class="comment">// bad</span></span><br><span class="line">somethingThatYieldsAFoo().aStaticMethod(); <span class="comment">// very bad</span></span><br></pre></td></tr></table></figure><h3 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h3><p>极少会去重载<code>Object.finalize</code>。</p><blockquote><p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解<a href="http://books.google.com/books?isbn=8131726592">Effective Java</a><br>第7条款：“Avoid Finalizers”，然后不要使用它。</p></blockquote><h2 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a><a id="Javadoc">Javadoc</a></h2><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><h4 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h4><p>Javadoc块的基本格式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Multiple lines of Javadoc text are written here,</span></span><br><span class="line"><span class="comment"> * wrapped normally...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(String p1)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>或者是以下单行形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** An especially short bit of Javadoc. */</span></span><br></pre></td></tr></table></figure><p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p><h4 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h4><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。<br>除了第一个段落，每个段落第一个单词前都有标签<code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。</p><h4 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h4><p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。<br>当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p><h3 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h3><p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p><p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A &#123;@code Foo&#125; is a...</code>或<code>This method returns...</code>开头,<br>它也不会是一个完整的祈使句，如<code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p><blockquote><p>Tip：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p></blockquote><h3 id="7-3-哪里需要使用Javadoc"><a href="#7-3-哪里需要使用Javadoc" class="headerlink" title="7.3 哪里需要使用Javadoc"></a>7.3 哪里需要使用Javadoc</h3><p>至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：</p><h4 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h4><p>对于简单明显的方法如<code>getFoo</code>，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p><p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p><blockquote><p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>，<br>就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p></blockquote><h4 id="7-3-2-例外：重载"><a href="#7-3-2-例外：重载" class="headerlink" title="7.3.2 例外：重载"></a>7.3.2 例外：重载</h4><p>如果一个方法重载了超类中的方法，那么Javadoc并非必需的。</p><h4 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h4><p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为，<br>那么这个注释应该写成Javadoc，这样更统一更友好。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a><a id="End">后记</a></h2><p>本文档翻译自<a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html">Google Java Style</a>，<br>译者<a href="http://weibo.com/hawstein">@Hawstein</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
